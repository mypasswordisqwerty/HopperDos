{
  "00": " CPU-generated - DIVIDE ERROR\r\n",
  "01": " CPU-generated - SINGLE STEP\r\n",
  "02": " external hardware - NON-MASKABLE INTERRUPT\r\n",
  "03": " CPU-generated - BREAKPOINT\r\n",
  "04": " CPU-generated - INTO DETECTED OVERFLOW\r\n",
  "05": " PRINT SCREEN\r\n",
  "06": " CPU-generated (80186+) - INVALID OPCODE\r\n",
  "07": " CPU-generated (80286+) - PROCESSOR EXTENSION NOT AVAILABLE\r\n",
  "08": " IRQ0 - SYSTEM TIMER\r\n",
  "09": " IRQ1 - KEYBOARD DATA READY\r\n",
  "0A": " IRQ2 - LPT2 (PC), VERTICAL RETRACE INTERRUPT (EGA,VGA)\r\n",
  "0B": " IRQ3 - SERIAL COMMUNICATIONS (COM2)\r\n",
  "0C": " IRQ4 - SERIAL COMMUNICATIONS (COM1)\r\n",
  "0D": " IRQ5 - FIXED DISK (PC,XT), LPT2 (AT), reserved (PS/2)\r\n",
  "0E": " IRQ6 - DISKETTE CONTROLLER\r\n",
  "0F": " IRQ7 - PARALLEL PRINTER\r\n",
  "10": {
    "AH": {
      "00": " VIDEO - SET VIDEO MODE\r\n\tAL = desired video mode (see #00010)\r\n\nReturn: AL = video mode flag (Phoenix, AMI BIOS)\r\n\n\t    20h mode > 7\r\n\n\t    30h modes 0-5 and 7\r\n\n\t    3Fh mode 6\r\n\n\tAL = CRT controller mode byte (Phoenix 386 BIOS v1.10)\r\n",
      "01": " VIDEO - SET TEXT-MODE CURSOR SHAPE\r\n\tCH = cursor start and options (see #00013)\r\n\n\tCL = bottom scan line containing cursor (bits 0-4)\r\n\nReturn: nothing\r\n",
      "02": " VIDEO - SET CURSOR POSITION\r\n\tBH = page number\r\n\n\t    0-3 in modes 2&3\r\n\n\t    0-7 in modes 0&1\r\n\n\t    0 in graphics modes\r\n\n\tDH = row (00h is top)\r\n\n\tDL = column (00h is left)\r\n\nReturn: nothing\r\n",
      "03": " VIDEO - GET CURSOR POSITION AND SIZE\r\n\tBH = page number\r\n\n\t    0-3 in modes 2&3\r\n\n\t    0-7 in modes 0&1\r\n\n\t    0 in graphics modes\r\n\nReturn: AX = 0000h (Phoenix BIOS)\r\n\n\tCH = start scan line\r\n\n\tCL = end scan line\r\n\n\tDH = row (00h is top)\r\n\n\tDL = column (00h is left)\r\n",
      "04": " HUNTER 16 - GET CURSOR ADDRESS\r\n\tBH = page\r\n\nReturn: DH = row (0..24)\r\n\n\tDL = column (0..79)\r\n\n\tCH = cursor pixel Y-address (0..199)\r\n\n\tCL = cursor pixel X-address (0..639)\r\n",
      "05": " VIDEO - PCjr, Tandy 1000 - SET CRT/CPU PAGE REGISTERS\r\n\tAL = subfunction\r\n\n\t    81h set CPU page register\r\n\n\t\tBL = CPU page\r\n\n\t    82h set CRT page register\r\n\n\t\tBH = CRT page\r\n\n\t    83h set both CPU and CRT page registers\r\n\n\t\tBL = CPU page\r\n\n\t\tBH = CRT page\r\n\nReturn: nothing\r\n",
      "06": " VIDEO - SCROLL UP WINDOW\r\n\tAL = number of lines by which to scroll up (00h = clear entire window)\r\n\n\tBH = attribute used to write blank lines at bottom of window\r\n\n\tCH,CL = row,column of window's upper left corner\r\n\n\tDH,DL = row,column of window's lower right corner\r\n\nReturn: nothing\r\n",
      "07": " VIDEO - SCROLL DOWN WINDOW\r\n\tAL = number of lines by which to scroll down (00h=clear entire window)\r\n\n\tBH = attribute used to write blank lines at top of window\r\n\n\tCH,CL = row,column of window's upper left corner\r\n\n\tDH,DL = row,column of window's lower right corner\r\n\nReturn: nothing\r\n",
      "08": " VIDEO - READ CHARACTER AND ATTRIBUTE AT CURSOR POSITION\r\n\tBH = page number (00h to number of pages - 1) (see #00010)\r\n\nReturn: AH = character's attribute (text mode only) (see #00014)\r\n\n\tAH = character's color (Tandy 2000 graphics mode only)\r\n\n\tAL = character\r\n",
      "09": " VIDEO - WRITE CHARACTER AND ATTRIBUTE AT CURSOR POSITION\r\n\tAL = character to display\r\n\n\tBH = page number (00h to number of pages - 1) (see #00010)\r\n\n\t    background color in 256-color graphics modes (ET4000)\r\n\n\tBL = attribute (text mode) or color (graphics mode)\r\n\n\t    if bit 7 set in <256-color graphics mode, character is XOR'ed\r\n\n\t      onto screen\r\n\n\tCX = number of times to write character\r\n\nReturn: nothing\r\n",
      "0A": " VIDEO - WRITE CHARACTER ONLY AT CURSOR POSITION\r\n\tAL = character to display\r\n\n\tBH = page number (00h to number of pages - 1) (see #00010)\r\n\n\t    background color in 256-color graphics modes (ET4000)\r\n\n\tBL = attribute (PCjr, Tandy 1000 only) or color (graphics mode)\r\n\n\t    if bit 7 set in <256-color graphics mode, character is XOR'ed\r\n\n\t      onto screen\r\n\n\tCX = number of times to write character\r\n\nReturn: nothing\r\n",
      "0B": " Tandy 2000 - VIDEO - SET PALETTE ENTRY\r\n\tBH = 02h\r\n\n\tBL = palette entry number\r\n\n\tAL = new color value for palette entry\r\n\nReturn: nothing\r\n",
      "0C": " VIDEO - WRITE GRAPHICS PIXEL\r\n\tBH = page number\r\n\n\tAL = pixel color\r\n\n\t    if bit 7 set, value is XOR'ed onto screen except in 256-color modes\r\n\n\tCX = column\r\n\n\tDX = row\r\n\nReturn: nothing\r\n",
      "0D": " VIDEO - READ GRAPHICS PIXEL\r\n\tBH = page number\r\n\n\tCX = column\r\n\n\tDX = row\r\n\nReturn: AL = pixel color\r\n",
      "0E": " VIDEO - TELETYPE OUTPUT\r\n\tAL = character to write\r\n\n\tBH = page number\r\n\n\tBL = foreground color (graphics modes only)\r\n\nReturn: nothing\r\n",
      "0F": " FRIEZE v7.41+ - INSTALLATION CHECK\r\n\tSI = F123h\r\n\n\tDI = 321Fh\r\n\nReturn: AH = number of character columns\r\n\n\tAL = display mode (see #00010 at AH=00h)\r\n\n\tBH = active page (see AH=05h)\r\n\n\tSI = DI = F345h if installed\r\n",
      "10": " Tandy 2000 - VIDEO - GET/SET CHARACTER FONTS\r\n\tAL = control value\r\n\n\t    bit 0: set character set instead of reading it\r\n\n\t    bit 1: high 128 characters instead of low 128 characters\r\n\n\tES:BX -> new character set if AL bit 0 set\r\n\nReturn: ES:BX -> current character set if AL bit 0 clear on entry\r\n",
      "11": " VIDEO - Realtek RTVGA - TEXT-MODE CHARACTER GENERATOR FUNCTIONS\r\n\tAL = 07h load user-specified patterns and recalculate mode parms\r\n\n\t\t parameters are the same as for AX=1110h\r\n\n\tAL = 08h load monochrome patterns (8x14) and recalculate mode parms\r\n\n\t\t parameters are the same as for AX=1111h\r\n\n\tAL = 09h load ROM 8 by 8 double-dot patterns and recalculate mode parms\r\n\n\t\t parameters are the same as for AX=1112h\r\n\n\tAL = 0Bh load ROM 8x16 character set (VGA) and recalculate mode parms\r\n\n\t\t parameters are the same as for AX=1114h\r\n",
      "12": " Tseng ET-4000 BIOS - GET/SET SCREEN REFRESH RATE\r\n\tBL = F1h\r\n\n\tAL = subfunction\r\n\n\t    00h set refresh rate\r\n\n\t    01h get refresh rate\r\n\n\tBH = video mode\r\n\n\t    00h\t 640x480\r\n\n\t    01h\t 800x600\r\n\n\t    02h\t 1024x768\r\n\n\t    03h\t 1280x1024\r\n\n\tCX = new refresh rate (see #00035) if AL = 00h\r\n\nReturn: AL = 12h if supported\r\n\n\t    CX = current rate (for AL=00h, a changed CX indicates failure)\r\n",
      "13": " VIDEO - WRITE STRING (AT and later,EGA)\r\n\tAL = write mode\r\n\n\t   bit 0: update cursor after writing\r\n\n\t   bit 1: string contains alternating characters and attributes\r\n\n\t   bits 2-7: reserved (0)\r\n\n\tBH = page number\r\n\n\tBL = attribute if string contains only characters\r\n\n\tCX = number of characters in string\r\n\n\tDH,DL = row,column at which to start writing\r\n\n\tES:BP -> string to write\r\n\nReturn: nothing\r\n",
      "15": " VIDEO - SET SUPERIMPOSE MODE (Sperry PC)\r\n\tAL = superimpose mode\r\n\n\t    00h show graphics screen\r\n\n\t    01h show text screen\r\n\n\t    02h show text screen superimposed on graphics screen\r\n\nReturn: nothing\r\n",
      "19": " Japanese VIDEO - DOUBLE-BYTE CHARACTER SET SHIFT INFORMATION\r\n\t???\r\n\nReturn: ???\r\n",
      "1B": " VIDEO - FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)\r\n\tBX = implementation type\r\n\n\t    0000h return funtionality/state information\r\n\n\tES:DI -> 64-byte buffer for state information (see #00040)\r\n\nReturn: AL = 1Bh if function supported\r\n\n\t    ES:DI buffer filled with state information\r\n",
      "1C": " VIDEO - SAVE/RESTORE VIDEO STATE (PS50+,VGA)\r\n\tAL = function\r\n\n\t    00h return state buffer size\r\n\n\t\tReturn: BX = number of 64-byte blocks needed\r\n\n\t    01h save video state\r\n\n\t\tES:BX -> buffer\r\n\n\t    02h restore video state\r\n\n\t\tES:BX -> buffer containing previously saved state\r\n\n\tCX = requested states (see #00048)\r\n\nReturn: AL = 1Ch if function supported\r\n",
      "1D": " Tseng ET-4000 BIOS v3.00 and v8.00 - BUG\r\n",
      "40": " VIDEO - Hercules GRAFIX - \"GMODE\" - SET GRAPHICS MODE\r\nReturn: nothing\r\n",
      "41": " VIDEO - Hercules GRAFIX - \"TMODE\" - SET TEXT MODE\r\nReturn: nothing\r\n",
      "42": " VIDEO - Hercules GRAFIX - \"CLRSCR\" - CLEAR CURRENT PAGE\r\nReturn: nothing\r\n",
      "43": " VIDEO - Hercules GRAFIX - \"GPAGE\" - SELECT DRAWING PAGE\r\n\tAL = page number (0,1)\r\n\nReturn: nothing\r\n",
      "44": " VIDEO - Hercules GRAFIX - \"LEVEL\" - SELECT DRAWING FUNCTION\r\n\tAL = drawing function\r\n\n\t    00h clear pixels\r\n\n\t    01h set pixels\r\n\n\t    02h invert pixels\r\n\nReturn: nothing\r\n",
      "45": " VIDEO - Hercules GRAFIX - \"DISP\" - SELECT PAGE TO DISPLAY\r\n\tAL = page number (0,1)\r\n\nReturn: nothing\r\n",
      "46": " VIDEO - Hercules GRAFIX - \"PLOT\" - DRAW ONE PIXEL\r\n\tDI = x (0-719)\r\n\n\tBP = y (0-347)\r\n\nReturn: nothing\r\n",
      "47": " VIDEO - Hercules GRAFIX - \"GETPT\" - FIND PIXEL VALUE\r\n\tDI = x (0-719)\r\n\n\tBP = y (0-347)\r\n\nReturn: AL = 00h pixel clear\r\n\n\tAL = 01h pixel set\r\n",
      "48": " VIDEO - Hercules GRAFIX - \"MOVE\" - MOVE TO POINT\r\n\tDI = x (0-719)\r\n\n\tBP = y (0-347)\r\n\nReturn: nothing\r\n",
      "49": " VIDEO - Hercules GRAFIX - \"DLINE\" - DRAW TO POINT\r\n\tDI = x (0-719)\r\n\n\tBP = y (0-347)\r\n\nReturn: nothing\r\n",
      "4A": " VIDEO - Hercules GRAFIX - \"BLKFIL\" - BLOCK FILL\r\n\tDI = x coordinate of lower left corner\r\n\n\tBP = y coordinate of lower left corner\r\n\n\tBX = height in pixels\r\n\n\tCX = width in pixels\r\n\nReturn: nothing\r\n",
      "4B": " VIDEO - Hercules GRAFIX - \"TEXT\" - DISPLAY CHARACTER\r\n\tAL = character to display\r\n\n\tDI = x (0-719)\r\n\n\tBP = y (0-347)\r\n\nReturn: nothing\r\n",
      "4C": " VIDEO - Hercules GRAFIX - \"ARC\" - DRAW ARC\r\n\tAL = quadrant (1 = upper right, 2 = upper left, etc)\r\n\n\tDI = x coordinate of center\r\n\n\tBP = y coordinate of center\r\n\n\tBX = radius\r\n\nReturn: nothing\r\n",
      "4D": " VIDEO - Hercules GRAFIX - \"CIRC\" - DRAW CIRCLE\r\n\tDI = x of center\r\n\n\tBP = y of center\r\n\n\tBX = radius\r\n\nReturn: nothing\r\n",
      "4E": " VIDEO - Hercules GRAFIX - \"FILL\" - FILL AREA\r\n\tDI = x coordinate of an interior point\r\n\n\tBP = y coordinate of an interior point\r\n\nReturn: nothing\r\n",
      "60": " HUNTER 16 - SET GRAPHICS FONT\r\n\tAL = new font\r\n\n\t    bit 7    output characters in reverse video\r\n\n\t    bits 0-6 font number (see #00200 at AH=77h)\r\n\nReturn: BH = cell width\r\n\n\tBL = cell height\r\n",
      "61": " HUNTER 16 - MOVE CURSOR TO GRAPHICS CO-ORDINATES\r\n\tCX = column\r\n\n\tDX = row\r\n\nReturn: nothing\r\n",
      "62": " HUNTER 16 - GET CURSOR POSITION IN GRAPHICS CO-ORDINATES\r\nReturn: CX = column\r\n\n\tDX = row\r\n",
      "63": " HUNTER 16 - SET CONTRAST\r\n\tAL = contrast (0..127)\r\n\nReturn: nothing\r\n",
      "64": " HUNTER 16 - SET BACKLIGHT LEVEL\r\n\tAL = level (0..15)\r\n\nReturn: nothing\r\n",
      "66": " HUNTER 16 - SPLIT DISPLAY\r\n\tAL = control bits (see #00187)\r\n\n\tBH = top row of lower section of LCD (0..7)\r\n\n\tBL = top row of lower section of the virtual screen (0..24)\r\n\nReturn: nothing\r\n",
      "70": " HUNTER 16 - DRAW ELLIPSE/CIRCLE\r\n\tDS:BX -> control block (see #00192)\r\n\nReturn: nothing\r\n",
      "71": " HUNTER 16 - DRAW LINE/BOX\r\n\tDS:BX -> control block (see #00199)\r\n\nReturn: nothing\r\n",
      "72": " HUNTER 16 - SELECT TEXT-MODE INVERSE VIDEO MECHANISM\r\n\tAL = mechanism to use\r\n\n\t    00h do not use inverse video\r\n\n\t    01h emulate MDA. Display attribute 07h is normal video and 70h is\r\n\n\t\tinverse video.\r\n\n\t    02h use inverse video if background is non-black.\r\n\n\t    03h use inverse video for high intensity text.\r\n\n\t    04h use inverse video for text with background intensity greater\r\n\n\t\tthan foreground intensity.\r\n\n\t    05h use inverse video for text with background color other than\r\n\n\t\tblack or high intensity foreground.\r\n\nReturn: nothing\r\n",
      "73": " HUNTER 16 - SELECT TEXT FONT\r\n\tAL = new font\r\n\n\t      00h  7x7 in a 8x8 cell\r\n\n\t      01h  5x7 in a 6x8 cell\r\n\n\t      06h  3x5 in a 4x6 cell\r\n\nReturn: BH = cell width\r\n\n\tBL = cell height\r\n",
      "74": " HUNTER 16 - SET LCD WINDOWS POSITION\r\n\tDH = row (0..24)\r\n\n\tDL = column (0..79)\r\n\nReturn: nothing\r\n",
      "75": " HUNTER 16 - SET ZOOM\r\n\tAL = new Zoom state (00h off, nonzero on)\r\n\nReturn: nothing\r\n",
      "76": " HUNTER 16 - LOOKING KEYS\r\n\tAL = action\r\n\n\t     00h home the window\r\n\n\t     01h move up one line\r\n\n\t     02h move down one line\r\n\n\t     03h move left one character\r\n\n\t     04h move right one character\r\n\n\t     05h flip window to other side of virtual screen\r\n\nReturn: nothing\r\n",
      "77": " HUNTER 16 - GET GRAPHICS FONT\r\nReturn: AL = font number (see #00200)\r\n",
      "78": " HUNTER 16 - TURN BACKLIGHT ON/OFF\r\n\tAL = new state of backlight (00h on, 01h off)\r\n\nReturn: nothing\r\n",
      "7F": " Paradise SVGA - WD90C24 INSTALLATION CHECK\r\nReturn: AX = 1234h if WD90C24 chip installed\r\n",
      "96": " VHRBIOS.SYS - GET OTHER DISPLAY INFO\r\nReturn: AL = display type (see AH=1Ah)\r\n\n\tAH = ??? (possibly related to Micro Channel support)\r\n",
      "BB": " Doorway - SET BIOS/DIRECT REDIRECTION\r\n\tAL = new redirection mode\r\n\n\t    00h BIOS (hook and redirect INT 10h,etc.)\r\n\n\t    01h DIRECT (scan video memory for changes)\r\n\nReturn: ???\r\n",
      "BF": " Athena Digital HGCIBM.COM - INSTALLATION CHECK\r\n\tCX = 0000h (???)\r\n\nReturn: CX = 0202h\r\n\n\tDL = ??? (internal data, possibly version number)\r\n",
      "CD": " VIDEO - UltraVision - SET ULTRAVISION TEXT MODE (EGA,VGA)\r\n\tAL = text mode number (see #00220)\r\n\nReturn: AX = CDCDh if invalid mode\r\n",
      "D0": " VIDEO - HP 100LX/200LX - SET ZOOM MODE\r\n\tAL = zoom mode\r\n\n\t    02h 80x25 mono\r\n\n\t    03h 80x25 color\r\n\n\t    80h 64x18 mono\r\n\n\t    81h 64x18 color\r\n\n\t    82h 40x25 mono\r\n\n\t    83h 40x25 color\r\n\n\t    84h 40x16 mono\r\n\n\t    85h 40x16 color\r\n\nReturn: nothing\r\n",
      "D1": " VIDEO - HP 100LX/200LX - INTERNAL - ???\r\n\tAL = 01h\r\n\nReturn: ???\r\n",
      "D4": " VIDEO - HP 100LX/200LX - INTERNAL - ???\r\n\tAL = 29h\r\n\nReturn: ???\r\n",
      "D5": " Netroom SCRNCLK - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "EE": " VIDEO - IBM \"Private\" Function\r\n",
      "EF": " VIDEO - MSHERC.COM - GET VIDEO ADAPTER TYPE AND MODE\r\nReturn: DL = video adapter type\r\n\n\t    00h original Hercules\r\n\n\t    01h Hercules Plus\t (port 03BAh reads x001xxxxx)\r\n\n\t    02h Hercules InColor (port 03BAh reads x101xxxxx)\r\n\n\t    FFh not a Hercules-compatible card (port 03BAh bit 7 not pulsing)\r\n\n\tDH = memory mode byte\r\n\n\t    00h \"half\" mode\r\n\n\t    01h \"full\" mode\r\n\n\t    FFh not a Hercules-compatible card\r\n",
      "F0": " VHRBIOS.SYS - INSTALLATION CHECK\r\nReturn: BX = 4F4Bh ('OK')\r\n",
      "F1": " VHRBIOS.SYS - SET REVERSE VIDEO\r\n\tAL = new video state \r\n\n\t    (bit 5 set for black text on white, clear for white on black)\r\n\nReturn: ???\r\n",
      "F2": " VHRBIOS.SYS - ???\r\nReturn: ???\r\n",
      "F3": " VHRBIOS.SYS - SWITCH BETWEEN DUAL MONITORS???\r\nReturn: ???\r\n",
      "F4": " VHRBIOS.SYS - GET VERSION\r\nReturn: AX = driver version (AH = major, AL = minor)\r\n",
      "F5": " VHRBIOS.SYS - GET VENDOR ID\r\nReturn: AXBX = vendor ID (4D44h:5349h = 'MDSI' for Micro Display Systems Inc.)\r\n",
      "F6": " VHRBIOS.SYS - GET INFO\r\n\tAL = what to get\r\n\n\t    00h device driver state\r\n\n\t\tReturn: AX = device driver state\r\n\n\t    01h video mode info\r\n\n\t\tReturn: AL = video mode\r\n\n\t\t\tDH = screen height in rows\r\n\n\t\t\tDL = screen width in columns\r\n",
      "F7": " EGA Register Interface Library - DEFINE DEFAULT REGISTER TABLE\r\n\tDX = port number\r\n\n\t   Pointer/data chips\r\n\n\t      00h CRTC (3B4h mono modes, 3D4h color modes)\r\n\n\t      08h Sequencer 3C4h\r\n\n\t      10h Graphics Controller 3CEh\r\n\n\t      18h Attribute Controller 3C0h\r\n\n\t   Single registers\r\n\n\t      20h Miscellaneous Output register 3C2h\r\n\n\t      28h Feature Control register (3BAh mono modes, 3DAh color modes)\r\n\n\t      30h Graphics 1 Position register 3CCh\r\n\n\t      38h Graphics 2 Position register 3CAh\r\n\n\tES:BX -> table of one-byte entries, one byte to be written to each\r\n\n\t\t register\r\n\nReturn: nothing\r\n",
      "FA": " EGA Register Interface Library - INTERROGATE DRIVER\r\n\tBX = 0000h\r\n\nReturn: BX = 0000h if RIL driver not present\r\n\n\tES:BX -> EGA Register Interface version number, if present:\r\n\n\t    byte 0 = major release number\r\n\n\t    byte 1 = minor release number\r\n",
      "FE": " TopView - GET SHADOW BUFFER\r\n\tES:DI -> assumed video buffer\r\n\n\t\tB800h:0000h color text/CGA graphics, B000h:0000h mono text,\r\n\n\t\t  or A000h:0000h EGA/VGA graphics (RSIS environments only)\r\n\nReturn: ES:DI -> actual video buffer for calling process\r\n",
      "FF": " VIDEO - Oak VGA BIOS v1.02+ - SET EMULATION\r\n\tAL = emulation\r\n\n\t    43h ('C') CGA emulation\r\n\n\t    45h ('E') EGA emulation\r\n\n\t    4Dh ('M') Hercules emulation\r\n\n\t    56h ('V') VGA emulation\r\n\n\tES:DI -> signature string \"Calamity\"\r\n\nReturn: VGA switched to suggested mode\r\n"
    },
    "AX": {
      "0070": " VIDEO - Everex Micro Enhancer EGA/Viewpoint VGA - EXTENDED MODE SET\r\n\tBL = mode (see #00011)\r\n",
      "007E": " VIDEO - Paradise VGA, AT&T VDC600 - SET SPECIAL MODE\r\n\tBX = horizontal dimension of the mode desired\r\n\n\tCX = vertical dimension of the mode desired\r\n\n\t    (both BX/CX in pixels for graphics modes, rows for alpha modes)\r\n\n\tDX = number of colors of the mode desired (0000h for monochrome modes)\r\n\nReturn: BH = 7Eh if successful (Paradise VGA)\r\n\n\tAL = 7Eh if successful (AT&T VDC600)\r\n",
      "007F": " Paradise VGA - ???\r\n\tBH = A6h\r\n\n\t???\r\n\nReturn: BH = status (00h failed or not supported, 7Fh successful)\r\n\n\t???\r\n",
      "0500": " VIDEO - Corona/Cordata BIOS v4.10+ - SET GRAPHICS BITMAP BUFFER\r\n\tBX = segment of buffer\r\n\nReturn: nothing\r\n",
      "050F": " VIDEO - Corona/Cordata BIOS v4.10+ - GET GRAPHICS BITMAP BUFFER\r\nReturn: DX = segment of graphics bitmap buffer\r\n",
      "0580": " VIDEO - PCjr, Tandy 1000 - GET CRT/CPU PAGE REGISTERS\r\nReturn: BH = CRT page register\r\n\n\tBL = CPU page register\r\n",
      "0F56": " VUIMAGE DISPLAY DRIVER (v2.20 and below)\r\n\tBX = 4756h\r\n\n\tCX = 4944h\r\n\n\tDL = function\r\n\n\t    01h installation check\r\n\n\t\tReturn: AX = 5649h\r\n\n\t\t\tBX = 4443h\r\n\n\t\t\tCX = 5647h\r\n\n\t\t\tDH = 01h\r\n\n\t    02h get first video mode's parameters\r\n\n\t\tReturn: AX = BIOS mode number\r\n\n\t\t\tBX = width in pixels\r\n\n\t\t\tCX = height in pixels\r\n\n\t\t\tDX = number of colors\r\n\n\t    03h get next video mode's parameters\r\n\n\t\tReturn: as for DL=02h\r\n\n\t    04h display line???\r\n\n\t\tES:DI -> record (see #00016)\r\n\n\t\t???\r\n\n\t\tReturn: ???\r\n",
      "1000": " VIDEO - SET SINGLE PALETTE REGISTER (PCjr,Tandy,EGA,MCGA,VGA)\r\n\tBL = palette register number (00h-0Fh)\r\n\n\t   = attribute register number (undocumented) (see #00017)\r\n\n\tBH = color or attribute register value\r\n\nReturn: nothing\r\n",
      "1001": " VIDEO - SET BORDER (OVERSCAN) COLOR (PCjr,Tandy,EGA,VGA)\r\n\tBH = border color (00h-3Fh)\r\n\nReturn: nothing\r\n",
      "1002": " VIDEO - SET ALL PALETTE REGISTERS (PCjr,Tandy,EGA,VGA)\r\n\tES:DX -> palette register list (see #00018)\r\n\n\tBH = 00h to avoid problems on some adapters\r\n\nReturn: nothing\r\n",
      "1003": " VIDEO - TOGGLE INTENSITY/BLINKING BIT (Jr, PS, TANDY 1000, EGA, VGA)\r\n\tBL = new state\r\n\n\t    00h background intensity enabled\r\n\n\t    01h blink enabled\r\n\n\tBH = 00h to avoid problems on some adapters\r\n\nReturn: nothing\r\n",
      "1007": " VIDEO - GET INDIVIDUAL PALETTE REGISTER (VGA,UltraVision v2+)\r\n\tBL = palette or attribute (undoc) register number (see #00017)\r\n\nReturn: BH = palette or attribute register value\r\n",
      "1008": " VIDEO - READ OVERSCAN (BORDER COLOR) REGISTER (VGA,UltraVision v2+)\r\nReturn: BH = border color (00h-3Fh)\r\n",
      "1009": " VIDEO - READ ALL PALETTE REGISTERS AND OVERSCAN REGISTER (VGA)\r\n\tES:DX -> 17-byte buffer for palette register list (see #00018)\r\n\nReturn: nothing\r\n",
      "1010": " VIDEO - SET INDIVIDUAL DAC REGISTER (VGA/MCGA)\r\n\tBX = register number\r\n\n\tCH = new value for green (0-63)\r\n\n\tCL = new value for blue (0-63)\r\n\n\tDH = new value for red (0-63)\r\n\nReturn: nothing\r\n",
      "1012": " VIDEO - SET BLOCK OF DAC REGISTERS (VGA/MCGA)\r\n\tBX = starting color register\r\n\n\tCX = number of registers to set\r\n\n\tES:DX -> table of 3*CX bytes where each 3 byte group represents one\r\n\n\t\t byte each of red, green and blue (0-63)\r\n\nReturn: nothing\r\n",
      "1013": " VIDEO - SELECT VIDEO DAC COLOR PAGE (VGA)\r\n\tBL = subfunction\r\n\n\t    00h select paging mode\r\n\n\t\tBH = 00h select 4 blocks of 64\r\n\n\t\tBH = 01h select 16 blocks of 16\r\n\n\t    01h select page\r\n\n\t\tBH = page number (00h to 03h) or (00h to 0Fh)\r\n\nReturn: nothing\r\n",
      "1015": " VIDEO - READ INDIVIDUAL DAC REGISTER (VGA/MCGA)\r\n\tBL = palette register number\r\n\nReturn: DH = red value\r\n\n\tCH = green value\r\n\n\tCL = blue value\r\n\n\tAX destroyed by some BIOSes\r\n\n\t      (e.g. Tseng ET4000 BIOS v8.00n always returns AX=00C9h)\r\n",
      "1017": " VIDEO - READ BLOCK OF DAC REGISTERS (VGA/MCGA)\r\n\tBX = starting palette register\r\n\n\tCX = number of palette registers to read\r\n\n\tES:DX -> buffer (3 * CX bytes in size) (see also AX=1012h)\r\n\nReturn: buffer filled with CX red, green and blue triples\r\n",
      "1018": " VIDEO - SET PEL MASK (VGA/MCGA)\r\n\tBL = new PEL value\r\n\nReturn: nothing\r\n",
      "1019": " VIDEO - READ PEL MASK (VGA/MCGA)\r\nReturn: BL = value read\r\n",
      "101A": " VIDEO - GET VIDEO DAC COLOR-PAGE STATE (VGA)\r\nReturn: BL = paging mode\r\n\n\t    00h four pages of 64\r\n\n\t    01h sixteen pages of 16\r\n\n\tBH = current page\r\n",
      "101B": " VIDEO - PERFORM GRAY-SCALE SUMMING (VGA/MCGA)\r\n\tBX = starting palette register\r\n\n\tCX = number of registers to convert\r\n\nReturn: nothing\r\n",
      "10E0": " VIDEO - Diamond Speedstar 24 - SET 24-BIT GRAPHICS MODE\r\n\tBL = video mode (see also #00010 at AH=00h)\r\n\n\t    2Eh = 640x480\r\n\nReturn: ???\r\n",
      "10F0": " VIDEO - Tseng ET-4000 BIOS - SET HiColor GRAPHICS MODE\r\n\tBL = video mode (see also #00010 at AH=00h)\r\n\n\t    13h = 320x200x32K\r\n\n\t    2Dh = 640x350x32K\r\n\n\t    2Eh = 640x480x32K\r\n\n\t    2Fh = 640x400x32K\r\n\n\t    30h = 800x600x32K\r\n\n\t    3Eh = 640x480x16M (Genoa 7900)\r\n\n\t    FFh Tseng 24-bit color mode\r\n\n\t\tBH = mode\r\n\n\t\t    2Dh = 640x480\r\n\n\t\t    2Eh = 640x480x16M\r\n\n\t\t    2Fh = 640x400\r\n\n\t\t    30h = 800x600\r\n\n\t\t    38h = 1024x768??? (Tseng ET4000/W32i)\r\n\nReturn: AL = 10h if supported\r\n\n\tAH = status\r\n\n\t    00h if successful\r\n\n\t    other on error\r\n",
      "10F1": " VIDEO - Tseng ET-4000 BIOS - GET DAC TYPE\r\nReturn: AL = 10h if supported\r\n\n\tBL = type of digital/analog converter (see #00019)\r\n",
      "10F2": " VIDEO - Tseng ET-4000 BIOS - CHECK IF HiColor MODE/SET HiColor MODE\r\n\tBL = function\r\n\n\t    00h get current HiColor mode\r\n\n\t    01h set 15-bit HiColor mode\r\n\n\t    02h set 16-bit HiColor mode\r\n\nReturn: AX = 0010h if supported\r\n\n\t    BL = video mode type\r\n\n\t\t00h not in HiColor mode\r\n\n\t\t01h 15-bit RGB mode\r\n\n\t\t02h 16-bit RGB mode\r\n\n\t\t03h 24-bit RGB mode\r\n",
      "1100": " VIDEO - TEXT-MODE CHARGEN - LOAD USER-SPECIFIED PATTERNS (PS,EGA,VGA)\r\n\tES:BP -> user table\r\n\n\tCX = count of patterns to store\r\n\n\tDX = character offset into map 2 block\r\n\n\tBL = block to load in map 2\r\n\n\tBH = number of bytes per character pattern\r\n\nReturn: nothing\r\n",
      "1101": " VIDEO - TEXT-MODE CHARGEN - LOAD ROM MONOCHROME PATTERNS (PS,EGA,VGA)\r\n\tBL = block to load\r\n\nReturn: nothing\r\n",
      "1102": " VIDEO - TEXT-MODE CHARGEN - LOAD ROM 8x8 DBL-DOT PATTERNS (PS,EGA,VGA)\r\n\tBL = block to load\r\n\nReturn: nothing\r\n",
      "1103": " VIDEO - TEXT-MODE CHARGEN - SET BLOCK SPECIFIER (PS,EGA,VGA)\r\n\tBL = block specifier (see #00020)\r\n\nReturn: nothing\r\n",
      "1104": " VIDEO - TEXT-MODE CHARGEN - LOAD ROM 8x16 CHARACTER SET (VGA)\r\n\tBL = block to load\r\n\nReturn: nothing\r\n",
      "110F": " VIDEO - Realtek RTVGA - SET USER 8x8 GRAPHICS CHARACTERS\r\n\tES:BP -> user table for INT 1F\r\n\nReturn: nothing\r\n",
      "1110": " VIDEO - Realtek RTVGA - SET USER GRAPHICS CHARACTERS\r\n\tES:BP -> user table\r\n\n\tCX = bytes per character\r\n\n\tBL = row specifier\r\n\n\t    00h user set\r\n\n\t\tDL = number of rows\r\n\n\t    01h 14 rows\r\n\n\t    02h 25 rows\r\n\n\t    03h 43 rows\r\n\nReturn: nothing\r\n",
      "1111": " VIDEO - Realtek RTVGA - SET ROM 8x14 GRAPHICS CHARACTERS\r\n\tBL = row specifier (see AX=1121h)\r\n\nReturn: nothing\r\n",
      "1112": " VIDEO - Realtek RTVGA - SET ROM 8x8 DOUBLE-DOT CHARACTERS\r\n\tBL = row specifier (see AX=1121h)\r\n\nReturn: nothing\r\n",
      "1114": " VIDEO - TEXT-MODE CHARGEN - LOAD ROM 8x16 CHARACTER SET (VGA)\r\n\tBL = block to load\r\n\nReturn: nothing\r\n",
      "1118": " IBM SurePath BIOS - Officially \"Private\" Function\r\n",
      "1120": " VIDEO - GRAPH-MODE CHARGEN - SET USER 8x8 GRAPHICS CHARS (PS,EGA,VGA)\r\n\tES:BP -> user table for INT 1F\r\n\nReturn: nothing\r\n",
      "1121": " VIDEO - GRAPH-MODE CHARGEN - SET USER GRAPHICS CHARACTERS (PS,EGA,VGA)\r\n\tES:BP -> user table\r\n\n\tCX = bytes per character\r\n\n\tBL = row specifier\r\n\n\t    00h user set\r\n\n\t\tDL = number of rows\r\n\n\t    01h 14 rows\r\n\n\t    02h 25 rows\r\n\n\t    03h 43 rows\r\n\nReturn: AL = new number of rows (Diamond Stealth64 Video)\r\n",
      "1122": " VIDEO - GRAPH-MODE CHARGEN - SET ROM 8x14 GRAPHICS CHARS (PS,EGA,VGA)\r\n\tBL = row specifier (see AX=1121h)\r\n\nReturn: nothing\r\n",
      "1123": " VIDEO - GRAPH-MODE CHARGEN - SET ROM 8x8 DOUBLE-DOT CHARS (PS,EGA,VGA)\r\n\tBL = row specifier (see AX=1121h)\r\n\nReturn: nothing\r\n",
      "1124": " VIDEO - GRAPH-MODE CHARGEN - LOAD 8x16 GRAPHICS CHARS (VGA,MCGA)\r\n\tBL = row specifier (see AX=1121h)\r\n\nReturn: nothing\r\n",
      "1129": " VIDEO - GRAPH-MODE CHARGEN - SET USER GRAPHICS CHARACTERS (Diamond)\r\n\tDI:BP -> user table\r\n\n\tCX = bytes per character\r\n\n\tBL = row specifier\r\n\n\t    00h user set\r\n\n\t\tDL = number of rows\r\n\n\t    01h 14 rows\r\n\n\t    02h 25 rows\r\n\n\t    03h 43 rows\r\n\nReturn: AL = new number of rows\r\n",
      "1130": " M10_SCR.COM v3.5+ - INSTALLATION CHECK\r\n\tBX = 4D4Fh\r\n\nReturn: CX = 4F4Dh if installed\r\n\n\t    ES:BP -> M10_SCR INT 10 handler\r\n",
      "1400": " VIDEO - LOAD USER-SPECIFIED LCD CHARACTER FONT (CONV,Compaq Port 386)\r\n\tES:DI -> character font\r\n\n\tBH = number of bytes per character\r\n\n\t    08h or 10h (Compaq)\r\n\n\tBL = 00h load main font (block 0)\r\n\n\t     01h load alternate font (block 1)\r\n\n\tCX = number of characters to store\r\n\n\tDX = character offset into RAM font area\r\n\nReturn: nothing\r\n",
      "1401": " VIDEO - LOAD SYSTEM ROM DEFAULT LCD CHARACTER FONT (CONV,CP386)\r\n\tBL = font to load\r\n\n\t    00h main font (block 0)\r\n\n\t    01h alternate font (block 1)\r\n\nReturn: nothing\r\n",
      "1402": " VIDEO - SET MAPPING OF LCD HIGH INTENSITY ATTRIBUTES (CONV,CP386)\r\n\tBL = subfunction\r\n\n\t    00h ignore high intensity attribute\r\n\n\t    01h map high intensity to reverse video\r\n\n\t    02h map high intensity to underscore\r\n\n\t    03h map high intensity to selected alternate font\r\n\n\t    B0h half intensity (Compaq)\r\n\n\t    B1h toggle active intensity bit interpretation (CP386)\r\n\nReturn: nothing\r\n",
      "1A00": " VIDEO - GET DISPLAY COMBINATION CODE (PS,VGA/MCGA)\r\nReturn: AL = 1Ah if function was supported\r\n\n\t    BL = active display code (see #00039)\r\n\n\t    BH = alternate display code (see #00039)\r\n",
      "1A01": " VIDEO - SET DISPLAY COMBINATION CODE (PS,VGA/MCGA)\r\n\tBL = active display code (see #00039)\r\n\n\tBH = alternate display code\r\n\nReturn: AL = 1Ah if function was supported\r\n",
      "1DAA": " Diamond Stealth64 Video - INSTALLATION CHECK\r\n\tBX = FDECh\r\n\nReturn: BX = CDEFh if Diamond Stealth64 Video 2001-series video card installed\r\n\n\t    AL = number of megabytes of video memory\r\n\n\t    AH = card type??? (4Bh for VL-Bus/5Bh for PCI)\r\n\n\t    CX = ??? (0000h)\r\n\n\t    SI:DI -> signature/copyright string\r\n",
      "1E00": " VIDEO - FLAT-PANEL - READ INFORMATION\r\nReturn: AL = 1Eh if function supported\r\n\n\t    BL = flat-panel status (see #00052)\r\n\n\t    ES:DI -> information table (see #00053)\r\n",
      "1E01": " VIDEO - FLAT-PANEL - LCD/CRT DISPLAY CONTROL\r\n\tBH = function\r\n\n\t    bit 7: =1 set display control, =0 query control\r\n\n\t    bits 6-0: reserved (0)\r\n\n\t---if BH bit 7 set---\r\n\n\tBL = new display combination (see #00054)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbits 6-3: reserved (0)\r\n\n\t\tbit 2: simultaneous display is supported by hardware\r\n\n\t\tbit 1: LCD/CRT display control supported by hardware\r\n\n\t\tbit 0: set operation was successful (always clear on get)\r\n\n\t    BL = active display combination (see #00054)\r\n",
      "1E02": " VIDEO - FLAT-PANEL - DISPLAY POSITION\r\n\tBH = function\r\n\n\t    bit 7: =1 set display position, =0 query position\r\n\n\t    bits 6-0: reserved (0)\r\n\n\t---if BH bit 7 set---\r\n\n\tBL = new position setting (see #00055)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbits 6-4: reserved (0)\r\n\n\t\tbit 3: positioning to top is supported by hardware\r\n\n\t\tbit 2: positioning to center is supported by hardware\r\n\n\t\tbit 1: positioning to bottom is supported by hardware\r\n\n\t\tbit 0: set operation was successful (always clear on get)\r\n\n\t    BL = active position setting (see #00055)\r\n",
      "1E03": " VIDEO - FLAT-PANEL - VERTICAL EXPANSION FOR TEXT/GRAPHICS MODES\r\n\tBH = function\r\n\n\t    bit 7: =1 set vertical expansion, =0 query expansion\r\n\n\t    bits 6-0: reserved (0)\r\n\n\t---if BH bit 7 set---\r\n\n\tBL = new vertical expansion setting (see #00056)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbits 6-4: reserved (0)\r\n\n\t\tbit 3: vertical expansion of text is supported by hardware\r\n\n\t\tbit 2: vertical expansion of graphics is supported by hardware\r\n\n\t\tbit 1: hardware supports independent control of expansion in\r\n\n\t\t\ttext and graphics modes\r\n\n\t\tbit 0: set operation was successful (always clear on get)\r\n\n\t    BL = active vertical expansion setting (see #00056)\r\n",
      "1E04": " VIDEO - FLAT-PANEL - NORMAL/REVERSE VIDEO FOR TEXT/GRAPHICS MODES\r\n\tBH = function\r\n\n\t    bit 7: =1 set normal/reverse video, =0 query normal/reverse\r\n\n\t    bits 6-0: reserved (0)\r\n\n\t---if BH bit 7 set---\r\n\n\tBL = new normal/reverse video setting (see #00057)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbits 6-4: reserved (0)\r\n\n\t\tbit 3: hardware supports reverse video for text modes\r\n\n\t\tbit 2: hardware supports reverse video for graphics modes\r\n\n\t\tbit 1: hardware supports independent control of reverse video\r\n\n\t\t      in text and graphics modes\r\n\n\t\tbit 0: set operation was successful (always clear on get)\r\n\n\t    BL = active normal/reverse video setting (see #00057)\r\n",
      "1E05": " VIDEO - FLAT-PANEL - BRIGHTNESS CONTROL\r\n\tBH = function\r\n\n\t    bit 7: =1 set brightness, =0 query brightness\r\n\n\t    bits 6-0: reserved (0)\r\n\n\t---if BH bit 7 set---\r\n\n\tBL = new brightness setting (see #00058)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbits 6-2: reserved (0)\r\n\n\t\tbit 1: software brightness control is supported\r\n\n\t\tbit 0: set operation was successful (always clear on get)\r\n\n\t    BL = active brightness setting (see #00058)\r\n",
      "1E06": " VIDEO - FLAT-PANEL - CONTRAST CONTROL FOR TEXT/GRAPHICS\r\n\tBH = function\r\n\n\t    bit 7: =1 set contrast control, =0 query contrast\r\n\n\t    bits 6-0: reserved (0)\r\n\n\t---if BH bit 7 set---\r\n\n\tBL = new normal/reverse video setting (see #00059)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbits 6-4: reserved (0)\r\n\n\t\tbit 3: software contrast control supported for text\r\n\n\t\tbit 2: software contrast control supported for graphics\r\n\n\t\tbit 1: hardware supports independent control of contrast\r\n\n\t\t      in text and graphics modes\r\n\n\t\tbit 0: set operation was successful (always clear on get)\r\n\n\t    BL = active contrast setting (see #00059)\r\n",
      "1E07": " VIDEO - FLAT-PANEL - BRIGHTNESS SETTING\r\n\tBH = function\r\n\n\t    bit 7: =1 set brightness control, =0 query brightness\r\n\n\t    bit 6: use standard brightness\r\n\n\t    bits 5-0: reserved (0)\r\n\n\t---if BH bits 7,6=10---\r\n\n\tBL = brightness (00h = minimum, FFh = maximum)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbit 6: standard/custom (copied from input)\r\n\n\t\tbits 5-2: reserved (0)\r\n\n\t\tbit 1: software brightness control is supported\r\n\n\t\tbit 0: set operation was succesful (always clear on get)\r\n\n\t    BL = brightness (00h = minimum, FFh = maximum)\r\n",
      "1E08": " VIDEO - FLAT-PANEL - CONTRAST SETTING\r\n\tBH = function\r\n\n\t    bit 7: =1 set contrast control, =0 query contrast\r\n\n\t    bit 6: use standard contrast\r\n\n\t    bits 5-0: reserved (0)\r\n\n\t---if BH bits 7,6=10---\r\n\n\tBL = contrast (00h = minimum, FFh = maximum)\r\n\nReturn: AL = 1Eh if function supported\r\n\n\t    BH = results\r\n\n\t\tbit 7: query/set (copied from input)\r\n\n\t\tbit 6: standard/custom (copied from input)\r\n\n\t\tbits 5-2: reserved (0)\r\n\n\t\tbit 1: software contrast control is supported\r\n\n\t\tbit 0: set operation was succesful (always clear on get)\r\n\n\t    BL = contrast (00h = minimum, FFh = maximum)\r\n",
      "1EFE": " VIDEO - FLAT-PANEL - FUNCTION SUPPORT FLAG\r\n\tES:DI -> DWORD buffer for bitmap of supported functions\r\n\n\t\t(set to all zeros before calling)\r\n\nReturn: ES:DI buffer updated with mask of supported functions\r\n",
      "1F00": " VIDEO - XGA - GET DMQS (Display Mode Query and Set) DATA LENGTH\r\nReturn: AL = 1Fh if supported\r\n\n\t    BX = number of bytes of DMQS data\r\n",
      "1F01": " VIDEO - XGA - READ DMQS DATA\r\n\tES:DI -> user buffer for return data (call AX=1F00h for size)\r\n\nReturn: AL = 1Fh if function supported\r\n\n\tuser buffer filled with DMQS data (see #00060)\r\n",
      "1F02": " VIDEO - XGA - GET SVGA DMQS DATA LENGTH\r\nReturn: AL = 1Fh if function supported\r\n\n\t    BX = length of SVGA DMQS data in bytes\r\n",
      "1F03": " VIDEO - XGA - GET SVGA DMQS DATA\r\n\tES:DI -> buffer for SVGA DMQS data (see #00061)\r\n\nReturn: AL = 1Fh if function supported\r\n\n\t    ES:DI buffer filled\r\n",
      "3000": " VIDEO - LOCATE 3270PC CONFIGURATION TABLE (INSTALLATION CHECK)\r\n\tCX = 0000h\r\n\n\tDX = 0000h\r\n\nReturn: CX:DX -> 3270PC configuration table (see #00062)\r\n\n\tCX:DX = 0000h:0000h if 3270PC Control Program not active\r\n",
      "4E00": " VESA XGA BIOS Extensions - GET XGA ENVIRONMENT INFORMATION\r\n\tES:DI -> 256-byte buffer for XGA information (see #00069)\r\n\nReturn: AL = 4Eh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\telse error code\r\n",
      "4E01": " VESA XGA BIOS Extensions - RETURN XGA SUBSYSTEM INFORMATION\r\n\tDX = XGA handle (0 to number of XGAs-1)\r\n\n\tES:DI -> 256-byte buffer for subsystem information (see #00071)\r\n\nReturn: AL = 4Eh if function supported\r\n\n\tAH = status\r\n\n\t    00h\t function successful\r\n\n\t    else error code\r\n",
      "4E02": " VESA XGA BIOS Extensions - RETURN XGA MODE INFORMATION\r\n\tCX = Video mode\r\n\n\tDX = XGA handle\r\n\n\tES:DI -> 256 byte buffer for mode information (see #00073)\r\n\nReturn: AL = 4Eh if function supported\r\n\n\tAH = status\r\n\n\t    00h\t function successful\r\n\n\t    else error code\r\n",
      "4E03": " VESA XGA BIOS Extensions - SET XGA VIDEO MODE\r\n\tBX = video mode\r\n\n\tCX = other command flags\r\n\n\t     bit 0  If clear the feature connector is set to the default state\r\n\n\tDX = XGA handle\r\n\n\tES:DI -> 256 byte buffer\r\n\nReturn: AL = 4Eh if function supported\r\n\n\tAH = status\r\n\n\t    00h\t function successful\r\n\n\t    else error code\r\n",
      "4E04": " VESA XGA BIOS Extensions - RETURN CURRENT VIDEO MODE\r\n\tDX = XGA handle\r\n\nReturn: AL = 4Eh if function supported\r\n\n\tAH = status\r\n\n\t    00h\t function successful\r\n\n\t\tBX??? = current mode\r\n\n\t    else error code\r\n",
      "4E05": " VESA XGA BIOS Extensions - SET FEATURE CONNECTOR STATE\r\n\tBX = Feature Connector State (see #00076)\r\n\n\tDX = XGA handle\r\n\nReturn: AL = 4Eh if function supported\r\n\n\tAH = status\r\n\n\t    00h\t function successful\r\n\n\t    else error code\r\n",
      "4E06": " VESA XGA BIOS Extensions - RETURN FEATURE CONNECTOR STATE\r\n\tDX = XGA handle\r\n\nReturn: AL = 4Eh if function supported\r\n\n\tAH = status\r\n\n\t    00h\t function successful\r\n\n\t    else error code\r\n\n\tBX = Feature Connector State (see #00076)\r\n",
      "4F00": " VESA SuperVGA BIOS (VBE) - GET SuperVGA INFORMATION\r\n\tES:DI -> buffer for SuperVGA information (see #00077)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tES:DI buffer filled\r\n\n\t    01h failed\r\n\n\t    ---VBE v2.0---\r\n\n\t    02h function not supported by current hardware configuration\r\n\n\t    03h function invalid in current video mode\r\n",
      "4F01": " VESA SuperVGA BIOS - GET SuperVGA MODE INFORMATION\r\n\tCX = SuperVGA video mode (see #04082 for bitfields)\r\n\n\tES:DI -> 256-byte buffer for mode information (see #00079)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tES:DI buffer filled\r\n\n\t    01h failed\r\n",
      "4F02": " VESA SuperVGA BIOS - SET SuperVGA VIDEO MODE\r\n\tBX = new video mode (see #04082,#00083,#00084)\r\n\n\tES:DI -> (VBE 3.0+) CRTC information block, bit mode bit 11 set\r\n\n\t\t  (see #04083)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n",
      "4F03": " VESA SuperVGA BIOS - GET CURRENT VIDEO MODE\r\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tBX = video mode (see #00083,#00084)\r\n\n\t\t    bit 13: VBE/AF v1.0P accelerated video mode\r\n\n\t\t    bit 14: linear frame buffer enabled (VBE v2.0+)\r\n\n\t\t    bit 15: don't clear video memory\r\n\n\t    01h failed\r\n",
      "4F04": " VESA SuperVGA BIOS - SAVE/RESTORE SuperVGA VIDEO STATE\r\n\tDL = subfunction\r\n\n\t    00h get state buffer size\r\n\n\t\tReturn: BX = number of 64-byte blocks needed\r\n\n\t    01h save video states\r\n\n\t\tES:BX -> buffer\r\n\n\t    02h restore video states\r\n\n\t\tES:BX -> buffer\r\n\n\tCX = states to save/restore (see #00085)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n",
      "4F05": " VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL\r\n\tBH = subfunction\r\n\n\t    00h select video memory window\r\n\n\t\tDX = window address in video memory (in granularity units)\r\n\n\t    01h get video memory window\r\n\n\t\tReturn: DX = window address in video memory (in gran. units)\r\n\n\tBL = window number\r\n\n\t    00h window A\r\n\n\t    01h window B\r\n\n\tES = selector for memory-mapped registers (VBE 2.0+, when called from\r\n\n\t      32-bit protected mode)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n",
      "4F06": " VESA SuperVGA BIOS v2.0+ - GET MAXIMUM SCAN LINE LENGTH\r\n\tBL = 03h\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n\n\tBX = maximum bytes per scan line\r\n\n\tCX = maximum number of pixels per scan line\r\n",
      "4F07": " VESA SuperVGA BIOS v3.0+ - ENABLE/DISABLE STEREOSCOPIC MODE\r\n\tBL = subfunction\r\n\n\t    05h enable stereoscopic mode\r\n\n\t    06h\tdisable stereoscopic mode\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n",
      "4F08": " VESA SuperVGA BIOS v1.2+ - GET/SET DAC PALETTE CONTROL\r\n\tBL = subfunction\r\n\n\t    00h set DAC palette width\r\n\n\t\tBH = desired number of bits per primary color\r\n\n\t    01h get DAC palette width\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tBH = current number of bits per primary (06h = standard VGA)\r\n\n\t    01h failed\r\n",
      "4F09": " VESA SuperVGA BIOS v2.0+ - GET/SET PALETTE ENTRIES\r\n\tBL = subfunction\r\n\n\t    00h set (primary) palette\r\n\n\t    01h get (primary) palette\r\n\n\t    02h set secondary palette data\r\n\n\t    03h get secondary palette data\r\n\n\t    80h set palette during vertical retrace\r\n\n\tCX = number of entries to change\r\n\n\tDX = starting palette index\r\n\n\tES:DI -> palette buffer, array of DAC entries (see #00086)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n",
      "4F0A": " VESA SuperVGA BIOS v2.0 beta - GET PROTECTED-MODE CODE\r\n\tBX = function to be copied (see #00088)\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tCX = number of bytes to copy\r\n\n\t\tES:DI -> code for requested function\r\n\n\t    01h failed\r\n",
      "4F0B": " Diamond Viper V330 - ???\r\n\tECX = ???\r\n\n\t???\r\n\nReturn: AL = 4Fh if function supported\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tECX = ???\r\n\n\t\t???\r\n\n\t    01h failed\r\n",
      "4F11": " VESA VBE/FP (Flat Panel Interface) - API\r\n\tBL = function\r\n\n\t    00h installation check / get capabilities\r\n\n\tother registers vary by function\r\n\nReturn: varies by function\r\n",
      "4F12": " VESA VBE/CI (Cursor Interface) - API\r\n\tBL = function\r\n\n\tother registers vary by function\r\n\nReturn: varies by function\r\n",
      "4F15": " VESA VBE/DC (Display Data Channel) - READ VDIF\r\n\tBL = 02h\r\n\n\t???\r\n\nReturn: AL = 4Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t    ???\r\n\n\t\t01h failed\r\n",
      "4F16": " VESA VBE/GC (Graphics System Configuration) - API\r\n\tBL = function\r\n\n\t    00h installation check / get capabilities\r\n\n\tother registers vary by function\r\n\nReturn: varies by function\r\n",
      "4F17": " VESA VBE/AF (Accelerator Functions) - API\r\n\tBL = function\r\n\n\t    00h installation check / get capabilities\r\n\n\tother registers vary by function\r\n\nReturn:\tAL = 4Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t01h failed\r\n\n\t\t02h hardware does not support function\r\n\n\t\t03h function not available in current video mode\r\n\n\t\telse reserved for future error codes\r\n\n\tother vary by function\r\n",
      "4F4D": " VESA - VIDEO CURSOR INTERFACE REQUEST\r\n\tBX = number of bytes available for VCI use\r\n\n\tDS:0000h -> buffer for VCI\r\n\n\tES:DI -> VCI driver callback function\r\n\nReturn: AL = 4Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t    BX = number of bytes used by VCI\r\n\n\t\t    ES:DI -> VCI request handler\r\n\n\t\t01h failed\r\n",
      "4F70": " Avance Logic - GET ADAPTER INFORMATION\r\nReturn:\tAX = 004Fh if successful\r\n\n\t    BL = board information (see #00174)\r\n\n\t    BH = board type???\r\n\n\t\t00h on ALG2101\r\n\n\t\tFFh otherwise\r\n",
      "4FDD": " ATI M64VBE.COM - GET RESIDENT SEGMENT\r\nReturn: AX = CS of resident code\r\n",
      "4FFF": " ATI M64VBE.COM - UNINSTALL\r\n\tBX = 364Dh ('6M')\r\n\n\tCX = 5634h ('V4')\r\n\nReturn: AX,DX,DS,ES destroyed\r\n",
      "5555": " VIDEO - ATI EGA/VGA Wonder Super Switch - INSTALLATION CHECK\r\nReturn: AX = AAAAh    if installed\r\n\n\tBX:CX -> ??? routine in SMS.COM resident portion\r\n\n\t      -> data area (see #00175) in VCONFIG\r\n",
      "5F00": " VIDEO - Realtek RTVGA - RETURN CHIP VERSION\r\nReturn: AH = 00h, if successful\r\n\n\tAL = chip version (the same value that VTEST.EXE reads)\r\n\n\t    00h RTG3103???\r\n\n\t    01h RTG31030/RTG3105\r\n\n\t    02h RTG3106???\r\n\n\t    3Fh non-Realtek chip\r\n",
      "5F01": " VIDEO - Realtek RTVGA - WRITE RTVGA BIOS STRING TO DESTINATION\r\n\tES:DI -> zero-filled buffer for BIOS ID string\r\n\nReturn: AH = 00h if successful\r\n\n\tES:DI -> ASCII signature \"REALTEK VGA BIOS Version 3C.10\"\r\n",
      "5F02": " VIDEO - Realtek RTVGA - RETURN RTVGA ON-BOARD MEMORY SIZE\r\nReturn: AH = 00h, if successful\r\n\n\tAL = on-board memory size\r\n\n\t     (00h = 256K, 01h = 512K, 02h = 768K, 03h = 1024K)\r\n",
      "5F03": " Chips & Technologies Extended BIOS - SET POWER-ON EMULATION MODE\r\n\tBL = 01h\r\n\n\tCL = emulation mode (see #00181)\r\n\n\tCH = permanence\r\n\n\t    bit 7 persistence (0 reset on next boot, 1 until changed)\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F04": " Chips & Technologies '64300' BIOS - GET REFRESH RATE\r\n\tBL = video mode number\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n\n\t\t    BH = available refresh rates (see #00182)\r\n\n\t\t    BL = currently-set refresh rate (see #00182)\r\n",
      "5F05": " Chips & Technologies '64300' BIOS - SET REFRESH RATE\r\n\tBL = video mode number\r\n\n\tBH = refresh rate to set (see #00182)\r\n\n\t\tbit 7:\t=0 program new clock and CRT parametes\r\n\n\t\t\t=1 keep current parameters\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F06": " Chips & Technologies '64300' BIOS - GET XRAM INFORMATION\r\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n\n\t\t    BL = XRAM presence (00h no XRAM, 01h present)\r\n",
      "5F08": " Chips & Technologies '64300' BIOS - SET LINEAR MEMORY START ADDRESS\r\n\tBX = desired start address in megabytes\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F10": " Chips & Technologies '64300'/'65530' BIOS - GET LINEAR MEMORY INFO\r\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n\n\t\t    BX:CX = linear memory base address\r\n\n\t\t    DX = virtual screen width offset (bytes)\r\n\n\t\t    SI;DI = linear memory size\r\n",
      "5F50": " Chips & Technologies '65530' BIOS - GET 655xx INFORMATION\r\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n\n\t\t    BX = width of flat panel in pixels\r\n\n\t\t    CX = height of flat panel in pixels\r\n\n\t\t    DX = F65520/525/530 status (see #00184)\r\n",
      "5F51": " Chips & Technologies Extended BIOS - SWITCH DISPLAY DEVICE\r\n\tBL = new active display\r\n\n\t    00h CRT\r\n\n\t    01h flat panel (LCD)\r\n\n\t    02h both simultaneously\r\n\n\tBH = 01h to allow reprogramming the DAC\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F53": " Chips & Technologies Extended BIOS - EN/DISABLE ACCELERATOR SUPPORT\r\n\tBL = new support state\r\n\n\t    00h disable buffer/accelerator\r\n\n\t    01h enable buffer/acelerator\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F54": " Chips & Technologies Extended BIOS - TURN FLAT PANEL ON/OFF\r\n\tBL = new state\r\n\n\t    00h on\r\n\n\t    01h off\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F5A": " Chips & Technologies Extended BIOS - SET FLAT-PANEL VIDEO POLARITY\r\n\tBL = new video polarity\r\n\n\t    00h normal\r\n\n\t    01h inverted\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F5C": " Chips & Technologies Extended BIOS - SET VERTICAL COMPENSATION\r\n\tBL = type of vertical compensation to use\r\n\n\t    00h no compensation\r\n\n\t    01h automatic centering\r\n\n\t    02h set centering register\r\n\n\t\tDX = centering value (bits 9-0 only)\r\n\n\t    03h non-automatic centering\r\n\n\t    04h set vertical line insertion register\r\n\n\t\tDL = vertical line insertion (bits 3-0 only)\r\n\n\t    05h set alternate maximum scanline register\r\n\n\t\tDL = alternate maximum scanline (bits 4-0 only)\r\n\n\t    06h enable text stretching, type 0\r\n\n\t    07h enable text stretching, type 1\r\n\n\t    08h enable text stretching, type 2\r\n\n\t    09h enable text stretching, type 3\r\n\n\t    0Ah\tdisable text stretching\r\n\n\t    0Bh set vertical line replication register\r\n\n\t\tDL = vertical line replication (bits 3-0 only)\r\n\n\t    0Ch enable graphics stretching, type 0\r\n\n\t    0Dh enable graphics stretching, type 1\r\n\n\t    0Eh disable vertical graphics stretching\r\n\n\t    0Fh disable all horizontal and vertical compensation\r\n\n\t    10h enable optimal compensation\r\n\n\t    11h disable optimal compensation\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F5E": " Chips & Technologies Extended BIOS - EN/DISABLE TALL FONT LOADING\r\n\tBL = new state of tall-font loading\r\n\n\t    00h enable loading\tof 8x19/30/32 fonts\r\n\n\t    01h disable loading of 8x19/30/32 fonts\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F5F": " Chips & Technologies Extended BIOS - HORIZONTAL COMPENSATION\r\n\tBL = horizontal compensation type\r\n\n\t    00h none\r\n\n\t    01h automatic centering\r\n\n\t    02h set centering register\r\n\n\t\tDL = centering value\r\n\n\t    03h non-automatic centering\r\n\n\t    04h enable text compression (force 8xN fonts)\r\n\n\t    05h disable text compression (allow 9xN fonts)\r\n\n\t    06h enable auto doubling\r\n\n\t    07h disable auto doubling\r\n\n\t    0Fh disable all horizontal and vertical compensation\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "5F90": " Chips & Technologies Extended BIOS - GET SUPERVGA STATE BUFFER SIZE\r\n\tCX = state mask (see #00185)\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    BX = number of 64-byte blocks required\r\n",
      "5F91": " Chips & Technologies Extended BIOS - SAVE SUPERVGA STATE\r\n\tCX = state mask (see #00185)\r\n\n\tES:BX -> save buffer\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    buffer at ES:BX filled\r\n",
      "5F92": " Chips & Technologies Extended BIOS - RESTORE SUPERVGA STATE\r\n\tCX = state mask (see #00185)\r\n\n\tES:BX -> previously-filled save buffer\r\n\nReturn: AL = 5Fh if function supported\r\n",
      "5FA0": " Chips & Technologies Wingine DGX - GET EXTENDED BIOS SAVE BUFFER SIZE\r\n\tCX = state(s) to be saved (see #00186)\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n\n\t\t    BX = number of 64-byte blocks required for state\r\n",
      "5FA1": " Chips & Technologies Wingine DGX - SAVE VIDEO STATE\r\n\tCX = state(s) to be saved (see #00186)\r\n\n\tES:BX -> buffer for state information\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n\n\t\t    ES:BX buffer filled\r\n",
      "5FA2": " Chips & Technologies Wingine DGX - RESTORE VIDEO STATE\r\n\tCX = state(s) to be restored (see #00186)\r\n\n\tES:BX -> buffer containing previously-saved state information\r\n\nReturn: AL = 5Fh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h unsuccessful\r\n\n\t\t01h successful\r\n",
      "6500": " HUNTER 16 - GET BACKLIGHT TIMEOUT\r\nReturn: BX = timeout in seconds (0-300)\r\n",
      "6501": " HUNTER 16 - SET BACKLIGHT TIMEOUT\r\n\tBX = timeout in seconds (0-300)\r\n\nReturn: nothing\r\n",
      "6A00": " Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES\r\n\tBX = 0000h\r\n\n\tCX = 0000h\r\n\n\tDX = buffer length (may be 0)\r\n\n\tES:DI -> buffer\r\n\nReturn: BX = number of bytes stored in buffer\r\n\n\tCX = bytes required for all descriptions (0 if no DGIS)\r\n",
      "6A01": " Direct Graphics Interface Standard (DGIS) - REDIRECT CHARACTER OUTPUT\r\n\tCX = 0000h\r\n\n\tES:DI = address of device to send INT 10 output to\r\n\nReturn: CX = 0000h  output could not be redirected\r\n\n\t     else INT 10h output now routed to requested display\r\n",
      "6A02": " DGIS - INQUIRE INT 10 OUTPUT DEVICE\r\n\tES:DI = 0000h:0000h\r\n\nReturn: ES:DI = 0000h:0000h  if current display is non-DGIS\r\n\n\t\telse address of the current DGIS INT 10 display\r\n",
      "6E00": " Paradise VGA internal - GET ???\r\nReturn: BX = 5744h ('WD') if supported\r\n\n\t    DH:AH:AL = last three ASCII digits of ROM serial number\r\n\n\t    CL = ???\r\n\n\t    CH = ???\r\n",
      "6E04": " Paradise VGA internal - GET SCREEN SIZE AND ???\r\nReturn: BX = screen width (columns)\r\n\n\tCX = screen height (lines)\r\n\n\tAH = ??? (05h or FFh)\r\n\n\tAL = ??? (04h or video mode)\r\n",
      "6E05": " Paradise VGA internal - SET MODE\r\n\tBL = mode\r\n\nReturn: nothing\r\n",
      "6F00": " VIDEO - Video7 VGA,VEGA VGA - INSTALLATION CHECK\r\n\tBX = 0000h\r\n\nReturn: BX = 5637h ('V7') indicates Video7 VGA/VEGA VGA extensions are present\r\n",
      "6F01": " VIDEO - Video7 VGA,VEGA VGA,HP EX-BIOS - GET MONITOR INFO\r\nReturn: AL = monitor type code (HP,VEGA VGA only) (see #00188)\r\n\n\tAH = status register information (see #00189)\r\n\n\tCL = current value of Extended Control register (HP Ext BIOS, and only\r\n\n\t\tif AL=41h) (see #00190)\r\n",
      "6F02": " HP Vectra EX-BIOS - SET MONITOR INFO\r\n\tBL = new value for extended control register (see #00190)\r\n\nReturn: AX,BL destroyed\r\n",
      "6F03": " HP Vectra EX-BIOS - MODIFY MONITOR INFO\r\n\tBH = exclude mask (set bits are not modified)\r\n\n\tBL = new values for bits indicated by BH (see #00190)\r\n\nReturn: AX destroyed\r\n",
      "6F04": " VIDEO - Video7 VGA,VEGA VGA,HP Vectra - GET MODE AND SCREEN RESOLUTION\r\nReturn: AL = current video mode (see #00191)\r\n\n\tBX = horizontal columns (text) or pixels (graphics)\r\n\n\tCX = vertical columns (text) or pixels (graphics)\r\n",
      "6F05": " VIDEO - Video7 VGA,VEGA EXTENDED EGA/VGA,HP Vectra - SET VIDEO MODE\r\n\tBL = mode (see #00191)\r\n\nReturn: AX,BL destroyed\r\n",
      "6F06": " VIDEO - Video7 VGA,VEGA VGA - SELECT AUTOSWITCH MODE\r\n\tBL = Autoswitch mode select\r\n\n\t     00h select EGA/VGA-only modes\r\n\n\t     01h select Autoswitched VGA/EGA/CGA/MGA modes\r\n\n\t     02h select 'bootup' CGA/MGA modes\r\n\n\tBH = enable/disable (00h enable, 01h = disable selection)\r\n\nReturn: nothing\r\n",
      "6F07": " VIDEO -  Video7 VGA,VEGA VGA - GET VIDEO MEMORY CONFIGURATION\r\nReturn: AL = 6Fh\r\n\n\tAH = memory configuration\r\n\n\t    bits 0-6 = number of 256K blocks of video memory\r\n\n\t    bit 7    = DRAM/VRAM (0: DRAM, 1: VRAM)\r\n\n\tBH = chip revision (SR8F) (S/C Chip in VEGA VGA)\r\n\n\tBL = chip revision (SR8E) (G/A Chip in VEGA VGA)\r\n\n\tCX = 0000h\r\n",
      "7000": " Everex Extended Video BIOS - GET SUPPORTED MODE INFO\r\n\tBX = 0005h\r\n\n\tCL = maximum number of modes to get info for\r\n\n\tCH = mode type to get info for (see #00196)\r\n\n\tDL = monitor type to get info for\r\n\n\tES:DI -> buffer for mode info (see #00197)\r\n\nReturn: CL = total number of modes fitting criteria\r\n\n\tCH = size of each info record\r\n",
      "7F00": " Diamond Stealth 24 - SET LINEAR ADDRESS\r\n\tBX = 4002h\r\n\n\tCX = new linear address base (high word)\r\n\nReturn: AX = 007Fh if supported\r\n",
      "7F01": " SOLLEX SuperVGA - ADAPTER CONTROL - DETERMINE ADAPTER SUPPORT\r\n\tBL = 02h\r\n\n\tCX = adapter request (see #00205)\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h requested setting can successfully be made\r\n\n\t\t01h requested setting not available in this configuration\r\n",
      "7F02": " SOLLEX SuperVGA - DISPLAY OUTPUT CONTROL - GET DISPLAY OUTPUT\r\n\tBL = 01h\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t    BX = display output setting (see #00207)\r\n\n\t\t    CX = displays attached (see #00208)\r\n\n\t\t01h failed\r\n",
      "7F03": " SOLLEX SuperVGA - VIDEO SUPPORT CONTROL - GO RAM RESIDENT\r\n\tBL = 02h\r\n\n\tCX = support request\r\n\n\tES = destination segment\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t01h failed\r\n",
      "7F04": " SOLLEX SuperVGA - POWER CONTROL - GET TIMEOUT RESET\r\n\tBL = 03h\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t    BX = time increment\r\n\n\t\t    CX = current timeout reset\r\n\n\t\t    DX = maximum timeout reset\r\n\n\t\t    ES:DI -> timeout reset table (array of bytes)\r\n\n\t\t01h failed\r\n",
      "7F05": " SOLLEX SuperVGA - LOAD REGISTER\r\n\tES:DI -> register value table (see #00209)\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t01h failed\r\n",
      "7F06": " SOLLEX SuperVGA - MULTIPLE FONT CONTROL\r\n\tBL = subfunction\r\n\n\t    00h set multiple font state\r\n\n\t\tCX = new state (00h off, 01h on)\r\n\n\t    01h get multiple font state\r\n\n\t\tReturn: BL = current state (00h off, 01h on)\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t01h failed\r\n",
      "7F07": " SOLLEX SuperVGA - FILL VIDEO RAM\r\n\tBL = how much to fill\r\n\n\t   00h regen size\r\n\n\t   01h all video memory\r\n\n\tCX = pattern to write (normally 0720h for text modes and 0000h for gr)\r\n\nReturn: AL <> 7Fh if not supported\r\n\n\tAL = 7Fh if supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t01h failed\r\n",
      "9508": " VHRBIOS.SYS - ???\r\nReturn: ???\r\n",
      "A004": " PhoenixVIEW/LC - VIDEO DISPLAY TYPE\r\n\t???\r\n\nReturn: ???\r\n",
      "A00D": " ATI Rage128 BIOS - GET ???\r\n\tBL = subfunction\r\n\n\t   00h ???\r\n\n\t   01h ???\r\n\n\t   02h ???\r\n\n\t   03h ???\r\n\n\tDX:DI -> buffer for results\r\n\n\t???\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n\n\t???\r\n",
      "A012": " ATI Mach64 BIOS - GET ???\r\nReturn: AH = 00h (successful)\r\n\n\tAL = ??? (00h)\r\n\n\tBX = ??? (0000h)\r\n\n\tCX = ??? (0000h)\r\n\n\tDX = ??? (02ECh)\r\n",
      "A013": " ATI Mach64 BIOS - ???\r\n\t???\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n\n\t???\r\n",
      "A014": " ATI Rage128 BIOS - ???\r\n\tCH = ??? (bits 0,1,4)\r\n\n\t???\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n\n\t???\r\n",
      "A015": " ATI Rage128 BIOS - GET/SET ???\r\n\tCH = subfunction\r\n\n\t    00h get ???\t\r\n\n\t    01h set ???\r\n\n\t       CL = ??? (only bits 0,1 used on All-in-Wonder 128)\r\n\n\t    other NOP\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n\n\t???\r\n",
      "A016": " ATI Rage128 BIOS - NOP\r\nReturn: nothing\r\n",
      "A017": " ATI Rage128 BIOS - ???\r\n\t???\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h failed\r\n\n\t???\r\n",
      "A01B": " PhoenixVIEW/LC - CRT MONITOR DETECTION\r\n\t???\r\n\nReturn: ???\r\n",
      "BD44": " Compaq QVision - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "BFA0": " VIDEO - Compaq ADAPT.COM - INSTALLATION CHECK\r\n\tBX = ADADh\r\n\nReturn: AX = BDBDh if newer ADAPT.COM installed\r\n\n\t    BX = BCD version (BH = major, BL = minor)\r\n\n\t    CL = ???\r\n\n\t    CH = ???\r\n\n\t    DL = ???\r\n\n\tAX = ADADh if older version of ADAPT.COM installed\r\n",
      "BFA1": " VIDEO - Compaq ADAPT.COM - GET ???\r\nReturn: AX = BDBEh if supported\r\n\n\t    CH = current value of ???\r\n\n\t    DL = current value of ???\r\n",
      "BFA2": " VIDEO - Compaq ADAPT.COM - SET ???\r\n\tCH = new value for ???\r\n\n\tDL = new value for ???\r\n\nReturn: AX = BDBEh if supported\r\n",
      "C000": " S3 SpeedUp v3.00+ - INSTALLATION CHECK\r\nReturn: AX = FFFFh if installed\r\n\n\t    DX = version number (binary, DH=major, DL=minor)\r\n\n\t    BX = resident code segment\r\n",
      "C001": " S3 SpeedUp v3.00+ - GET ACTIVE OPTIONS\r\nReturn: AX = FFFFh if function supported\r\n\n\t    BX = currently active options (see #00216)\r\n",
      "C002": " S3 SpeedUp v3.00+ - SET ACTIVE OPTIONS\r\n\tBX = new value for active options (see #00216)\r\n\nReturn: AX = FFFFh if function supported\r\n",
      "C003": " S3 SpeedUp v3.10+ - GET FLAGS\r\nReturn: AX = FFFFh if function supported\r\n\n\t    BX = flags\r\n\n\t\tbit 0: SpeedUp is active\r\n\n\t\tbit 1: Windows run after SpeedUp\r\n",
      "CB00": " UNCHAIN - SAVE CURRENT VGA REGISTERS\r\n",
      "CB01": " UNCHAIN - UPDATE PAGE 1 OFFSET\r\n\tBX = offset of page 1\r\n\nReturn: nothing\r\n",
      "CB02": " UNCHAIN - UPDATE PAGE 2 OFFSET\r\n\tBX = offset of page 2\r\n\nReturn: nothing\r\n",
      "CB03": " UNCHAIN - UPDATE PAGE 3 OFFSET\r\n\tBX = offset of page 3\r\n\nReturn: nothing\r\n",
      "CB04": " UNCHAIN - UPDATE PAGE 4 OFFSET\r\n\tBX = offset of page 4\r\n\nReturn: nothing\r\n",
      "CB05": " UNCHAIN - SAVE PALETTE\r\nReturn: nothing\r\n",
      "CB06": " UNCHAIN - RESTORE VGA REGISTERS\r\nReturn: nothing\r\n",
      "CBFF": " UNCHAIN - INSTALLATION CHECK\r\nReturn: AX = CCBBh if installed\r\n",
      "CC00": " VIDEO - UltraVision - GET STATUS (INSTALLATION CHECK)\r\n\tSI = magic value 0000h (if checking version)\r\n\nReturn: CX = product signature\r\n\n\t    ABCDh UltraVision\r\n\n\t    5546h ('UF') UltraFont\r\n\n\tAL = Ultravision extensions\r\n\n\t    00h enabled\r\n\n\t    FFh disabled\r\n\n\tAH = card designator\r\n\n\tBX:00F0h -> palette values (for compatibility with NEWFONT)\r\n\n\tDX = support for high resolution modes\r\n\n\t    00h not active\r\n\n\t    01h active\r\n\n\tSI = UltraVision version number (v1.2+), high byte=major,low byte=minor\r\n\n\t    unchanged for versions <1.2\r\n",
      "CC01": " VIDEO - UltraVision - DISABLE EXTENSIONS\r\nReturn: nothing\r\n",
      "CC02": " VIDEO - UltraVision - ENABLE EXTENSIONS\r\nReturn: nothing\r\n",
      "CD00": " VIDEO - UltraVision - LOAD ULTRAVISION PALETTE (color EGA,VGA)\r\n\tCL = palette table number (01h-07h for v1.x, 01h-0Fh for v2+)\r\n\n\tDS:DX -> 16-byte palette register list (colors for registers 00h-0Fh)\r\n\nReturn: nothing\r\n",
      "CD01": " VIDEO - UltraVision - SET PALETTE LOCKING STATUS (color EGA,VGA)\r\n\tCL = palette locking value\r\n\n\t    00h none\r\n\n\t    01h text modes only (02h,03h)\r\n\n\t    FFh all modes (all standard color text and graphics modes)\r\n\nReturn: nothing\r\n",
      "CD02": " VIDEO - UltraVision - GET ULTRAVISION PALETTE (EGA,VGA)\r\nReturn: CL = palette table number\r\n\n\tDS:DX -> 17-byte palette register list (see #00217)\r\n\n\tDS:SI -> current font names table (see #00218,#00219)\r\n",
      "CD03": " VIDEO - UltraVision - GET PALETTE LOCKING STATUS (color EGA,VGA)\r\nReturn: CL = palette locking value\r\n\n\t    00h none\r\n\n\t    01h text modes only\r\n\n\t    FFh all modes\r\n",
      "CD04": " VIDEO - UltraVision - GET UltraVision TEXT MODE (EGA,VGA)\r\nReturn: AL = mode number (see #00220)\r\n",
      "CD05": " VIDEO - UltraVision - SET CURSOR TYPE (EGA,VGA)\r\n\tCL = type\r\n\n\t    00h line cursor\r\n\n\t    FFh box cursor\r\n\nReturn: nothing\r\n",
      "CD06": " VIDEO - UltraVision - GET CURSOR TYPE (EGA,VGA)\r\nReturn: CL = type\r\n\n\t    00h line cursor\r\n\n\t    FFh box cursor\r\n",
      "CD07": " VIDEO - UltraVision v1.2+ - SET UNDERLINE STATUS (EGA,VGA)\r\n\tCL = hardware underline status (see #00221)\r\n\n\tBL = foreground color for normal text (FFh = current)\r\n\n\tBH = foreground color for bright text (FFh = current)\r\n\nReturn: CL = hardware underline status\r\n\n\tBL = current foreground color for normal text\r\n\n\tBH = current foreground color for bright text\r\n",
      "CD08": " VIDEO - UltraVision v1.2+ - GET UNDERLINE STATUS (EGA,VGA)\r\nReturn: CL = hardware underline status (see #00221)\r\n\n\tBL = foreground color for normal text\r\n\n\tBH = foreground color for bright text\r\n",
      "CD0F": " VIDEO - UltraVision - GET POINTER TO ??? (EGA,VGA)\r\nReturn: DS:DI -> pointer to ???\r\n",
      "CD10": " VIDEO - UltraVision - LOAD USER FONT (EGA,VGA)\r\n\tBH = bytes per character (08h,0Ah,0Bh,0Eh,13h,14h)\r\n\n\tCX = ABCDh load 9xN alternate font (v2+)\r\n\n\t   else number of characters to load\r\n\n\t\tDX = character offset into font table\r\n\n\t\tDS:SI -> 8-byte ASCII font name\r\n\n\tES:BP -> font definitions\r\n\nReturn: AX = FFFFh if invalid font parameters\r\n",
      "D000": " S3VBE/Core2.0 v3.00+ - INSTALLATION CHECK\r\nReturn: AX = FFFFh if installed\r\n\n\t    BX = resident code segment\r\n\n\t    DX = version (binary, DH = major, DL = minor)\r\n",
      "D001": " S3VBE/Core2.0 v3.00+ - GET ACTIVE OPTIONS\r\nReturn: AX = FFFFh if supported\r\n\n\t    BX = currently active options (see #00222)\r\n",
      "D002": " S3VBE/Core2.0 v3.00+ - SET ACTIVE OPTIONS\r\n\tBX = new active options (see #00222)\r\n\nReturn: AX = FFFFh if supported\r\n",
      "D003": " S3VBE/Core2.0 v3.10+ - GET VBE/Core CAPABILITIES\r\nReturn: AX = FFFFh if supported\r\n\n\t    BX = capabilities\r\n\n\t\tbit 0: SpeedUp = activate/deactivate linear addressing at\r\n\n\t\t\tA0000h for VBE functions 04h/05h\r\n",
      "D004": " S3VBE/Core2.0 v3.10+ - ACTIVATE SPEED-UP\r\nReturn: AX = FFFFh if supported\r\n\n\tBX = status\r\n\n\t    0000h SpeedUp activated\r\n\n\t    0001h SpeedUp not possible (wrong memory organization for mode)\r\n\n\t    0002h SpeedUp not possible (linear frame buffer active)\r\n",
      "D005": " S3VBE/Core2.0 v3.10+ - DEACTIVATE SPEED-UP\r\nReturn: AX = FFFFh if supported\r\n\n\tBX = status\r\n\n\t    0000h SpeedUp deactivated\r\n\n\t    0001h SpeedUp not possible (wrong memory organization for mode)\r\n\n\t    0002h SpeedUp not possible (linear frame buffer active)\r\n",
      "DFA5": " VIDEO - Compaq ADAPT.COM - GET ??? DATA AREA\r\nReturn: AX = BDBFh if supported\r\n\n\t    ES:DI -> ??? data area\r\n\n\t    BX = ES\r\n"
    }
  },
  "11": {
    "AX": {
      "0225": " Blank-It Screen Blanker - SET HOTKEY FOR MANUAL BLANKING\r\n\tBX = 6909h\r\n\n\tCL = key scan code (see #00229)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AL = error code\r\n",
      "FFFE": " BACK&FORTH (before v1.62) API\r\n\tCX = FFFEh\r\n\n\tBX = function\r\n\n\t    00h installation check\r\n\n\t\tReturn: AX = installation state\r\n\n\t\t\t    0001h BNFHIGH and BNFLOW both loaded\r\n\n\t\t\t    0003h only BNFHIGH loaded\r\n\n\t\t\t    else neither loaded\r\n\n\t    01h ???\r\n\n\t\tReturn: DX:AX -> ???\r\n\n\t    02h ???\r\n\n\t    03h ???\r\n\n\t    04h ???\r\n\n\t    05h ??? switches current PSP segment and stack if BNFLOW has not\r\n\n\t\t    yet announced itself installed\r\n\n\t    06h ???\r\n\n\t\tReturn: AX = ???\r\n"
    },
    "AH": {
      "BC": " BNU FOSSIL - INSTALLATION CHECK\r\n\tDX = 1954h\r\n\nReturn: AX = 1954h\r\n\n\tES:DX -> entry point of driver (instead of INT 14)\r\n"
    }
  },
  "12": {
    "AX": {
      "FFFE": " Back&Forth v1.62+ - API\r\n\tCX = FFFEh\r\n\n\tBX = function\r\n\n\t    00h installation check\r\n\n\t\tReturn: AX = 0001h installed\r\n\n\t\t\t     else  not loaded\r\n\n\t    01h (reserved)\r\n\n\t    02h build program ID list (shareware Back&Forth)\r\n\n\t\tES:DI -> buffer of at least 100 bytes, to be filled with words\r\n\n\t\tReturn: AX = number of programs defined\r\n\n\t\t\tES:DI buffer filled with AX words\r\n\n\t    02h get memory statistics (Back&Forth Professional)\r\n\n\t\tReturn: AX = available swap memory, KBytes\r\n\n\t\t\tBX = maximum task size, KBytes\r\n\n\t\t\tDX = fixed overhead per task, excluding video/macro\r\n\n\t\t\t      storage\r\n\n\t    03h switch to specified task (task need not be open yet)\r\n\n\t\tDX = two-letter program ID\r\n\n\t\tReturn: AX = status\r\n\n\t\t\t    0000h if task undefined\r\n\n\t\t\t    0001h task switch will occur when safe\r\n\n\t    04h (reserved)\r\n\n\t    05h (reserved)\r\n\n\t    06h get version (documented only for Back&Forth Professional)\r\n\n\t\tReturn: AX = version * 100 (v1.71 = 00ABh)\r\n\n\t    07h spawn program (Back&Forth Professional only???)\r\n\n\t\tES:DI -> BF_SPAWN record (see #00232)\r\n\n\t\tReturn: AX = status\r\n\n\t\t\t    0000h if no task handles free\r\n\n\t\t\t    0001h spawn will occur when safe\r\n\n\t    08h get open tasks (documented only for Back&Forth Professional)\r\n\n\t\tES:DI -> task info buffer (see #00231,#00233)\r\n\n\t\tReturn: AX = number of open tasks (max 20)\r\n\n\t\tNote:\tthe supplied buffer must be large enough to hold 21\r\n\n\t\t\t  task entries\r\n\n\t    09h (reserved)\r\n\n\t    ---Back&Forth Professional---\r\n\n\t    0Ah get active clipboard filename\r\n\n\t\tReturn: DX:AX -> ASCIZ clipboard filename\r\n\n\t    0Bh get active task number\r\n\n\t\tAX = active task number (00h-13h)\r\n\n\t\tBX = number of tasks allocated\r\n\n\t\tDX = maximum number of tasks\r\n\n\t    0Ch (reserved)\r\n\n\t    0Dh (reserved)\r\n\n\t    0Eh (reserved)\r\n\n\t    0Fh stuff string into keyboard buffer\r\n\n\t\tES:DI -> ASCIZ string to be stuffed\r\n\n\t\tReturn: nothing\r\n\n\t    10h check if in graphics mode\r\n\n\t\tReturn: AX = state\r\n\n\t\t\t    0000h color text mode\r\n\n\t\t\t    0004h mono text mode\r\n\n\t\t\t    FFFFh graphics mode\r\n\n\t    11h get Back&Forth Professional user number\r\n\n\t\tReturn: AX = user number (0000h-00FFh)\r\n\n\t    12h switch task by task number\r\n\n\t\tDX = task number\r\n\n\t\tReturn: AX = status\r\n\n\t\t\t    0000h attempted to switch to active task\r\n\n\t\t\t    0001h task switch will occur when safe\r\n\n\t\t\t    FFFFh invalid task number\r\n\n\t    13h delete (kill) task\r\n\n\t\tDX = task number\r\n\n\t\tReturn: AX = status\r\n\n\t\t\t    0000h attempted to delete the active task\r\n\n\t\t\t    0001h successfully deleted\r\n\n\t\t\t    FFFFh invalid task number\r\n\n\t\tNote:\tthe active task number will change if the deleted task\r\n\n\t\t\t  was lower in the task list than the active task\r\n\n\t    14h get next available task handle\r\n\n\t\tReturn:\tAX = next available task handle\r\n\n\t\t\t    FFFFh if task table is full\r\n"
    }
  },
  "13": {
    "AH": {
      "00": " DISK - RESET DISK SYSTEM\r\n\tDL = drive (if bit 7 is set both hard disks and floppy disks reset)\r\n\nReturn: AH = status (see #00234)\r\n\n\tCF clear if successful (returned AH=00h)\r\n\n\tCF set on error\r\n",
      "01": " DISK - GET STATUS OF LAST OPERATION\r\n\tDL = drive (bit 7 set for hard disk)\r\n\nReturn: CF clear if successful (returned status 00h)\r\n\n\tCF set on error\r\n\n\tAH = status of previous operation (see #00234)\r\n",
      "02": " DISK - READ SECTOR(S) INTO MEMORY\r\n\tAL = number of sectors to read (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF set on error\r\n\n\t    if AH = 11h (corrected ECC error), AL = burst length\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234)\r\n\n\tAL = number of sectors transferred (only valid if CF set for some\r\n\n\t      BIOSes)\r\n",
      "03": " DISK - WRITE DISK SECTOR(S)\r\n\tAL = number of sectors to write (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234)\r\n\n\tAL = number of sectors transferred\r\n\n\t      (only valid if CF set for some BIOSes)\r\n",
      "04": " DISK - VERIFY DISK SECTOR(S)\r\n\tAL = number of sectors to verify (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> data buffer (PC,XT,AT with BIOS prior to 1985/11/15)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234)\r\n\n\tAL = number of sectors verified\r\n",
      "05": " FIXED DISK - FORMAT TRACK\r\n\tAL = interleave value (XT-type controllers only)\r\n\n\tES:BX -> 512-byte format buffer\r\n\n\t\tthe first 2*(sectors/track) bytes contain F,N for each sector\r\n\n\t\t   F = sector type\r\n\n\t\t\t00h for good sector\r\n\n\t\t\t20h to unassign from alternate location\r\n\n\t\t\t40h to assign to alternate location\r\n\n\t\t\t80h for bad sector\r\n\n\t\t   N = sector number\r\n\n\tCH = cylinder number (bits 8,9 in high bits of CL)\r\n\n\tCL = high bits of cylinder number (bits 7,6)\r\n\n\tDH = head\r\n\n\tDL = drive\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status code (see #00234)\r\n",
      "06": " FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)\r\n\tAL = interleave value\r\n\n\tCH = cylinder number (bits 8,9 in high bits of CL)\r\n\n\tCL = sector number\r\n\n\tDH = head\r\n\n\tDL = drive\r\n\nReturn: AH = status code (see #00234)\r\n",
      "07": " FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)\r\n\tAL = interleave value (XT only)\r\n\n\tES:BX = 512-byte format buffer (see AH=05h)\r\n\n\tCH = cylinder number (bits 8,9 in high bits of CL)\r\n\n\tCL = sector number\r\n\n\tDH = head\r\n\n\tDL = drive\r\n\nReturn: AH = status code (see #00234)\r\n",
      "08": " DISK - GET DRIVE PARAMETERS (PC,XT286,CONV,PS,ESDI,SCSI)\r\n\tDL = drive (bit 7 set for hard disk)\r\n\n\tES:DI = 0000h:0000h to guard against BIOS bugs\r\n\nReturn: CF set on error\r\n\n\t    AH = status (07h) (see #00234)\r\n\n\tCF clear if successful\r\n\n\t    AH = 00h\r\n\n\t    AL = 00h on at least some BIOSes\r\n\n\t    BL = drive type (AT/PS2 floppies only) (see #00242)\r\n\n\t    CH = low eight bits of maximum cylinder number\r\n\n\t    CL = maximum sector number (bits 5-0)\r\n\n\t\t high two bits of maximum cylinder number (bits 7-6)\r\n\n\t    DH = maximum head number\r\n\n\t    DL = number of drives\r\n\n\t    ES:DI -> drive parameter table (floppies only)\r\n",
      "09": " HARD DISK - INITIALIZE CONTROLLER WITH DRIVE PARAMETERS (AT,PS)\r\n\tDL = drive (80h for first, 81h for second)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\tAH = status (see #00234)\r\n",
      "0A": " HARD DISK - READ LONG SECTOR(S) (AT and later)\r\n\tAL = number of sectors (01h may be only value supported)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number (bits 5-0)\r\n\n\t     high two bits of cylinder number (bits 7-6)\r\n\n\tDH = head number\r\n\n\tDL = drive number (80h = first, 81h = second)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\tAH = status (see #00234)\r\n\n\tAL = number of sectors transferred\r\n",
      "0B": " HARD DISK - WRITE LONG SECTOR(S) (AT and later)\r\n\tAL = number of sectors (01h may be only value supported)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number (bits 5-0)\r\n\n\t     high two bits of cylinder number (bits 7-6)\r\n\n\tDH = head number\r\n\n\tDL = drive number (80h = first, 81h = second)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\tAH = status (see #00234)\r\n\n\tAL = number of sectors transferred\r\n",
      "0C": " HARD DISK - SEEK TO CYLINDER\r\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number (bits 5-0)\r\n\n\t    high two bits of cylinder number (bits 7-6)\r\n\n\tDH = head number\r\n\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234)\r\n",
      "0D": " HARD DISK - RESET HARD DISKS\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234)\r\n",
      "0E": " HARD DISK - READ SECTOR BUFFER (XT only)\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\n\tES:BX -> buffer\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status code (see #00234)\r\n",
      "0F": " HARD DISK - WRITE SECTOR BUFFER (XT only)\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\n\tES:BX -> buffer\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status code (see #00234)\r\n",
      "10": " HARD DISK - CHECK IF DRIVE READY\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at AH=01h)\r\n",
      "11": " HARD DISK - RECALIBRATE DRIVE\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at AH=01h)\r\n",
      "12": " HARD DISK - CONTROLLER RAM DIAGNOSTIC (XT,PS)\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status code (see #00234 at AH=01h)\r\n\n\tAL = 00h\r\n",
      "13": " HARD DISK - DRIVE DIAGNOSTIC (XT,PS)\r\n\tDL = drive number (80h = first, 81h = second hard disk)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status code (see #00234 at AH=01h)\r\n\n\tAL = 00h\r\n",
      "14": " HARD DISK - CONTROLLER INTERNAL DIAGNOSTIC\r\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status code (see #00234 at AH=01h)\r\n\n\tAL = 00h\r\n",
      "15": " DISK - GET DISK TYPE (XT 1986/1/10 or later,XT286,AT,PS)\r\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\t(AL = FFh, CX = FFFFh, see Note)\r\n\nReturn: CF clear if successful\r\n\n\t    AH = type code\r\n\n\t\t00h no such drive\r\n\n\t\t    (SpeedStor) AL = 03h hard disk\r\n\n\t\t\t\t    CX:DX = number of 512-byte sectors\r\n\n\t\t01h floppy without change-line support\r\n\n\t\t02h floppy (or other removable drive) with change-line support\r\n\n\t\t03h hard disk\r\n\n\t\t    CX:DX = number of 512-byte sectors\r\n\n\tCF set on error\r\n\n\t    AH = status (see #00234 at AH=01h)\r\n",
      "16": " FLOPPY DISK - DETECT DISK CHANGE (XT 1986/1/10 or later,XT286,AT,PS)\r\n\tDL = drive number (00h-7Fh)\r\n\n\tSI = 0000h (to avoid crash on AT&T 6300)\r\n\nReturn: CF clear if change line inactive\r\n\n\t    AH = 00h (disk not changed)\r\n\n\tCF set if change line active\r\n\n\t    AH = status\r\n\n\t\t01h invalid command (SyQuest)\r\n\n\t\t06h change line active or not supported\r\n\n\t\t80h drive not ready or not present\r\n",
      "17": " FLOPPY DISK - SET DISK TYPE FOR FORMAT (AT,PS)\r\n\tAL = format type\r\n\n\t    01h = 320/360K disk in 360K drive\r\n\n\t    02h = 320/360K disk in 1.2M drive\r\n\n\t    03h = 1.2M disk in 1.2M drive\r\n\n\t    04h = 720K disk in 720K or 1.44M drive\r\n\n\tDL = drive number\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at AH=01h)\r\n",
      "18": " DISK - SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)\r\n\tDL = drive number\r\n\n\tCH = lower 8 bits of highest cylinder number (number of cylinders - 1)\r\n\n\tCL = sectors per track (bits 0-5)\r\n\n\t     top 2 bits of highest cylinder number (bits 6,7)\r\n\nReturn: AH = status\r\n\n\t    00h requested combination supported\r\n\n\t    01h function not available\r\n\n\t    0Ch not supported or drive type unknown\r\n\n\t    80h there is no disk in the drive\r\n\n\tES:DI -> 11-byte parameter table (see #01264 at INT 1E)\r\n",
      "19": " FIXED DISK - PARK HEADS ON ESDI DRIVE (XT286,PS)\r\n\tDL = drive\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at AH=01h)\r\n",
      "FF": " IBM SurePath BIOS - Officially \"Private\" Function\r\n"
    }
  },
  "14": {
    "AH": {
      "00": " MBBIOS - INITIALIZE PORT\r\n\tAL = port parameters (see #00302)\r\n\n\tDX = port number\r\n\nReturn: AH = line status (see #00304)\r\n\n\tAL = modem status (see #00305)\r\n",
      "01": " SERIAL - WRITE CHARACTER TO PORT\r\n\tAL = character to write\r\n\n\tDX = port number (00h-03h) (04h-43h for Digiboard XAPCM232.SYS)\r\n\nReturn: AH bit 7 clear if successful\r\n\n\tAH bit 7 set on error\r\n\n\tAH bits 6-0 = port status (see #00304)\r\n",
      "02": " FOSSIL - RECEIVE CHARACTER WITH WAIT\r\n\tDX = port number (0-3)\r\n\nReturn: AL = character received\r\n\n\tAH = 00h\r\n",
      "03": " SERIAL - GET PORT STATUS\r\n\tAL = 00h (ArtiCom)\r\n\n\tDX = port number (00h-03h) (04h-43h for Digiboard XAPCM232.SYS)\r\n\nReturn: AH = line status (see #00304)\r\n\n\tAL = modem status (see #00305)\r\n\n\tAX = 9E00h if disconnected (ArtiCom)\r\n",
      "04": " MBBIOS - INSTALLATION CHECK\r\n\tDX = port number\r\n\nReturn: AX = AA55h if installed on specified port\r\n",
      "05": " PC-MOS/386 v5.01 $serial.sys v5.04 - CHANGE PORT PROTOCOL\r\n\tAL = new port protocol (see #00336)\r\n\n\tBH = new XOFF character\r\n\n\tBL = new XON character\r\n\n\tDX = port number\r\n\nReturn: AH = FFh if invalid protocol\r\n",
      "06": " PC-MOS/386 v5.01 $serial.sys v5.04 - DRIVER 'ID' FUNCTION\r\n\tDX = port number\r\n\nReturn: AH bit 7 set\r\n\n\tAL = number of highest function supported by driver\r\n",
      "07": " PC-MOS/386 v5.01 $serial.sys v5.04 - SEND RS-232 BREAK\r\n\tBX = duration of break in clock ticks\r\n\n\tDX = port number\r\n\nReturn: nothing\r\n",
      "08": " PC-MOS/386 v5.01 $serial.sys v5.04 - INPUT STATUS CHECK\r\n\tDX = port number\r\n\nReturn: CF set if carrier loss detected\r\n\n\tZF set if input buffer empty\r\n\n\tZF clear if characters available\r\n\n\t    AL = next character dequeued\r\n",
      "09": " PC-MOS/386 v5.01 $serial.sys v5.04 - RESET I/O BUFFER POINTERS\r\n\tDX = port number\r\n\nReturn: nothing\r\n",
      "0A": " MBBIOS - WRITE BUFFER\r\n\tCX = count\r\n\n\tES:DI -> buffer (see #00338)\r\n\nReturn: AX = status (see #00304,#00305)\r\n\n\tCX = unsent character count\r\n\n\tDI updated\r\n",
      "0B": " MBBIOS - READ BUFFER\r\n\tCX = size of buffer\r\n\n\tES:DI -> buffer\r\n\nReturn: AH = composite line status (see #00304) formed by ORing all statuses\r\n\n\t\t  on receive interrupts; bit 0 set if additional characters\r\n\n\t\t  available\r\n\n\tAL = composite modem status (see #00305) formed by ORing all statuses\r\n\n\tCX = number of characters actually read\r\n\n\tDI updated\r\n",
      "0C": " MBBIOS PACCOM support - BUFFER MANAGEMENT\r\n\tES = segment of buffer to free, or 0000h to allocate new buffer\r\n\nReturn: ES = segment of allocated buffer (if ES=0000h on entry)\r\n",
      "0D": " MBBIOS PACCOM support - SET TXD\r\n\tAL = new setting (FFh = 1.0)\r\n\nReturn: nothing\r\n",
      "0E": " MBBIOS PACCOM support - SET PERSISTENCE\r\n\tAL = new setting (FFh = 1.0)\r\n\nReturn: nothing\r\n",
      "0F": " MBBIOS PACCOM support - SET SLOT TIME\r\n\tAL = new setting in clock ticks\r\n\nReturn: nothing\r\n",
      "10": " MBBIOS PACCOM support - SET CRC WAIT\r\n\tAL = new setting in clock ticks (should be at least 5 character times)\r\n\nReturn: nothing\r\n",
      "11": " PC-MOS/386 v5.01 $serial.sys v5.04 - DISABLE PORT\r\n\tDX = port number\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h IRQ for port is shared\r\n\n\t    02h IRQ was reserved\r\n",
      "12": " PC-MOS/386 v5.01 $serial.sys v5.04 - GET CURRENT PORT PARAMETERS\r\n\tDX = port number\r\n\nReturn: AH = status\r\n\n\t    FFh port number invalid\r\n\n\tAL = line parameters (see #00304)\r\n\n\tAH = flow control configuration (see #00336 at AH=05h\"PC-MOS\")\r\n\n\tCX:BX = bps rate\r\n\n\tDL = XOFF character or 00h for none\r\n\n\tDH = XON character or 00h for none\r\n",
      "13": " PC-MOS/386 v5.01 $serial.sys v5.04 - REGISTER A PORT WITH A TERMINAL\r\n\tDX = port number\r\n\nReturn: AH = status\r\n\n\t    FFh port number invalid\r\n\n\t    else\r\n\n\t\tES:BX -> BYTE flag (00h buffer empty, FFh buffer contains data)\r\n",
      "14": " Digiboard - GET NUMBER OF BOARDS INSTALLED\r\nReturn: AX = number of boards installed\r\n",
      "15": " Digiboard - ENABLE/DISABLE MEMORY\r\n\tAL = new state (00h disabled, 01h enabled)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "16": " Digiboard DigiCHANNEL PC/X* - CCB COMMAND\r\n\tAL = CCB command number (see #00342) (see also following entries)\r\n\n\tBL = byte 2\r\n\n\tBH = byte 3\r\n\n\tCL = byte 1 (for all channel functions except 4Eh and 4Fh)\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "17": " PC-MOS/386 v5.01 $serial.sys v5.04 - WRITE MODEM CONTROL REGISTER\r\n\tAL = new value for UART's modem control register\r\n\n\tDX = port number\r\n\nReturn: nothing\r\n",
      "18": " PC-MOS/386 v5.01 $serial.sys v5.04 - GET DRIVER DESCRIPTION\r\n\tDX = port number\r\n\nReturn: DS:BX -> 40-byte buffer containing a string identifying the serial\r\n\n\t\tdriver\r\n",
      "19": " PC-MOS/386 v5.01 $serial.sys v5.04 - SELECTIVE BUFFER FLUSH\r\n\tAL = what to flush\r\n\n\t    bit 0: input buffer\r\n\n\t    bit 1: output buffer\r\n\n\tDX = port number\r\n\nReturn: nothing\r\n",
      "1A": " Digiboard DigiCHANNEL PC/X - SPECIAL CHARACTER FLAG/COUNTER\r\n\tBX = subfunction\r\n\n\t    00h return pointer to special character flag byte\r\n\n\t    01h return pointer to special character counter word\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: ES:BX -> special character flag or counter\r\n",
      "1B": " FOSSIL - RETURN INFORMATION ABOUT THE DRIVER\r\n\tDX = port number\r\n\n\tCX = size of user buffer\r\n\n\tES:DI -> user buffer for driver info (see #00343)\r\n\nReturn: AX = number of characters transferred\r\n\n\tCX = 3058h (\"0X\") (X00 FOSSIL only)\r\n\n\tDX = 2030h (\" 0\") (X00 FOSSIL only)\r\n",
      "1C": " X00 FOSSIL - ACTIVATE PORT\r\n\tDX = port number\r\n\nReturn: AX = 1954h if successful\r\n\n\tBL = maximum function number supported (not including 7Eh and above)\r\n\n\tBH = revision of FOSSIL specification supported\r\n",
      "1D": " X00 FOSSIL - DEACTIVATE PORT\r\n\tDX = port number\r\n\nReturn: none\r\n",
      "1E": " HUNTER 16 - READ COMMS PARAMETERS\r\n\tCX = channel number (00h COM1, 01h COM2, ...)\r\n\n\tDS:BX -> buffer for communications parameters (see #00347)\r\n\nReturn: DS:BX buffer filled\r\n",
      "1F": " X00 FOSSIL - EXTENDED SERIAL PORT STATUS/CONTROL\r\n\tDX = port number\r\n\n\tAL = direction\r\n\n\t    00h read modem control register\r\n\n\t\tReturn: BL = modem control register (see #00349)\r\n\n\t\t\tAH = status\r\n\n\t    01h write modem control register\r\n\n\t\tBL = modem control register (see #00349)\r\n\n\t\tReturn: AX = status\r\n",
      "20": " HUNTER 16 - SELECT COMMS PARAMETERS\r\n\tCX = channel number (00h COM1, 01h COM2, ...)\r\n\n\tDS:BX -> buffer with communications parameter (see #00347)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h invalid parameter\r\n",
      "21": " HUNTER 16 - EXTENDED CONTROL\r\n\tAL = command\r\n\n\t    01h force transmission of buffer\r\n\n\t    02h clear transmit buffer\r\n\n\t    03h clear receive buffer\r\n\n\tDX = port (00h COM1, 01h COM2)\r\n\nReturn: AH = extended status\r\n",
      "22": " HUNTER 16 - EXTENDED STATUS\r\n\tDX = port (00h COM1, 01h COM2)\r\n\nReturn: AH = extended status\r\n\n\tBX = number of characters in input buffer\r\n\n\tCX = number of characters in output buffer\r\n",
      "23": " HUNTER 16 - CONTROL HANDSHAKE LINES\r\n\tBH = handshake line to set (00h RTS, 01h DTR)\r\n\n\tBL = new level (00h low, 01h high)\r\n\nReturn: nothing\r\n",
      "24": " HUNTER 16 - CONTROL CTS HANDSHAKING\r\n\tAL = new CTS handshake state for COM1 (00h disabled, 01h enabled)\r\n\nReturn: nothing\r\n",
      "25": " HUNTER 16 - CONTROL RS232 DRIVERS\r\n\tAL = new state of RS232 drivers (00h off, 01h on)\r\n\nReturn: nothing\r\n",
      "26": " HUNTER 16 - CONTROL RI POWER UP\r\n\tAL = 00h enable RI power up\r\n\n\t    else disable RI power up\r\n\nReturn: nothing\r\n",
      "27": " HUNTER 16 - GET INSTALLED PROTOCOLS COUNT\r\n\tAL = number of extended protocols installed (since last call)\r\n\nReturn: AL = total number installed, including new ones\r\n",
      "28": " HUNTER 16 - GET PROTOCOL NAME\r\n\tAL = protocol handle\r\n\n\tDS:BX -> 8 character buffer for protocol name\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t\tDS:BX buffer filled with the protocol name\r\n\n\t    FFh failed\r\n",
      "29": " HUNTER 16 - GET PROTOCOL HANDLE\r\n\tDS:BX -> buffer containing the protocol name\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t\tAL = handle\r\n\n\t    FFh failed\r\n",
      "2A": " HUNTER 16 - EXTENDED PROTOCOL MENU\r\n\tAL = protocol handle\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    FFh failed\r\n\n\tAL = menu handle\r\n",
      "2B": " HUNTER 16 - GET EXTENDED PROTOCOL PARAMETERS\r\n\tAL = protocol handle\r\n\n\tDS:BX -> buffer for extended protocol parameters\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t\tDS:BX buffer filled with extended parameters\r\n\n\t    FFh failed\r\n",
      "2C": " HUNTER 16 - SET DTR\r\n\tAL nonzero\r\n\n\tBL = new state\r\n\n\t    00h\t normal operation\r\n\n\t    else force DTR high\r\n\nReturn: AH = 00h\r\n",
      "56": " BWCOM14 - INSTALLATION CHECK\r\nReturn: CX = 0001h if installed\r\n",
      "57": " BWCOM14 - INITIALIZE\r\n\tDL = port number\r\n\nReturn: AL = initialization status (00h successful, 01h already initialized)\r\n\n\tCX = port status (0001h port redirected, 0002h and FFFFh failed)\r\n",
      "58": " BWCOM14 - SHUTDOWN\r\nReturn: CX = status (0001h successful, 0002h not initialized)\r\n",
      "7E": " FOSSIL - INSTALL AN EXTERNAL APPLICATION FUNCTION\r\n\tAL = code assigned to external application (80h-BFh)\r\n\n\t    80h reserved for communications FOSSIL\r\n\n\t    81h video FOSSIL\r\n\n\t    82h reserved for keyboard FOSSIL\r\n\n\t    83h reserved for system FOSSIL\r\n\n\tES:DX -> entry point\r\n\nReturn: AX = 1954h\r\n\n\tBL = code assigned to application (same as input AL)\r\n\n\tDH = status\r\n\n\t    00h failed\r\n\n\t    01h successful\r\n",
      "7F": " FOSSIL - REMOVE AN EXTERNAL APPLICATION FUNCTION\r\n\tAL = code assigned to external application\r\n\n\tES:DX -> entry point\r\n\nReturn: AX = 1954h\r\n\n\tBL = code assigned to application (same as input AL)\r\n\n\tDH = status\r\n\n\t    00h failed\r\n\n\t    01h successful\r\n",
      "80": " COURIERS.COM - INSTALLATION CHECK\r\nReturn: AH = E8h if loaded\r\n",
      "81": " COMM-DRV - EXTENDED INITIALIZATION\r\n\tBX:DI -> port control block (see #00367)\r\n\n\tDX = port number\r\n\nReturn: AH = line status register (see #00304)\r\n\n\t    error if bit 7 set\r\n\n\tAL = modem status register (see #00305)\r\n",
      "82": " COMM-DRV v14.0 - PORT CLEANUP\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "83": " COMM-DRV v14.0 - FLUSH COMMUNICATION BUFFERS\r\n\tDX = port number\r\n\n\tAL = subfunction\r\n\n\t    00h flush input buffer\r\n\n\t    01h flush output buffer\r\n\n\t    02h flush both buffers\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "84": " COMM-DRV v14.0 - SEND PACKET\r\n\tCX = packet length in bytes\r\n\n\tDX = port number\r\n\n\tES:DI -> packet to be sent\r\n\nReturn: AH = line status (see #00304)\r\n\n\t    bit 7 set on error\r\n\n\tAL destroyed\r\n",
      "85": " COMM-DRV v14.0 - RECEIVE PACKET\r\n\tCX = length of packet in bytes\r\n\n\tDX = port number\r\n\n\tES:DI -> buffer for packet\r\n\nReturn: AH = line status (see #00304)\r\n\n\t    bit 7 set on error\r\n\n\tAL destroyed\r\n",
      "86": " COMM-DRV v14.0 - SET INPUT/OUTPUT TIMEOUTS\r\n\tBL = maximum clock ticks to wait before signalling error on input func\r\n\n\tBH = maximum clock ticks to wait before signalling error on output\r\n\n\tDX = port number\r\n\n\tSI = input timeout in clock ticks if BL=FFh and BH=FFh\r\n\n\tDI = output timeout in clock ticks if BL=FFh and BH=FFh\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "87": " COMM-DRV v14.0 - TURN ON DTR\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "88": " COMM-DRV v14.0 - TURN OFF DTR\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "89": " COMM-DRV v14.0 - TURN ON RTS\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "8A": " COMM-DRV v14.0 - TURN OFF RTS\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "8B": " COMM-DRV v14.0 - SET USER INTERRUPT ROUTINE\r\n\tCX = bitmask of interrupt to process\r\n\n\t    00h = deinstall\r\n\n\tBX:DI -> DWORD containing address of function to be called\r\n\nReturn: AH bit 7 clear if successful\r\n\n\tAH bit 7 set on error\r\n",
      "8C": " COMM-DRV v14.0 - READ UART REGISTER\r\n\tAL = register offset\r\n\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n\n\t    AL = contents of UART register\r\n",
      "8D": " COMM-DRV v14.0 - WRITE UART REGISTER\r\n\tAL = register offset\r\n\n\tBL = new value for UART register\r\n\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "8E": " COMM-DRV v14.0 - READ PACKET NONDESTRUCTIVELY\r\n\tCX = length of packet in bytes\r\n\n\tDX = port number\r\n\n\tES:DI -> buffer for packet\r\n\nReturn: AH = line status (see #00304)\r\n\n\t    bit 7 set on error (see AX=8000h\"COMM-DRV\")\r\n\n\tAL destroyed\r\n",
      "A0": " Interconnections Inc. TES - INSTALLATION CHECK/STATUS REPORT\r\n\tCX = FFFFh\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 5445h ('TE')\r\n\n\t    CX <> FFFFh\r\n\n\t    DX = port number\r\n\n\tCF set on error\r\n",
      "A1": " Interconnections Inc. TES - GET LIST OF SESSIONS WITH STATUS\r\nReturn: CX = number of active sessions\r\n\n\tES:SI -> status array (see #00395)\r\n",
      "A2": " Interconnections Inc. TES - GET LIST OF SERVER NAMES\r\nReturn: CX = number of servers\r\n\n\tES:SI -> array of offsets from ES for server names\r\n",
      "A3": " Interconnections Inc. TES - START A NEW SESSION\r\n\tES:SI -> ???\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 5445h ('TE')\r\n\n\t    CX <> FFFFh\r\n\n\t    DX = port number\r\n\n\tCF set on error\r\n",
      "A4": " Interconnections Inc. TES - HOLD CURRENTLY ACTIVE SESSION\r\n\t???\r\n\nReturn: ???\r\n",
      "A5": " Interconnections Inc. TES - RESUME A SESSION\r\n\tAL = session number\r\n\nReturn: ???\r\n",
      "A6": " Interconnections Inc. TES - DROP A SESSION\r\n\tAL = session number\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    else error\r\n",
      "A7": " Interconnections Inc. TES - SWITCH TO NEXT ACTIVE SESSION\r\n\t???\r\n\nReturn: ???\r\n",
      "A8": " Interconnections Inc. TES - SEND STRING TO COMMAND INTERPRETER\r\n\tAL = 00h no visible response\r\n\n\tES:SI -> ASCIZ command\r\n\nReturn: ???\r\n",
      "B0": " 3com BAPI SERIAL I/O - EN/DISABLE \"ENTER COMMAND MODE\" (ECM) CHARACTER\r\n\tAL = new state (00h disabled, 01h enabled)\r\n\nReturn: AH = return code (00h,07h,0Ah) (see #00394)\r\n",
      "B1": " 3com BAPI SERIAL I/O - ENTER COMMAND MODE\r\nReturn: AH = return code (00h,07h,0Ah) (see #00394)\r\n",
      "B2": " 3com BAPI SERIAL I/O - GET ECM WATCH STATE\r\nReturn: AH = return code (00h,07h,0Ah) (see #00394)\r\n\n\tAL = watch flag (00h disabled, 01h enabled)\r\n",
      "B3": " 3com BAPI SERIAL I/O - GET/SET CONFIGURATION INFO\r\n\tAL = direction (00h get, 01h set)\r\n\n\tDH = session ID (00h for external session managment)\r\n\n\tDL = configuration item (00h = end-of-line mapping)\r\n\n\tCX = new configuration item value (if AL=01h)\r\n\n\t    ---if DL=00h---\r\n\n\t    CH = application EOL type (app to Telnet client)\r\n\n\t\t01h application will send lone CR\r\n\n\t\t02h application will send CR-? pair\r\n\n\t    CL = driver EOL type (Telnet client to Telnet server)\r\n\n\t\t01h driver should send CR-NUL pair\r\n\n\t\t02h driver should send CR-LF pair\r\n\nReturn: AH = return code (00h,03h,09h-0Bh) (see #00394)\r\n\n\t---if AL=00h---\r\n\n\tCX = configuration item value (above)\r\n",
      "F9": " IBM/Yale EBIOS SERIAL I/O - REGAIN CONTROL\r\n\tDX = port (00h-03h)\r\n\nReturn: nothing\r\n",
      "FA": " IBM/Yale EBIOS SERIAL I/O - SEND BREAK\r\n\tDX = port (00h-03h)\r\n\nReturn: nothing\r\n",
      "FB": " IBM/Yale EBIOS SERIAL I/O - SET OUTGOING MODEM SIGNALS\r\n\tAL = modem control register (see #00334 at AH=05h\"SERIAL\")\r\n\n\tDX = port (00h-03h)\r\n\nReturn: nothing\r\n",
      "FC": " IBM/Yale EBIOS SERIAL I/O - READ CHARACTER, NO WAIT\r\n\tDX = port (00h-03h)\r\n\nReturn: AH = RS232 status bits (see #00304 at AH=03h)\r\n\n\tAL = character\r\n"
    },
    "AX": {
      "0400": " Microsoft Systems Journal TSRCOMM INT14 - INSTALLATION CHECK\r\nReturn: AX = 0FF0h\r\n",
      "0401": " Microsoft Systems Journal TSRCOMM INT14 - INITIALIZE MODE\r\n\tCX = mode\r\n\nReturn: nothing\r\n",
      "0402": " Microsoft Systems Journal TSRCOMM INT14 - EXTENDED INITIALIZE\r\n\tCL = parameters\r\n\nReturn: nothing\r\n",
      "0403": " Microsoft Systems Journal TSRCOMM INT14 - SET TIMEOUT\r\n\tCX = timeout\r\n\nReturn: nothing\r\n",
      "0404": " Microsoft Systems Journal TSRCOMM INT14 - CLEAR THE RECEIVE BUFFER\r\nReturn: nothing\r\n",
      "0405": " Microsoft Systems Journal TSRCOMM INT14 - GET RECEIVE BUFFER COUNT\r\nReturn: AX = number of characters in buffer\r\n",
      "0406": " Microsoft Systems Journal TSRCOMM INT14 - CLEAR THE TRANSMIT BUFFER\r\nReturn: nothing\r\n",
      "0407": " Microsoft Systems Journal TSRCOMM INT14 - GET TRANSMIT BUFFER COUNT\r\nReturn: AX = number of characters in the buffer\r\n",
      "0408": " Microsoft Systems Journal TSRCOMM INT14 - UNINSTALL\r\nReturn: nothing\r\n",
      "0D00": " MBBIOS - GET AVAILABLE BYTES\r\nReturn: AX = bytes in transmit buffer\r\n\n\tCX = bytes in receive buffer\r\n",
      "0D01": " MBBIOS - LOWER ALL MODEM CONTROL SIGNALS\r\nReturn: nothing\r\n",
      "0D02": " MBBIOS - RAISE ALL MODEM CONTROL SIGNALS\r\nReturn: nothing\r\n",
      "0D03": " MBBIOS - SET HANDSHAKE BYTE\r\n\tCL = new handshake byte\r\n\nReturn: CL = previous handshake byte\r\n",
      "1646": " Digiboard - CCB COMMAND - SET INTERRUPT TO HOST MASK\r\n\tBL = bits to set\r\n\n\tBH = bits to clear\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "1647": " Digiboard - CCB COMMAND - SET BAUD/DATABITS/STOPBITS/PARITY\r\n\tBL = baud\r\n\n\tBH = datatype\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "1649": " Digiboard - CCB COMMAND - SET MODEM LINES\r\n\tBL = bits to set\r\n\n\tBH = bits to clear\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "164A": " Digiboard - CCB COMMAND - SET BREAK COUNT\r\n\tBL = break count\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "164B": " Digiboard - CCB COMMAND - SET HANDSHAKE\r\n\tBL = bits to set\r\n\n\tBH = bits to clear\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "164C": " Digiboard - CCB COMMAND - SET XON/XOFF CHARACTERS\r\n\tBL = XON character\r\n\n\tBH = XOFF character\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "164D": " Digiboard - CCB COMMAND - SET TRANSMIT MID-WATER MARK\r\n\tBX = new mid-water mark\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "164E": " Digiboard - CCB COMMAND - IRQ POLLING TIMER TO HOST\r\n\tBL = ticks\r\n\n\tBH = ???\r\n\n\tCL = mode\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "164F": " Digiboard - CCB COMMAND - BUFFER SET ALL\r\n\tBL = size\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "1653": " Digiboard - CCB COMMAND - SPECIAL CHARACTER INTERRUPT\r\n\tBL = enable/disable\r\n\n\tBH = special character\r\n\n\tCL = byte 1\r\n\n\tDX = port number (00h-03h) (04h-43h for XAPCM232.SYS)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    80h error\r\n\n\t    FFh error\r\n",
      "2C00": " HUNTER 16 - GET DTR\r\nReturn: AH = 00h\r\n\n\tBL = current state\r\n\n\t    00h\t normal DTR operation\r\n\n\t    else DTR is forced high\r\n",
      "6F00": " HP Vectra EX-BIOS - \"F14_INQUIRE\" - INSTALLATION CHECK\r\n\tBX <> 4850h (usually set to 0000h for simplicity)\r\n\nReturn: BX = 4850h (\"HP\") if HP Extended BIOS serial port extensions available\r\n\n\tAX destroyed\r\n",
      "6F01": " HP Vectra EX-BIOS - \"F14_EXINIT\" - INITIALIZE SERIAL PORT\r\n\tBX = port attributes (see #00356)\r\n\n\tDX = port number (0-3)\r\n\nReturn: AH = line status (see #00304)\r\n\n\tAL = modem status (see #00305)\r\n",
      "6F02": " HP Vectra EX-BIOS - \"F14_PUT_BUFFER\" - TRANSMIT BUFFER\r\n\tCX = number of characters in buffer\r\n\n\tDX = port number (0-3)\r\n\n\tES:DI -> buffer containing characters\r\n\nReturn: AH = line status (see #00304)\r\n\n\tAL = modem status (see #00305)\r\n\n\tCX = number of bytes actually sent\r\n\n\tES:DI -> next byte to be transferred (unchanged if all bytes sent)\r\n",
      "6F03": " HP Vectra EX-BIOS - \"F14_GET_BUFFER\" - READ DATA INTO BUFFER\r\n\tCX = size of buffer\r\n\n\tDX = port number (0-3)\r\n\n\tES:DI -> buffer for received characters\r\n\nReturn: AH = line status (see #00304)\r\n\n\t---on error (AH bit 7 set)---\r\n\n\t   AL = 00h\r\n\n\t   ES:DI -> next byte to be transferred\r\n\n\t---if successful---\r\n\n\t   AL = last byte read\r\n\n\t   ES:DI unchanged\r\n\n\tCX = number of bytes read\r\n",
      "6F04": " HP Vectra EX-BIOS - \"F14_TRM_BUFFER\" - READ UNTIL TERMINATOR\r\n\tBL = lowest termination character\r\n\n\tBH = highest termination character\r\n\n\tCX = size of buffer\r\n\n\tDX = port number (0-3)\r\n\n\tES:DI -> buffer for received characters\r\n\nReturn: AH = line status (see #00304)\r\n\n\t---on error (AH bit 7 set)---\r\n\n\t   AL = 00h\r\n\n\t   ES:DI -> next byte to be transferred\r\n\n\t---if successful---\r\n\n\t   AL = last byte read\r\n\n\t   ES:DI unchanged\r\n\n\tCX = number of bytes read\r\n",
      "8000": " COMM-DRV v14.0 - READ PORT METRICS - GET ERROR CODE AND BUFFER STATUS\r\n\tDX = port number\r\n\nReturn: AX = code for last error (see #00357)\r\n\n\tBX = number of characters in output buffer\r\n\n\tCX = nubmer of characters in input buffer\r\n\n\tDX = state flag (see #00358)\r\n",
      "8001": " COMM-DRV v14.0 - READ PORT METRICS - GET PORT PARAMETERS\r\n\tDX = port number\r\n\nReturn: BX:DI -> Port Control Block (see #00367)\r\n",
      "8002": " COMM-DRV v14.0 - READ PORT METRICS - GET PORT PARAMETERS\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n\n\t    BX:DI -> Port Control Block (see #00367) (modifyable portion only)\r\n",
      "8003": " COMM-DRV v14.0 - READ PORT METRICS - GET I/O BUFFER SIZES\r\n\tDX = port number\r\n\nReturn: AX = number of characters in input buffer\r\n\n\tBX = input buffer size\r\n\n\tCX = number of characters in output buffer\r\n\n\tDX = output buffer size\r\n",
      "8004": " ARTICOM - ATTACH ASYNCHRONOUS RESOURCE\r\n\tDX = port to redirect (COM1=0, COM2=1, ...)\r\n\n\tCH = attach type\r\n\n\tCL = adapter to use for attach, 0FFh to search all\r\n\n\tES:DI -> attachment structure (see #00361)\r\n\nReturn: AX = error code, if error (see #00360)\r\n",
      "8005": " ARTICOM - DETACH ASYNCHRONOUS RESOURCE\r\n\tDX = port to detach (COM1=0, COM2=1, ...)\r\n\nReturn: AX = error code, if error (see #00360)\r\n",
      "8006": " ARTICOM - GET RESOURCE INFORMATION\r\n\tBX = remote port (COM1=0, COM2=1, ...)\r\n\n\tCL = adapter number, FFh to try all adapters\r\n\n\tES:DI -> resource information structure (see #00362)\r\n\n\tDS:SI -> 16 byte server name. See note.\r\n\nReturn: AX = error code, if error (see #00360)\r\n\n\tBX = next remote port, recall to get next resource info\r\n",
      "8007": " ARTICOM - GET REDIRECTED PORT INFORMATION\r\n\tDX = port index (COM1=0, COM2=1, ...)\r\n\n\tES:DI -> buffer for port information structure (see #00363)\r\n\nReturn: CF clear if redirection info returned and port is redirected\r\n\n\tCF set if not a redirected port\r\n\n\tAX = error code, if error (see #00360)\r\n",
      "8008": " ARTICOM - GET AVAILABLE SERVER NAME\r\n\tBX = server index (0,1,...)\r\n\n\tES:DI -> server name structure (see #00365)\r\n\nReturn: AX = error code, if error (see #00360)\r\n\n\tBX = next remote port, repeat call to get next available server\r\n",
      "8009": " ARTICOM - SET SEND AND RECEIVE TIMEOUTS\r\n\tBX = send timeout in ticks\r\n\n\tCX = receive timeout in ticks\r\n\n\tDX = port index (COM1=0, COM2=1, ...)\r\n\nReturn: nothing\r\n",
      "800A": " ARTICOM - MODIFY FLOW CONTROL\r\n\tBL = flow control type (00h none, 01h XON/XOFF, 02h RTS/CTS)\r\n\n\tDX = port index (COM1=0, COM2=1, ...)\r\n\nReturn: AX = error code, if error (see #00360)\r\n",
      "8025": " ARTICOM - SET INTERNAL SEND/RECEIVE VECTOR\r\n\tDS:DX -> address of trap function (see #00366) to call on read/write\r\n\nReturn: nothing\r\n",
      "8035": " ARTICOM - GET INTERNAL SEND/RECEIVE VECTOR\r\nReturn: ES:BX -> address of current send/receive routine\r\n",
      "8100": " VIDEO FOSSIL - RETURN VFOSSIL INFORMATION\r\n\tES:DI -> buffer for VFOSSIL information (see #00368)\r\n\nReturn: AX = 1954h if installed\r\n",
      "8101": " VIDEO FOSSIL - OPEN VFOSSIL\r\n\tES:DI -> buffer for application function table (see #00369)\r\n\n\tCX = length of buffer in bytes\r\n\nReturn: AX = 1954h if installed\r\n\n\t    BH = highest VFOSSIL application function supported\r\n",
      "8102": " VIDEO FOSSIL - CLOSE VFOSSIL\r\nReturn: AX = 1954h\r\n",
      "8103": " VIDEO FOSSIL - UNINSTALL\r\nReturn: AX = 1954h\r\n",
      "AA01": " DimVGA v2.0+ - INSTALLATION CHECK\r\nReturn: AX = FFFFh if installed, unchanged\r\n\n\tBX = version (v1.5+ only), BH = major, BL = minor (v1.5 = 0105h)\r\n\n\tCX = resident segment (v3.1+)\r\n",
      "AA02": " DimVGA v2.0+ - SET TIME-OUT (DIMMING/BLANKING) PERIOD\r\n\tBX = number of clock ticks\r\n\nReturn: AX = FFFFh\r\n",
      "AA03": " DimVGA v2.0+ - SET DIMMING FACTOR\r\n\tBX = percentage remaining visible (1-99)\r\n\nReturn: AX = FFFFh\r\n",
      "AA04": " DimVGA v2.0+ - GET TIME-OUT PERIOD\r\nReturn: AX = FFFFh\r\n\n\tBX = current time-out in clock ticks\r\n",
      "AA05": " DimVGA v2.0+ - GET DIMMING FACTOR\r\nReturn: AX = FFFFh\r\n\n\tBX = current dimming factor\r\n",
      "AA06": " DimVGA v2.0+ - DISABLE\r\nReturn: AX = FFFFh\r\n",
      "AA07": " DimVGA v2.0+ - ENABLE\r\nReturn: AX = FFFFh\r\n",
      "AA08": " DimVGA v2.0+ - DIM SCREEN 'MANUALLY'\r\nReturn: AX = FFFFh\r\n",
      "AA09": " DimVGA v2.0+ - UNDIM SCREEN 'MANUALLY'\r\nReturn: AX = FFFFh\r\n",
      "AA0A": " DimVGA v2.0+ - CHECK WHETHER ENABLED\r\nReturn: AX = FFFFh\r\n\n\tBX = current state (0000h disabled, 0001h enabled)\r\n",
      "AA0B": " DimVGA v2.1+ - SET HOTKEY\r\n\tBH = shift state (see #00396)\r\n\n\tBL = keyboard scancode\r\n\nReturn: AX = FFFFh\r\n",
      "AA0C": " DimVGA v2.1+ - GET HOTKEY\r\nReturn: AX = FFFFh\r\n\n\tBH = shift state (see #00396)\r\n\n\tBL = keyboard scancode\r\n",
      "AA0D": " DimVGA v3.0+ - SET MOUSE CHECK STATUS\r\n\tBX = new mouse check status\r\n\n\t    0000h mouse checking off\r\n\n\t    0001h mouse checking on\r\n\nReturn: AX = FFFFh\r\n",
      "AA0E": " DimVGA v3.0+ - GET MOUSE CHECK STATUS\r\nReturn: BX = mouse check status (0000h disabled, 0001h enabled)\r\n",
      "AA0F": " DimVGA v3.4 - SET LOCKING STATUS\r\n\tBX = locking status\r\n\n\t    0000h disabled\r\n\n\t    0001h enabled\r\n\nReturn: AX = FFFFh\r\n",
      "AA10": " DimVGA v3.4 - GET MOUSE CHECK STATUS\r\nReturn: BX = locking status (0000h disabled, 0001h enabled)\r\n",
      "AF00": " 3com BAPI SERIAL I/O - INSTALLATION CHECK\r\n\tBX = AAAAh\r\n\nReturn: AX = AF01h if installed\r\n\n\t    BH = protocol type (if BX=AAAAh on entry)\r\n\n\t\t01h NetManage TCP/IP\r\n\n\t    BL = version for protocol type (if BX=AAAAh on entry)\r\n",
      "E000": " MX5 Extended FOSSIL - GET MNP STATUS BLOCK\r\n\tDX = port number (0-3)\r\n\nReturn: ES:BX -> status block (see #00398)\r\n",
      "E001": " MX5 Extended FOSSIL - GET/SET MNP LEVEL\r\n\tBH = function\r\n\n\t    00h get MNP level\r\n\n\t    01h set MNP level\r\n\n\t\tBL = new level (00h none, 02h/04h/05h MNP level N)\r\n\n\tDX = port number (0-3)\r\n\nReturn: BL = MNP level\r\n",
      "E002": " MX5 Extended FOSSIL - GET/SET MNP ANSWER/ORIGINATE MODE\r\n\tBH = function\r\n\n\t    00h get answer/originate mode\r\n\n\t    01h set mode\r\n\n\t\tBL = new mode (00h originate [default], 01h answer)\r\n\n\tDX = port number (0-3)\r\n\nReturn: BL = answer/originate mode\r\n",
      "E003": " MX5 Extended FOSSIL - GET/SET MNP WAIT TICKS\r\n\tBH = function\r\n\n\t    00h get wait ticks\r\n\n\t    01h set wait ticks\r\n\n\t\tBL = MNP wait ticks (default 0Eh)\r\n\n\tDX = port number (0-3)\r\n\nReturn: BL = wait ticks\r\n",
      "E004": " MX5 Extended FOSSIL - GET/SET MNP CONNECT SOUND LEVEL\r\n\tBH = function\r\n\n\t    00h get sound level\r\n\n\t    01h set sound level\r\n\n\t\tBL = new sound level (00h off, 01h on [default])\r\n\n\tDX = port number\r\n\nReturn: BL = sound state\r\n",
      "E005": " MX5 Extended FOSSIL - UNINSTALL\r\nReturn: BX = segment of MX5's memory block or 0000h on failure\r\n",
      "E006": " MX5 Extended FOSSIL - INSTALLATION CHECK\r\n\tBX = 0000h\r\n\nReturn: BX = 4D58h ('MX') if installed\r\n\n\t    AH = major version\r\n\n\t    AL = minor version\r\n",
      "E007": " MX5 Extended FOSSIL - WAIT SPECIFIED NUMBER OF TICKS\r\n\tCX = number of ticks to wait\r\n\nReturn: nothing\r\n",
      "F4FF": " IBM/Yale EBIOS SERIAL I/O - INSTALLATION CHECK\r\n\tDX = port (00h-03h)\r\n\nReturn: CF clear if present\r\n\n\t    AX = 0000h\r\n\n\tCF set if not present\r\n\n\t    AX <> 0000h\r\n",
      "FD02": " IBM/Yale EBIOS SERIAL I/O - READ STATUS\r\nReturn: CX = number of characters available\r\n",
      "FF01": " IBM/Yale EBIOS SERIAL I/O - SET SEND BUFFER\r\n\tCX = length of buffer (0000h to cancel buffer assignment)\r\n\n\tDX = port (00h-03h)\r\n\n\tES:BX -> send buffer\r\n\nReturn: nothing\r\n",
      "FF02": " IBM/Yale EBIOS SERIAL I/O - SET RECEIVE BUFFER\r\n\tCX = length of buffer (0000h to cancel buffer assignment)\r\n\n\tDX = port (00h-03h)\r\n\n\tES:BX -> receive buffer\r\n\nReturn: nothing\r\n",
      "FFF8": " COMM-DRV v14.0 - SET BAUD RATE DIVISOR\r\n\tBX = card type (sub-device number)\r\n\n\tCX = new baudrate divisor\r\n\n\tDX = index to baud rate\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "FFFB": " COMM-DRV v14.0 - GET HIGHEST ALLOWED PORT NUMBER\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n\n\t    BX = highest port number\r\n",
      "FFFC": " COMM-DRV v14.0 - GET INT 14 FLAGS\r\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n\n\t    BX = flags (see #00403)\r\n",
      "FFFD": " COMM-DRV v14.0 - SET INT 14 FLAGS\r\n\tBX = flags (see #00403)\r\n\n\tDX = port number\r\n\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "FFFE": " COMM-DRV v14.0 - RESTORE INT 14 VECTOR TO ORIGINAL\r\nReturn: AH bit 7 set on error\r\n\n\tAH bit 7 clear if successful\r\n",
      "FFFF": " COMM-DRV v14.0 - GET INT 14 INFORMATION AREA\r\n\tBX:SI -> DWORD buffer for address of information area (see #00404)\r\n\n\t\t  (initialized to zeros)\r\n\nReturn: BX:SI buffer filled with nonzero value if installed\r\n"
    }
  },
  "15": {
    "AH": {
      "00": " MultiDOS Plus - GIVE UP TIME SLICE\r\nReturn: nothing\r\n",
      "01": " MultiDOS Plus - REQUEST RESOURCE SEMAPHORE\r\n\tAL = semaphore number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    02h invalid semaphore number\r\n",
      "02": " MultiDOS Plus - RELEASE RESOURCE SEMAPHORE\r\n\tAL = semaphore number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h not semaphore owner\r\n\n\t    02h invalid semaphore number\r\n",
      "03": " MultiDOS Plus - SUSPEND TASK FOR INTERVAL\r\n\tDX = number of time slices to remain suspended\r\n\nReturn: after specified interval has elapsed\r\n",
      "04": " MultiDOS Plus - SEND MESSAGE TO ANOTHER TASK\r\n\tAL = mailbox number (00h-3Fh)\r\n\n\tCX = message length in bytes\r\n\n\tDS:SI -> message\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h out of message memory\r\n\n\t    02h invalid mailbox number\r\n",
      "05": " MultiDOS Plus - CHECK MAILBOX\r\n\tAL = mailbox number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t\tDX = length of first message in queue, 0000h if no message\r\n\n\t    02h invalid mailbox number\r\n",
      "06": " MultiDOS Plus - READ MAILBOX\r\n\tAL = mailbox number (00h-3Fh)\r\n\n\tCX = size of buffer in bytes\r\n\n\tES:DI -> buffer for message\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t\tCX = number of bytes copied\r\n\n\t\tDX = actual length of message\r\n\n\t    02h invalid mailbox number\r\n",
      "07": " MultiDOS Plus - SPAWN INTERNAL TASK (CREATE NEW THREAD)\r\n\tBX:CX = entry point of new task\r\n\n\tDX = stack size in paragraphs\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h no free task control blocks\r\n\n\t    02h no free memory for task's stack\r\n",
      "08": " MultiDOS Plus - TERMINATE INTERNAL TASK (KILL THREAD)\r\nReturn: calling task terminated, so execution never returns to caller\r\n",
      "09": " MultiDOS Plus - CHANGE TASK'S PRIORITY\r\n\tAL = new priority\r\n\nReturn: nothing\r\n",
      "0A": " MultiDOS Plus - CHANGE TIME SLICE INTERVAL\r\n\tAL = new interval\r\n\n\t    00h = 55.0 ms (default)\r\n\n\t    80h = 27.5 ms\r\n\n\t    40h = 13.75 ms\r\n\n\t    20h = 6.88 ms\r\n\n\t    10h = 3.44 ms\r\n\n\t    08h = 1.72 ms\r\n",
      "0B": " MultiDOS Plus - FORCE DISPLAY OUTPUT TO PHYSICAL SCREEN MEMORY\r\nReturn: nothing\r\n",
      "0C": " MultiDOS Plus - RESTORE OLD VIDEO DISPLAY MEMORY\r\nReturn: nothing\r\n",
      "0D": " MultiDOS Plus - DISABLE MULTITASKING\r\nReturn: nothing\r\n",
      "0E": " MultiDOS Plus - ENABLE MULTITASKING\r\nReturn: nothing\r\n",
      "0F": " MultiDOS Plus - EXECUTE A MULTIDOS PLUS COMMAND\r\n\tDS:BX -> ASCIZ command\r\n\nReturn: after command has been processed\r\n",
      "10": " MultiDOS Plus - TEST RESOURCE SEMAPHORE\r\n\tAL = semaphore number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h semaphore not in use\r\n\n\t    01h semaphore owned by another task\r\n\n\t    02h invalid semaphore number\r\n\n\t    03h semaphore owned by caller\r\n",
      "11": " MultiDOS Plus - TURN OFF AltZ TOGGLE\r\n",
      "12": " MultiDOS Plus - TURN ON AltZ TOGGLE\r\n",
      "13": " MultiDOS Plus - GET TASK CONTROL BLOCK\r\nReturn: BX:AX -> task control block (see #00456)\r\n",
      "14": " MultiDOS Plus - CHECK IF MultiDOS FOREGROUND OR BACKGROUND\r\nReturn: AX = current state\r\n\n\t    0000h MultiDOS Plus command prompt is background task\r\n\n\t    0001h command prompt is foreground task\r\n",
      "15": " MultiDOS Plus - GET SYSTEM BLOCK\r\nReturn: BX:AX -> system block (see #00457)\r\n",
      "16": " MultiDOS Plus - INITIALIZATION\r\n",
      "17": " MultiDOS Plus - MAP IRQ\r\n\tAL = IRQ to map (01h-0Fh)\r\n\n\tBX = offset of task control block (see #00456) to associate with IRQ\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    other invalid IRQ\r\n",
      "18": " MultiDOS Plus - UNMAP IRQ\r\n\tAL = IRQ to unmap (01h-0Fh)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h invalid IRQ\r\n",
      "19": " MultiDOS Plus - UNMAP ALL IRQs\r\nReturn: AX destroyed\r\n",
      "1A": " MultiDOS Plus - MAP SEMAPHORE NAME TO NUMBER\r\n\tDS:SI -> 8-byte name\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tAH = semaphore number (20h-3Fh)\r\n\n\t    04h out of string space\r\n",
      "1B": " MultiDOS Plus - REQUEST RESOURCE SEMAPHORE BY NAME\r\n\tDS:SI -> 8-byte name\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    02h invalid semaphore number\r\n\n\t    03h caller already owns semaphore\r\n\n\t    04h out of string space\r\n",
      "1C": " MultiDOS Plus - RELEASE RESOURCE SEMAPHORE BY NAME\r\n\tDS:SI -> 8-byte name\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h not semaphore owner\r\n\n\t    02h invalid semaphore number\r\n\n\t    04h out of string space\r\n",
      "1D": " MultiDOS Plus - TEST RESOURCE SEMAPHORE BY NAME\r\n\tDS:SI -> 8-byte name\r\n\nReturn: AH = status\r\n\n\t    00h semaphore not in use\r\n\n\t    01h semaphore owned by another task\r\n\n\t    02h invalid semaphore number\r\n\n\t    03h caller owns semaphore\r\n\n\t    04h out of string space\r\n",
      "1E": " VMiX v2+ - \"sys_setfont\" - SET CONSOLE GRAPHICS FONT\r\n\tSTACK: WORD new font number (00h-03h)\r\n\nReturn: AX = current font number (00h-03h)\r\n",
      "1F": " MultiDOS Plus v4.01 - GET MEMORY PARAMETERS\r\nReturn: BX = first segment of conventional memory\r\n\n\tDX = first segment of EMS swap frame into which MultiDOS will load\r\n\n\t\tprograms\r\n",
      "20": " MultiDOS Plus v4.01 - CHECK IF MULTITASKING ENABLED\r\nReturn: AX = current state\r\n\n\t    0000h multitasking enabled\r\n\n\t    other TCB of task that disabled multitasking\r\n",
      "21": " SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)\r\n\tAL = subfunction\r\n\n\t    00h read POST log\r\n\n\t    01h write POST log\r\n\n\t\tBH = device ID\r\n\n\t\tBL = error code\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\tAH = status\r\n\n\t    00h OK\r\n\n\t    01h list full\r\n\n\t    02h unsupported subfunction\r\n\n\t    80h invalid command\r\n\n\t    86h unsupported function\r\n\n\tif function 00h:\r\n\n\t   BX = number of error codes stored\r\n\n\t   ES:DI -> error log\r\n",
      "22": " SYSTEM - later PS/2s - LOCATE ROM BASIC\r\nReturn: CF set on error\r\n\n\t    AH = status (86h if function not supported)\r\n\n\tCF clear on success\r\n\n\t    AH = 00h\r\n\n\t    ES:BX -> ROM BASIC\r\n",
      "40": " SYSTEM - READ/MODIFY PROFILES (CONVERTIBLE)\r\n\tAL = subfunction\r\n\n\t    00h get system profile in CX and BX\r\n\n\t    01h set system profile from CX and BX\r\n\n\t    02h get internal modem profile in BX\r\n\n\t    03h set internal modem profile from BX\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (80h = profile execution failed)\r\n",
      "41": " SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE and some others)\r\n\tAL = condition type (see #00463)\r\n\n\tBH = condition compare or mask value\r\n\n\tBL = timeout value times 55 milliseconds\r\n\n\t    00h means no timeout\r\n\n\tDX = I/O port address if AL bit 4 set\r\n\n\tES:DI -> user byte if AL bit 4 clear\r\n\nReturn: after event or timeout occurs\r\n",
      "42": " SYSTEM - REQUEST POWER OFF (CONVERTIBLE,HP 95LX)\r\n\tAL = suspend type\r\n\n\t    00h to use system profile\r\n\n\t    01h to force suspend regardless of system profile\r\n\nReturn: nothing\r\n",
      "43": " SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)\r\nReturn: AL = status bits (see #00464)\r\n",
      "44": " SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)\r\n\tAL = new modem power state (00h power off, 01h power on)\r\n\nReturn: nothing\r\n",
      "49": " HP 100LX/200LX - SERIAL INTERFACE SELECT\r\n\tAL = serial interface\r\n\n\t    00h wired (COM1)\r\n\n\t    01h infrared\r\n",
      "4A": " HP 100LX/200LX - SERIAL INTERFACE CONTROL\r\n\tAL = control\r\n\n\t    00h deactivate\r\n\n\t    01h activate\r\n",
      "4F": " KEYBOARD - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)\r\n\tAL = hardware scan code (see #00006)\r\n\n\tCF set\r\n\nReturn: CF set to continue processing scan code\r\n\n\t   AL = possibly-altered hardware scan code (see #00006)\r\n\n\tCF clear\r\n\n\t   scan code should be ignored\r\n",
      "50": " VMIX v2.???+ - \"sys_vm_page\" - SET NEW VIRTUAL PAGE TABLE\r\n\tBX = segment of page directory table\r\n\n\tCX = page number of page table\r\n",
      "51": " VMiX v2.???+ - \"sys_vm_func\" - EXECUTE FUNCTION IN PROTECTED MODE\r\n\tSTACK:\tDWORD\tselector:offset of function\r\n\nReturn: registers as returned by function\r\n",
      "52": " VMiX v2.???+ - \"sys_vm_init\" - INITIALIZE PROTECTED-MODE ENVIRONMENT\r\n",
      "80": " OS HOOK - DEVICE OPEN (AT,XT286,PS)\r\n\tBX = device ID\r\n\n\tCX = process ID\r\n\n\tCF clear\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (see #00496)\r\n",
      "81": " OS HOOK - DEVICE CLOSE\r\n\tBX = device ID\r\n\n\tCX = process ID\r\n\n\tCF clear\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (see #00496)\r\n",
      "82": " OS HOOK - PROGRAM TERMINATION\r\n\tBX = process ID\r\n\n\tCF clear\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (see #00496)\r\n",
      "83": " BIOS - SET EVENT WAIT INTERVAL (AT,PS50+)\r\n\tAL = subfunction\r\n\n\t    00h set interval\r\n\n\t\tCX:DX = microseconds to delay\r\n\n\t\tES:BX -> byte whose high bit is to be set at end of interval\r\n\n\t    01h cancel wait interval\r\n\nReturn: CF set on error or function already busy\r\n\n\t    AH = status\r\n\n\t\t80h invalid command (PC,PCjr)\r\n\n\t\t86h function not supported (XT and later)\r\n\n\tCF clear if successful\r\n",
      "84": " BIOS - JOYSTICK SUPPORT (XT after 1982/11/8,AT,XT286,PS)\r\n\tDX = subfunction\r\n\n\t    0000h read joystick switches\r\n\n\t\tReturn: AL bits 7-4 = switch settings\r\n\n\t    0001h read positions of joysticks\r\n\n\t\tReturn: AX = X position of joystick A\r\n\n\t\t\tBX = Y position of joystick A\r\n\n\t\t\tCX = X position of joystick B\r\n\n\t\t\tDX = Y position of joystick B\r\n\nReturn: CF set on error\r\n\n\t    AH = status (see #00496)\r\n\n\tCF clear if successful\r\n",
      "85": " OS HOOK - SysReq KEY ACTIVITY (AT,PS)\r\n\tAL = SysReq key action (00h pressed, 01h released)\r\n\n\tCF clear\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (see #00496)\r\n",
      "86": " BIOS - WAIT (AT,PS)\r\n\tCX:DX = interval in microseconds\r\n\nReturn: CF clear if successful (wait interval elapsed)\r\n\n\tCF set on error or AH=83h wait already in progress\r\n\n\t    AH = status (see #00496)\r\n",
      "87": " SYSTEM - COPY EXTENDED MEMORY\r\n\tCX = number of words to copy (max 8000h)\r\n\n\tES:SI -> global descriptor table (see #00499)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00498)\r\n",
      "88": " SYSTEM - GET EXTENDED MEMORY SIZE (286+)\r\nReturn: CF clear if successful\r\n\n\t    AX = number of contiguous KB starting at absolute address 100000h\r\n\n\tCF set on error\r\n\n\t    AH = status\r\n\n\t\t80h invalid command (PC,PCjr)\r\n\n\t\t86h unsupported function (XT,PS30)\r\n",
      "89": " SYSTEM - SWITCH TO PROTECTED MODE\r\n\tBL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)\r\n\n\tBH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)\r\n\n\tES:SI -> GDT for protected mode (see #00500)\r\n\nReturn: CF set on error\r\n\n\t   AH = FFh  error enabling address line 20\r\n\n\tCF clear if successful\r\n\n\t   AH = 00h\r\n\n\t   in protected mode at specified address\r\n\n\t   BP may be destroyed; all segment registers change\r\n",
      "90": " OS HOOK - DEVICE BUSY (AT,PS)\r\n\tAL = device type (see #00507)\r\n\n\tES:BX -> request block for type codes 80h through BFh\r\n\n\tCF clear\r\n\nReturn: CF set if wait time satisfied\r\n\n\tCF clear if driver must perform wait\r\n\n\t    AH = 00h\r\n",
      "91": " OS HOOK - DEVICE POST (AT,PS)\r\n\tAL = device type (see #00507)\r\n\n\tES:BX -> request block for type codes 80h through BFh\r\n\n\tCF clear\r\n\nReturn: AH = 00h\r\n",
      "92": " IBM SurePath BIOS - Officially \"Private\" Function\r\n",
      "A0": " IBM SurePath BIOS - ACCESS LOADABLE-ABIOS SIGNATURE\r\n\tAL = function\r\n\n\t    00h get loadable-ABIOS signature\r\n\n\t\tReturn: BL = signature value\r\n\n\t\t\t    00h loadable-ABIOS prompting not required\r\n\n\t\t\t    A1h loadable-ABIOS prompting is required\r\n\n\t    01h write loadable-ABIOS signature\r\n\n\t\tBL = new signature value\r\n\n\t\t    00h loadable-ABIOS prompting not required\r\n\n\t\t    A1h loadable-ABIOS prompting is required\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t    01h invalid subfunction\r\n\n\t    02h unable to read/write signature\r\n\n\t    86h function not supported\r\n",
      "AB": " IBM SurePath BIOS - Officially \"Private\" Function\r\n",
      "C0": " SYSTEM - GET CONFIGURATION (XT >1986/1/10,AT mdl 3x9,CONV,XT286,PS)\r\nReturn: CF set if BIOS doesn't support call\r\n\n\tCF clear on success\r\n\n\t    ES:BX -> ROM table (see #00509)\r\n\n\tAH = status\r\n\n\t    00h successful\r\n\n\t\tThe PC XT (since 1986/01/10), PC AT (since 1985/06/10), the\r\n\n\t\t  PC XT Model 286, the PC Convertible and most PS/2 machines\r\n\n\t\t  will clear the CF flag and return the table in ES:BX.\r\n\n\t    80h unsupported function\r\n\n\t\tThe PC and PCjr return AH=80h/CF set\r\n\n\t    86h unsupported function\r\n\n\t\tThe PC XT (1982/11/08), PC Portable, PC AT (1984/01/10),\r\n\n\t\tor PS/2 prior to Model 30 return AH=86h/CF set\r\n",
      "C1": " SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)\r\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\t    ES = segment of data area (see #M0001,#M0004,#M0005)\r\n",
      "C2": " IBM SurePath BIOS - Officially \"Private\" Function\r\n\tAL = 10h-23h\r\n",
      "C3": " SYSTEM - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)\r\n\tAL = function\r\n\n\t    00h disable PS/2 watchdog timer\r\n\n\t    01h enable PS/2 watchdog timer\r\n\n\t\tBX = timer counter (0001h-00FFh)\r\n\n\t    02h disable Gearbox system\r\n\n\t    03h enable Gearbox system\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n",
      "C4": " SYSTEM - PROGRAMMABLE OPTION SELECT (PS50+)\r\n\tAL = subfunction\r\n\n\t    00h return base POS register address\r\n\n\t    01h enable selected slot for setup\r\n\n\t\tBL = slot number (1 to 8)\r\n\n\t    02h disable setup for all slots (enable adapter)\r\n\nReturn: CF set on error\r\n\n\tDX = base POS register address (if subfunction 00h)\r\n",
      "C5": " OS HOOK - ROM BIOS TRACING CALLOUT (PS30/286,PS50Z,PS95)\r\n\tAL = interrupt being invoked\r\n\n\t    01h INT 19\r\n\n\t    02h INT 14\r\n\n\t    03h INT 16\r\n\n\t    04h INT 40 (floppy INT 13)\r\n\n\t    05h INT 17\r\n\n\t    06h INT 10\r\n\n\t    07h INT 12\r\n\n\t    08h INT 11\r\n\n\t    09h INT 1A\r\n\nReturn: all registers except AX must be preserved\r\n",
      "C6": " later PS/2 models - GET POS DATA\r\n\t???\r\n\nReturn: ???\r\n",
      "C7": " SYSTEM - later PS/2s - RETURN MEMORY-MAP INFORMATION\r\n\tDS:SI -> user supplied memory map table (see #00526)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n",
      "C8": " SYSTEM - ENABLE/DISABLE PROCESSOR FUNCTIONS\r\n\tAL = function\r\n\n\t    00h disable L1 cache\r\n\n\t    01h enable L1 cache\r\n\n\t    ---models 90 and 95 only---\r\n\n\t    02h disable L2 cache\r\n\n\t    03h enable L2 cache\r\n\n\t    04h disable both caches\r\n\n\t    05h enable both caches\r\n\n\t    06h return status of both caches\r\n\n\t    07h-FFh Reserved\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00527)\r\n\n\tFor subfunction 06h only:\r\n\n\t    BL = status of L1 cache\r\n\n\t\t00h enabled\r\n\n\t\t01h disabled or not installed\r\n\n\t\t02h disabled due to test error (can not be enabled)\r\n\n\t    BH = status of L2 cache (same codes as BL)\r\n",
      "C9": " newer PS/2; various BIOSes - GET CPU TYPE AND MASK REVISION\r\n\tAL = 10h (may be required on some non-PS BIOSes)\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\t    CH = CPU type (see #00528)\r\n\n\t    CL = mask revision (stepping level) (see #00529)\r\n\n\tCF set on error\r\n\n\t    AH = status (80h,86h = function not supported)\r\n",
      "CA": " PS/2 Model 95 - READ/WRITE CMOS MEMORY\r\n\tAL = function\r\n\n\t    00h read CMOS\r\n\n\t\tReturn: CL = value of CMOS location\r\n\n\t    01h write CMOS\r\n\n\t\tCL = new value for CMOS location\r\n\n\tBL = CMOS location (0Eh-3Fh)\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = error code (see #00530)\r\n",
      "CB": " PS/2 Model 95 - RESERVED\r\n\t???\r\n\nReturn: ???\r\n",
      "CC": " PS/2 Model 95 - RESERVED\r\n\t???\r\n\nReturn: ???\r\n",
      "CD": " PS/2 Model 95 - RESERVED\r\n\t???\r\n\nReturn: ???\r\n",
      "CE": " later PS/2s - ALLOCATE DMA ARBITRATION LEVEL\r\n\tBL = 00h-0Eh arbitration level to be allocated\r\n\n\t     0Fh-FFh reserved\r\n\n\tAL = option byte\r\n\n\t    bit 7-1: reserved (0)\r\n\n\t    bit 0: 0 = need DMA channel for arbitration level requested\r\n\n\t\t   1 = no channel required for arbitration level\r\n\nReturn: CF set on error\r\n\n\t    AH = status (80h,86h = function not supported)\r\n\n\tCF clear on success\r\n\n\t    AL = channel number\r\n\n\t\t00h-07h channel number allocated for the arbiration level\r\n\n\t\t08h-FEh reserved\r\n\n\t\tFFh\tno channel requested for arbitration level\r\n\n\t    AH = status (see #00531)\r\n",
      "CF": " later PS/2s - DEALLOCATE DMA ARBITRATION LEVEL\r\n\tBL = arbitration level to be deallocated (see AH=CEh)\r\n\nReturn: CF set on error\r\n\n\t    AH = status (80h,86h = function not supported)\r\n\n\tCF clear on success\r\n\n\t    AH = status\r\n\n\t\t00h success\r\n\n\t\t04h arbitration level not allocated\r\n",
      "D0": " later PS/2s - RESERVED\r\n\t???\r\n\nReturn: ???\r\n",
      "D2": " later PS/2s - RESERVED\r\n\t???\r\n\nReturn: ???\r\n",
      "D3": " later PS/2s - RESERVED\r\n\t???\r\n\nReturn: ???\r\n",
      "D4": " later PS/2s - GET PHYSICAL FIXED DISK DRIVE NUMBER (SELECTABLE BOOT)\r\n\tDL = logical fixed disk drive number\r\n\nReturn: AH = return code (see #00537)\r\n\n\tCF set on error\r\n\n\tCF clear on success\r\n\n\t    AL = physical fixed disk drive number\r\n",
      "D5": " later PS/2s - RESERVED\r\n\t???\r\n\nReturn: ???\r\n"
    },
    "AX": {
      "1E00": " MultiDOS Plus - CLEAR EVENT COUNTER\r\n\tDX = event/trigger number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n",
      "1E01": " MultiDOS Plus - TRIGGER EVENT\r\n\tDX = event/trigger number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h invalid event/trigger number\r\n",
      "1E02": " MultiDOS Plus - WAIT FOR EVENT\r\n\tDX = event/trigger number (00h-3Fh)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    01h invalid event/trigger number\r\n",
      "1E08": " MultiDOS Plus 4.01 - SET CONTEXT-SWITCH FUNCTIONS\r\n\tDX:BX -> context save handler (see #00458)\r\n\n\tDX:CX -> context restore handler (see #00458)\r\n\nReturn: nothing\r\n",
      "2300": " IBM BIOS - SMART ENERGY SYSTEM - GET ??? CMOS DATA\r\nReturn: CF clear if successful\r\n\n\t    CL = value of CMOS location 2Dh\r\n\n\t    CH = value of CMOS location 2Eh\r\n\n\tCF set on error\r\n\n\t    AH = error code (80h,86h)\r\n",
      "2301": " IBM BIOS - SMART ENERGY SYSTEM - SET ??? CMOS DATA\r\n\tCL = new value for CMOS location 2Dh\r\n\n\tCH = new value for CMOS location 2Eh\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AH = error code (80h,86h)\r\n",
      "2302": " IBM BIOS - SMART ENERGY SYSTEM - GET ROM STARTUP VIDEO REG TABLES\r\n\tBL = data index (00h-0Dh) (see #00459)\r\n\nReturn: ES:BX -> table for register (see #00460,#00461)\r\n\n\tCX = size of table in bytes (may be 0000h)\r\n",
      "2303": " IBM BIOS - SMART ENERGY SYSTEM - ???\r\n\tBX = ??? ('x')\r\n\n\tDX = 'y' and 'z'\r\n\n\t\tbits 15-7 = 'y'\r\n\n\t\tbits 6-3 unused\r\n\n\t\tbits 2-0 = 'z'\r\n\n\tDI = ??? (0352h)\r\n\nReturn: ???\r\n",
      "2304": " IBM BIOS - SMART ENERGY SYSTEM - SYSTEM SETUP\r\n\tDX = segment of 32K buffer\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 0003h (left over from setting video mode 3)\r\n\n\t    BX,CX,DX,BP,DS,ES destroyed\r\n\n\tCF set on error\r\n\n\t    AH = error code (80h,86h)\r\n",
      "2305": " IBM BIOS - SMART ENERGY SYSTEM - GET PROCESSOR SPEED\r\nReturn: CF clear if successful\r\n\n\t    AL = processor speed in MHz\r\n\n\tCF set on error\r\n\n\t    AL = FFh (speed unknown or >80 MHz)\r\n\n\t    AL = error code (80h,86h = unsupported function)\r\n",
      "3000": " Object Kernel for DOS - INSTALLATION CHECK\r\nReturn: AX:BX = 4F42h:4A21h ('OBJ!') if installed\r\n\n\t    CX = resident segment\r\n",
      "3001": " Object Kernel for DOS - GET STATUS BLOCK\r\nReturn: AX = FFFFh\r\n\n\tES:DI -> status block\r\n",
      "3002": " Object Kernel for DOS - KILL PROCESS\r\n\t(not yet implemented)\r\n",
      "3003": " Object Kernel for DOS - STOP PROCESS\r\n\t(not yet implemented)\r\n",
      "3004": " Object Kernel for DOS - START PROCESS\r\n\t(not yet implemented)\r\n",
      "3005": " Object Kernel for DOS - RESTART PROCESS\r\n\t(not yet implemented)\r\n",
      "3006": " Object Kernel for DOS - EXECUTE PROCESS\r\n\t(not yet implemented)\r\n",
      "3007": " Object Kernel for DOS - LIST PROCESSES\r\n\t(not yet implemented)\r\n",
      "3008": " Object Kernel for DOS - SWITCH ObjectKernel ON/OFF\r\n\tBH = new state (00h disabled, 01h enabled)\r\n\nReturn: AX = FFFFh\r\n",
      "4000": " Compaq SLT/286 or Portable 386 - READ LCD/PLASMA TIMEOUT\r\nReturn: AX = 4000h\r\n\n\tCL = timeout in minutes, 00h if disabled\r\n",
      "4001": " Compaq SLT/286 or Portable 386 - SET LCD/PLASMA TIMEOUT\r\n\tCL = timeout in minutes, 00h to disable\r\n\nReturn: AL = status\r\n\n\t    00h timeout modified\r\n\n\t    01h timeout cannot be modified\r\n\n\t    40h timeout cannot be modified\r\n\n\tCL = timeout in minutes, 00h if disabled\r\n",
      "44F1": " Toshiba laptops - SECURITY LEVEL CHECK\r\n\tDS:DX -> byte with 00h ???\r\n\nReturn: ???\r\n",
      "44F2": " Toshiba laptops - SECURITY LEVEL CHECK\r\n\tBX = 0604h ???\r\n\nReturn: CF = ???\r\n\n\tAH = ???\r\n\n\tDX = ???\r\n",
      "44F3": " Toshiba laptops - SECURITY LEVEL CHECK\r\n\tDS:DX -> byte with 00h or 01h ???\r\n\nReturn: DS:DX -> changed ???\r\n",
      "5101": " SYSTEM - later PS/2s - EXPANSION UNIT, RETURN CONFIGURATION NUMBER\r\nReturn: CF set if successful\r\n\n\t    AH = 00h\r\n\n\t    AL = current configuration number\r\n\n\t\t00h system unit only\r\n\n\t\tFFh configuration not recognized\r\n\n\t    BX = status flag\r\n\n\t\tbits 0-14: reserved\r\n\n\t\tbit 15: additional data is available (location TBD)\r\n\n\tCF clear on error\r\n\n\t    AH = status\r\n\n\t\t01h expansion unit is not present\r\n\n\t\t86h function not supported\r\n",
      "5400": " Omniview Multitasker - INSTALLATION NOTIFICATION\r\n\tES:BX -> device information tables\r\n\n\tDI:DX -> dispatcher entry point\r\n",
      "5401": " Omniview Multitasker - PROCESS CREATION\r\n\tES:BX = process handle\r\n",
      "5402": " Omniview Multitasker - PROCESS DESTRUCTION\r\n\tES:DX = process handle\r\n",
      "5403": " Omniview Multitasker - SAVE\r\n\tES:DX = process swapping out\r\n",
      "5404": " Omniview Multitasker - RESTORE\r\n\tES:DX = process swapping in\r\n",
      "5405": " Omniview Multitasker - SWITCHING TO BACKGROUND\r\n\tES:DX = process swapping in\r\n",
      "5406": " Omniview Multitasker - SWITCHING TO FOREGROUND\r\n\tES:DX = process swapping in\r\n",
      "5407": " Omniview Multitasker - EXIT NOTIFICATION\r\n",
      "5F31": " Chips & Technologies '65530' BIOS - POST INITIALIZATION NOTIFICATION\r\nReturn:\tnothing\r\n",
      "5F33": " Chips & Technologies '65530' BIOS - MODE SET HOOK\r\n\tBL = current width in characters\r\n\n\tBH = curent video mode\r\n\n\tCH = active display page\r\n\nReturn:\tnothing\r\n",
      "5F35": " Chips & Technologies '65530' BIOS - MONITOR SENSING HOOK\r\nReturn:\tDL = boot display\r\n\n\t    00h CRT\r\n\n\t    01h flat panel (LCD)\r\n\n\t    02h both simultaneously\r\n\n\t    leave unchanged to boot according to BIOS settings\r\n",
      "BF00": " Rational Systems DOS/16M - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "BF01": " Rational Systems DOS/16M - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "BF02": " Rational Systems DOS/16M - INSTALLATION CHECK\r\n\tDX = 0000h\r\n\nReturn: DX = nonzero if installed\r\n\n\t    DX:SI -> XBRK structure (see #00508)\r\n",
      "BF03": " Rational Systems DOS/4GW - UNINSTALL???\r\n\tBX = PSP segment of extender\r\n\n\t???\r\n\nReturn: ???\r\n",
      "BF04": " Rational Systems DOS/4GW - ???\r\n\tBX = PSP segment of extender\r\n\nReturn: nothing???\r\n",
      "BF05": " Rational Systems DOS/4GW - INITIALIZE PROTECTED-MODE INTERFACE\r\n\tBX = PSP segment of extender\r\n\nReturn: nothing???\r\n",
      "BF06": " Rational Systems DOS/4GW - ???\r\n\tBX = PSP segment of extender\r\n\n\t???\r\n\nReturn: ???\r\n",
      "BFDC": " Rational Systems DOS/4GW - INSTALLATION CHECK\r\n\tDX = 0000h\r\n\n\tSI = 0000h\r\n\nReturn: DX = nonzero if installed\r\n\n\t    DX:SI -> XBRK structure (see #00508)\r\n",
      "BFDE": " DESQview/X 1.02+ - DVDOS4GX.DVR - NOP\r\n\tBX = FFFFh\r\n",
      "C200": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - ENABLE/DISABLE\r\n\tBH = new state\r\n\n\t    00h disabled\r\n\n\t    01h enabled\r\n\nReturn: CF set on error\r\n\n\tAH = status (see #00522)\r\n",
      "C201": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - RESET\r\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n\n\tCF clear if successful\r\n\n\t    BH = device ID\r\n\n\t    BL = value returned by attached device after reset\r\n\n\t\tAAh if device is a mouse\r\n",
      "C202": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET SAMPLING RATE\r\n\tBH = sampling rate\r\n\n\t    00h 10/second\r\n\n\t    01h 20/second\r\n\n\t    02h 40/second\r\n\n\t    03h 60/second\r\n\n\t    04h 80/second\r\n\n\t    05h 100/second\r\n\n\t    06h 200/second\r\n\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n",
      "C203": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET RESOLUTION\r\n\tBH = resolution (see #00523)\r\n\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n",
      "C204": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET TYPE\r\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n\n\tCF clear if successful\r\n\n\t    BH = device ID\r\n",
      "C205": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - INITIALIZE\r\n\tBH = data package size (1 - 8 bytes)\r\n\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n",
      "C206": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - EXTENDED COMMANDS\r\n\tBH = subfunction\r\n\n\t    00h return device status\r\n\n\t\tReturn: BL = pointing device status (see #00524)\r\n\n\t\t\tCL = resolution (see #00523)\r\n\n\t\t\tDL = sample rate, reports per second\r\n\n\t    01h set scaling at 1:1\r\n\n\t    02h set scaling at 2:1\r\n\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n",
      "C207": " SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET DEVICE HANDLER ADDR\r\n\tES:BX -> FAR user device handler or 0000h:0000h to cancel\r\n\nReturn: CF set on error\r\n\n\t    AH = status (see #00522)\r\n",
      "C208": " SYSTEM - POINTING DEVICE BIOS INTERFACE - WRITE TO POINTER PORT\r\n\tBL = byte to be sent to the pointing device\r\n",
      "C209": " SYSTEM - POINTING DEVICE BIOS INTERFACE - READ FROM POINTER PORT\r\nReturn: BL = first byte read from pointing device\r\n\n\tCL = second byte read\r\n\n\tDL = third byte read\r\n",
      "CCCC": " Toshiba laptops - VCHAD.EXE - INSTALLATION CHECK\r\nReturn: AX = ABCDh if installed\r\n",
      "D100": " later PS/2s - GET NUMBER OF DEVICE DESCRIPTOR TABLE (DDT) ENTRIES\r\n\tDX = 0000h (reserved, must set to 0)\r\n\nReturn: BL = size of one DDT entry, in bytes\r\n\n\tCX = number of DDT entries\r\n\n\tAH = return code (see #00534)\r\n\n\tCF set on error\r\n\n\tCF clear on success\r\n",
      "D101": " later PS/2s - RETURN DEVICE DESCRIPTOR TABLE (DDT) ENTRY BY NUMBER\r\n\tBX = number of requested entry (starting with 1)\r\n\n\tDX = 0000h (reserved, must be set to 0)\r\n\n\tES:DI -> buffer to contain DDT entry (see #00535)\r\n\nReturn: AH = return code (see #00534)\r\n\n\tCF set on error\r\n\n\tCF clear on success\r\n\n\t    ES:DI buffer filled with DDT entry\r\n",
      "D102": " later PS/2s - RETURN DEVICE DESCRIPTOR TABLE (DDT) ENTRY BY I/O ADDRSS\r\n\tBX = entry number at which to start searching\r\n\n\tCX = requested I/O port address\r\n\n\tDX = 0000h (reserved, must be set to 0)\r\n\n\tES:DI -> buffer to contain DDT entry (see #00535)\r\n\nReturn: AH = return code (see #00534)\r\n\n\tBX = DDT entry number where I/O port was found, or total entries\r\n\n\t     plus 1 if port was not found.\r\n\n\tCF set on error\r\n\n\tCF clear on success\r\n\n\t    ES:DI buffer filled with DDT entry\r\n",
      "D103": " later PS/2s - RETURN ENTIRE DDT\r\n\tDX = 0000h (reserved, must be set to 0)\r\n\n\tES:DI -> buffer to contain DDT entry (see #00535)\r\n\nReturn: AH = return code (see #00534)\r\n\n\tCF set on error\r\n\n\tCF clear on success\r\n\n\t    ES:DI buffer filled with DDT entry\r\n",
      "D104": " later PS/2s - RETURN DEVICE DESCRIPTOR TABLE (DDT) ENTRY BY DEVICE ID\r\n\tBX = entry number at which to start searching\r\n\n\tCX = requested device ID\r\n\n\tDX = 0000h (reserved, must be set to 0)\r\n\n\tES:DI -> buffer to contain DDT entry (see #00535)\r\n\nReturn: AH = return code (see #00534)\r\n\n\tBX = DDT entry number where device ID was found, or total entries\r\n\n\t      plus 1 if port was not found.\r\n\n\tCF set on error\r\n\n\tCF clear on success\r\n\n\t    ES:DI buffer filled with DDT entry\r\n",
      "D600": " later PS/2s - WRITE BOOT DEVICE ID\r\n\tBL = 01h\r\n\n\tDX = device ID\r\n\nReturn: CF clear on success\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (86h for function not supported)\r\n",
      "D601": " later PS/2s - WRITE BOOT DEVICE KEY\r\n\tBL = 01h\r\n\n\tDX = device ID\r\n\nReturn: CF clear on success\r\n\n\t    AH = 00h\r\n\n\tCF set on error\r\n\n\t    AH = status (86h for function not supported)\r\n",
      "D602": " later PS/2s - QUERY BOOT REFERENCE PARTITION\r\nReturn: CF clear on success\r\n\n\t    AH = 00h\r\n\n\t    AL = status of reference-partition boot request\r\n\n\t\t00h boot not requested\r\n\n\t\t01h boot requested\r\n\n\tCF set on error\r\n\n\t    AH = status (86h for function not supported)\r\n"
    }
  },
  "16": {
    "AH": {
      "00": " KEYBOARD - GET KEYSTROKE\r\nReturn: AH = BIOS scan code\r\n\n\tAL = ASCII character\r\n",
      "01": " KEYBOARD - CHECK FOR KEYSTROKE\r\nReturn: ZF set if no keystroke available\r\n\n\tZF clear if keystroke available\r\n\n\t    AH = BIOS scan code\r\n\n\t    AL = ASCII character\r\n",
      "02": " KEYBOARD - GET SHIFT FLAGS\r\nReturn: AL = shift flags (see #00582)\r\n\n\tAH destroyed by many BIOSes\r\n",
      "03": " KEYBOARD - SET TYPEMATIC RATE AND DELAY\r\n\tAL = subfunction\r\n\n\t    00h set default delay and rate (PCjr and some PS/2)\r\n\n\t    01h increase delay before repeat (PCjr)\r\n\n\t    02h decrease repeat rate by factor of 2 (PCjr)\r\n\n\t    03h increase delay and decrease repeat rate (PCjr)\r\n\n\t    04h turn off typematic repeat (PCjr and some PS/2)\r\n\n\t    05h set repeat rate and delay (AT,PS)\r\n\n\t\tBH = delay value (00h = 250ms to 03h = 1000ms)\r\n\n\t\tBL = repeat rate (00h=30/sec to 0Ch=10/sec [def] to 1Fh=2/sec)\r\n\n\t    06h get current typematic rate and delay (newer PS/2s)\r\n\n\t\tReturn: BL = repeat rate (above)\r\n\n\t\t\tBH = delay (above)\r\n\nReturn: AH destroyed by many BIOSes\r\n",
      "04": " KEYBOARD - SET KEYCLICK (PCjr only)\r\n\tAL = keyclick state\r\n\n\t    00h off\r\n\n\t    01h on\r\n\nReturn: AH destroyed by many BIOSes\r\n",
      "05": " KEYBOARD - SELECT KEYBOARD LAYOUT (PCjr only)\r\n\tAL = function\r\n\n\t    01h set keyboard layout to French\r\n\n\t    02h set keyboard layout to German\r\n\n\t    03h set keyboard layout to Italian\r\n\n\t    04h set keyboard layout to Spanish\r\n\n\t    05h set keyboard layout to UK\r\n\n\t    80h check if function supported\r\n\n\t\tReturn: AL <> 80h if supported\r\n\nReturn: ???\r\n\n\tAH destroyed by many BIOSes\r\n",
      "09": " KEYBOARD - GET KEYBOARD FUNCTIONALITY\r\nReturn: AL = supported keyboard functions (see #00585)\r\n\n\tAH destroyed by many BIOSes\r\n",
      "10": " KEYBOARD - GET ENHANCED KEYSTROKE (enhanced kbd support only)\r\nReturn: AH = BIOS scan code\r\n\n\tAL = ASCII character\r\n",
      "11": " KEYBOARD - CHECK FOR ENHANCED KEYSTROKE (enh kbd support only)\r\nReturn: ZF set if no keystroke available\r\n\n\tZF clear if keystroke available\r\n\n\t    AH = BIOS scan code\r\n\n\t    AL = ASCII character\r\n",
      "12": " KEYBOARD - GET EXTENDED SHIFT STATES (enh kbd support only)\r\nReturn: AL = shift flags 1 (same as returned by AH=02h) (see #00587)\r\n\n\tAH = shift flags 2 (see #00588)\r\n",
      "20": " KEYBOARD - GET 122-KEY KEYSTROKE (122-key kbd support only)\r\nReturn: AH = BIOS scan code (see AH=10h)\r\n\n\tAL = ASCII character\r\n",
      "21": " KEYBOARD - CHECK FOR 122-KEY KEYSTROKE (122-key kbd support only)\r\nReturn: ZF set if no keystroke available\r\n\n\tZF clear if keystroke available\r\n\n\t    AH = BIOS scan code\r\n\n\t    AL = ASCII character\r\n",
      "22": " KEYBOARD - GET 122-KEY SHIFT STATUS (122-key kbd support only)\r\nReturn: AL = shift flags 1 (see #00587)\r\n\n\tAH = shift flags 2 (see #00588)\r\n",
      "AA": " PTxxx.COM - (xxx=CGA,EGA,VGA,HER...) CALL GATE FOR GRAPHICS\r\n\tVarious registers set up by high level language.\r\n\nReturn: Graphics performed\r\n",
      "FF": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - QUERY ZOOM INTERRUPT\r\nReturn: AL = interrupt number to which BIOS keyboard handler has been relocated\r\n\n\tAL+1 = Zoom interrupt number\r\n\n\tBX = hotkey\r\n"
    },
    "AX": {
      "CA00": " CtrlAlt Associates VGAPAL.COM v1.00 - INSTALLATION CHECK\r\n\tBX = 7670h (\"vp\")\r\n\n\tCX = 7670h\r\n\nReturn: AX = CAFFh if installed\r\n\n\t    BX = segment of resident code\r\n\n\t    CX = ??? (0090h)\r\n",
      "FF80": " PC Tools v8+ CPTASK - UNINSTALL\r\n\tBX = 4350h ('CP')\r\n\n\tCX = 5354h ('ST')\r\n\nReturn: never returns; terminates all tasks and exits to program originally\r\n\n\t  calling CPTASK\r\n",
      "FF9C": " PC Tools v8+ CPTASK - SET/CLEAR ??? POINTER\r\n\tBL = function\r\n\n\t    00h set ??? pointer\r\n\n\t\tDS:SI -> ???\r\n\n\t    01h clear pointer to 0000h:0000h\r\n",
      "FFFE": " PC Tools v5.1-8.0 DESKTOP - SHOW MOUSE CURSOR\r\n",
      "FFFF": " PC Tools v5.1-8.0 DESKTOP - HIDE MOUSE CURSOR\r\n"
    }
  },
  "17": {
    "AH": {
      "00": " PRINTER - WRITE CHARACTER\r\n\tAL = character to write\r\n\n\tDX = printer number (00h-02h)\r\n\nReturn: AH = printer status (see #00631)\r\n",
      "01": " PRINTER - INITIALIZE PORT\r\n\tDX = printer number (00h-02h)\r\n\nReturn: AH = printer status (see #00631)\r\n",
      "02": " PRINTER - GET STATUS\r\n\tDX = printer number (00h-02h)\r\n\nReturn: AH = printer status (see #00631)\r\n",
      "60": " FLASHUP.COM - INSTALLATION CHECK\r\nReturn: AL = 60h\r\n\n\tDX = CS of resident code\r\n",
      "61": " SPEEDSCR.COM - INSTALLATION CHECK\r\nReturn: AL = 61h\r\n\n\tDX = CS of resident code\r\n"
    }
  },
  "18": " DISKLESS BOOT HOOK (START CASSETTE BASIC)\r\n",
  "19": " SYSTEM - BOOTSTRAP LOADER\r\n",
  "1A": {
    "AH": {
      "00": " TIME - GET SYSTEM TIME\r\nReturn: CX:DX = number of clock ticks since midnight\r\n\n\tAL = midnight flag, nonzero if midnight passed since time last read\r\n",
      "01": " TIME - SET SYSTEM TIME\r\n\tCX:DX = number of clock ticks since midnight\r\n\nReturn: nothing\r\n",
      "02": " TIME - GET REAL-TIME CLOCK TIME (AT,XT286,PS)\r\n\tCF clear to avoid bug (see below)\r\n\nReturn: CF clear if successful\r\n\n\t    CH = hour (BCD)\r\n\n\t    CL = minutes (BCD)\r\n\n\t    DH = seconds (BCD)\r\n\n\t    DL = daylight savings flag (00h standard time, 01h daylight time)\r\n\n\tCF set on error (i.e. clock not running or in middle of update)\r\n",
      "03": " TIME - SET REAL-TIME CLOCK TIME (AT,XT286,PS)\r\n\tCH = hour (BCD)\r\n\n\tCL = minutes (BCD)\r\n\n\tDH = seconds (BCD)\r\n\n\tDL = daylight savings flag (00h standard time, 01h daylight time)\r\n\nReturn: nothing\r\n",
      "04": " TIME - GET REAL-TIME CLOCK DATE (AT,XT286,PS)\r\n\tCF clear to avoid bug (see below)\r\n\nReturn: CF clear if successful\r\n\n\t    CH = century (BCD)\r\n\n\t    CL = year (BCD)\r\n\n\t    DH = month (BCD)\r\n\n\t    DL = day (BCD)\r\n\n\tCF set on error\r\n",
      "05": " TIME - SET REAL-TIME CLOCK DATE (AT,XT286,PS)\r\n\tCH = century (BCD)\r\n\n\tCL = year (BCD)\r\n\n\tDH = month (BCD)\r\n\n\tDL = day (BCD)\r\n\nReturn: nothing\r\n",
      "06": " TIME - SET ALARM (AT,XT286,PS)\r\n\tCH = hour (BCD)\r\n\n\tCL = minutes (BCD)\r\n\n\tDH = seconds (BCD)\r\n\nReturn: CF set on error (alarm already set or clock stopped for update)\r\n\n\tCF clear if successful\r\n",
      "07": " TIME - CANCEL ALARM (AT,XT286,PS)\r\nReturn: alarm disabled\r\n",
      "08": " TIME - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)\r\n\tCH = hours in BCD\r\n\n\tCL = minutes in BCD\r\n\n\tDH = seconds in BCD\r\n",
      "09": " TIME - READ RTC ALARM TIME AND STATUS (CONV,PS30)\r\nReturn: CH = hours in BCD\r\n\n\tCL = minutes in BCD\r\n\n\tDH = seconds in BCD\r\n\n\tDL = alarm status\r\n\n\t    00h alarm not enabled\r\n\n\t    01h alarm enabled but will not power up system\r\n\n\t    02h alarm will power up system\r\n",
      "0A": " TIME - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)\r\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\t    CX = count of days since Jan 1,1980\r\n",
      "0B": " TIME - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)\r\n\tCX = count of days since Jan 1,1980\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n",
      "0C": " TIME - SET RTC DATE/TIME ACTIVATED POWER-ON MODE (IBM)\r\n\tCH = hours (BCD)\r\n\n\tCL = minutes (BCD)\r\n\n\tDH = seconds (BCD)\r\n\n\tDL = day of month (BCD)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error (alarm already set or clock nonfunctional)\r\n",
      "0D": " TIME - RESET RTC DATE/TIME ACTIVATED POWER-ON MODE (IBM)\r\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "0E": " TIME - GET RTC DATE/TIME ALARM AND STATUS (IBM)\r\nReturn: CF clear if successful\r\n\n\t    BH = alarm status\r\n\n\t\t00h disabled\r\n\n\t\t01h enabled but will not power-up system\r\n\n\t\t02h enabled, system will power-up on activation\r\n\n\t    CH = alarm time, hours (BCD)\r\n\n\t    CL = alarm time, minutes (BCD)\r\n\n\t    DH = seconds (BCD)\r\n\n\t    DL = day of month (BCD)\r\n\n\tCF set on error\r\n",
      "0F": " TIME - INITIALIZE REAL-TIME CLOCK\r\n\tAL = reserved (0)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n"
    }
  },
  "1B": " KEYBOARD - CONTROL-BREAK HANDLER\r\n",
  "1C": " TIME - SYSTEM TIMER TICK\r\n",
  "1D": " SYSTEM DATA - VIDEO PARAMETER TABLES\r\n",
  "1E": " SYSTEM DATA - DISKETTE PARAMETERS\r\n",
  "1F": " SYSTEM DATA - 8x8 GRAPHICS FONT\r\n",
  "20": " DOS 1+ - TERMINATE PROGRAM\r\n\tCS = PSP segment\r\n\nReturn: never\r\n",
  "21": {
    "AH": {
      "00": " DOS 1+ - TERMINATE PROGRAM\r\n\tCS = PSP segment\r\n",
      "01": " DOS 1+ - READ CHARACTER FROM STANDARD INPUT, WITH ECHO\r\nReturn: AL = character read\r\n",
      "02": " DOS 1+ - WRITE CHARACTER TO STANDARD OUTPUT\r\n\tDL = character to write\r\n\nReturn: AL = last character output (despite the official docs which state\r\n\n\t\tnothing is returned) (at least DOS 2.1-7.0)\r\n",
      "03": " DOS 1+ - READ CHARACTER FROM STDAUX\r\nReturn: AL = character read\r\n",
      "04": " DOS 1+ - WRITE CHARACTER TO STDAUX\r\n\tDL = character to write\r\n",
      "05": " DOS 1+ - WRITE CHARACTER TO PRINTER\r\n\tDL = character to print\r\n",
      "06": " DOS 1+ - DIRECT CONSOLE INPUT\r\n\tDL = FFh\r\n\nReturn: ZF set if no character available\r\n\n\t    AL = 00h\r\n\n\tZF clear if character available\r\n\n\t    AL = character read\r\n",
      "07": " DOS 1+ - DIRECT CHARACTER INPUT, WITHOUT ECHO\r\nReturn: AL = character read from standard input\r\n",
      "08": " DOS 1+ - CHARACTER INPUT WITHOUT ECHO\r\nReturn: AL = character read from standard input\r\n",
      "09": " DOS 1+ - WRITE STRING TO STANDARD OUTPUT\r\n\tDS:DX -> '$'-terminated string\r\n\nReturn: AL = 24h (the '$' terminating the string, despite official docs which\r\n\n\t\tstate that nothing is returned) (at least DOS 2.1-7.0 and\r\n\n\t\tNWDOS)\r\n",
      "0A": " DOS 1+ - BUFFERED INPUT\r\n\tDS:DX -> buffer (see #01344)\r\n\nReturn: buffer filled with user input\r\n",
      "0B": " DOS 1+ - GET STDIN STATUS\r\nReturn: AL = status\r\n\n\t    00h if no character available\r\n\n\t    FFh if character is available\r\n",
      "0C": " DOS 1+ - FLUSH BUFFER AND READ STANDARD INPUT\r\n\tAL = STDIN input function to execute after flushing buffer\r\n\n\tother registers as appropriate for the input function\r\n\nReturn: as appropriate for the specified input function\r\n",
      "0D": " DOS 1+ - DISK RESET\r\nReturn: (DOS 6 only) CF clear (earlier versions preserve CF)\r\n",
      "0E": " DOS 1+ - SELECT DEFAULT DRIVE\r\n\tDL = new default drive (00h = A:, 01h = B:, etc)\r\n\nReturn: AL = number of potentially valid drive letters\r\n",
      "0F": " DOS 1+ - OPEN FILE USING FCB\r\n\tDS:DX -> unopened File Control Block (see #01345,#01346)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    FFh file not found or access denied\r\n",
      "10": " DOS 1+ - CLOSE FILE USING FCB\r\n\tDS:DX -> File Control Block (see #01345)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    FFh failed\r\n",
      "11": " DOS 1+ - FIND FIRST MATCHING FILE USING FCB\r\n\tDS:DX -> unopened FCB (see #01345), may contain '?' wildcards\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\t[DTA] unopened FCB for first matching file\r\n\n\t    FFh no matching filename, or bad FCB\r\n",
      "12": " DOS 1+ - FIND NEXT MATCHING FILE USING FCB\r\n\tDS:DX -> unopened FCB (see #01345)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tDisk Transfer Area filled with unopened FCB\r\n\n\t    FFh no more matching filenames\r\n",
      "13": " DOS 1+ - DELETE FILE USING FCB\r\n\tDS:DX -> unopened FCB (see #01345), filename filled with template for\r\n\n\t\tdeletion ('?' wildcards allowed)\r\n\nReturn: AL = status\r\n\n\t    00h one or more files successfully deleted\r\n\n\t    FFh no matching files or all were read-only or locked\r\n",
      "14": " DOS 1+ - SEQUENTIAL READ FROM FCB FILE\r\n\tDS:DX -> opened FCB (see #01345)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h end of file (no data)\r\n\n\t    02h segment wrap in DTA\r\n\n\t    03h end of file, partial record read\r\n\n\tDisk Tranfer Area filled with record read from file\r\n",
      "15": " DOS 1+ - SEQUENTIAL WRITE TO FCB FILE\r\n\tDS:DX -> opened FCB (see #01345)\r\n\n\tDisk Tranfer Area contains record to be written\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h disk full\r\n\n\t    02h segment wrap in DTA\r\n",
      "16": " DOS 1+ - CREATE OR TRUNCATE FILE USING FCB\r\n\tDS:DX -> unopened FCB (see #01345), wildcards not allowed\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    FFh directory full or file exists and is read-only or locked\r\n",
      "17": " DOS 1+ - RENAME FILE USING FCB\r\n\tDS:DX -> modified FCB (see also #01345)\r\n\n\t\tthe old filename ('?' wildcards OK) is in the standard location\r\n\n\t\twhile the new filename ('?' wildcards OK, no drive) is stored\r\n\n\t\tin the 11 bytes beginning at offset 11h\r\n\nReturn: AL = status\r\n\n\t    00h successfully renamed\r\n\n\t    FFh no matching files,file is read-only, or new name already exists\r\n",
      "18": " DOS 1+ - NULL FUNCTION FOR CP/M COMPATIBILITY\r\nReturn: AL = 00h\r\n",
      "19": " DOS 1+ - GET CURRENT DEFAULT DRIVE\r\nReturn: AL = drive (00h = A:, 01h = B:, etc)\r\n",
      "1A": " DOS 1+ - SET DISK TRANSFER AREA ADDRESS\r\n\tDS:DX -> Disk Transfer Area (DTA)\r\n",
      "1B": " DOS 1+ - GET ALLOCATION INFORMATION FOR DEFAULT DRIVE\r\nReturn: AL = sectors per cluster (allocation unit)\r\n\n\tCX = bytes per sector\r\n\n\tDX = total number of clusters\r\n\n\tDS:BX -> media ID byte (see #01356)\r\n",
      "1C": " DOS 1+ - GET ALLOCATION INFORMATION FOR SPECIFIC DRIVE\r\n\tDL = drive (00h = default, 01h = A:, etc)\r\n\nReturn: AL = sectors per cluster (allocation unit), or FFh if invalid drive\r\n\n\tCX = bytes per sector\r\n\n\tDX = total number of clusters\r\n\n\tDS:BX -> media ID byte (see #01356)\r\n",
      "1D": " DOS 1+ - NULL FUNCTION FOR CP/M COMPATIBILITY\r\nReturn: AL = 00h\r\n",
      "1E": " DOS 1+ - NULL FUNCTION FOR CP/M COMPATIBILITY\r\nReturn: AL = 00h\r\n",
      "1F": " DOS 1+ - GET DRIVE PARAMETER BLOCK FOR DEFAULT DRIVE\r\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tDS:BX -> Drive Parameter Block (DPB) (see #01357 for DOS 1.x,\r\n\n\t\t\tAH=32h for DOS 2+)\r\n\n\t    FFh invalid drive\r\n",
      "20": " DOS 1+ - NULL FUNCTION FOR CP/M COMPATIBILITY\r\nReturn: AL = 00h\r\n",
      "21": " DOS 1+ - READ RANDOM RECORD FROM FCB FILE\r\n\tDS:DX -> opened FCB (see #01345)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h end of file, no data read\r\n\n\t    02h segment wrap in DTA, no data read\r\n\n\t    03h end of file, partial record read\r\n\n\tDisk Tranfer Area filled with record read from file\r\n",
      "22": " DOS 1+ - WRITE RANDOM RECORD TO FCB FILE\r\n\tDS:DX -> opened FCB (see #01345)\r\n\n\tDisk Transfer Area contains record to be written\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h disk full\r\n\n\t    02h segment wrap in DTA\r\n",
      "23": " DOS 1+ - GET FILE SIZE FOR FCB\r\n\tDS:DX -> unopened FCB (see #01345), wildcards not allowed\r\n\nReturn: AL = status\r\n\n\t    00h successful (matching file found)\r\n\n\t\tFCB random record field filled with size in records, rounded up\r\n\n\t\tto next full record\r\n\n\t    FFh failed (no matching file found)\r\n",
      "24": " DOS 1+ - SET RANDOM RECORD NUMBER FOR FCB\r\n\tDS:DX -> opened FCB (see #01345)\r\n",
      "25": " DOS 1+ - SET INTERRUPT VECTOR\r\n\tAL = interrupt number\r\n\n\tDS:DX -> new interrupt handler\r\n",
      "26": " DOS 1+ - CREATE NEW PROGRAM SEGMENT PREFIX\r\n\tDX = segment at which to create PSP (see #01378)\r\n\nReturn: AL destroyed\r\n",
      "27": " DOS 1+ - RANDOM BLOCK READ FROM FCB FILE\r\n\tCX = number of records to read\r\n\n\tDS:DX -> opened FCB (see #01345)\r\n\nReturn: AL = status\r\n\n\t    00h successful, all records read\r\n\n\t    01h end of file, no data read\r\n\n\t    02h segment wrap in DTA, no data read\r\n\n\t    03h end of file, partial read\r\n\n\tDisk Transfer Area filled with records read from file\r\n\n\tCX = number of records read (return AL = 00h or 03h)\r\n",
      "28": " DOS 1+ - RANDOM BLOCK WRITE TO FCB FILE\r\n\tCX = number of records to write\r\n\n\tDS:DX -> opened FCB (see #01345)\r\n\n\tDisk Transfer Area contains records to be written\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h disk full or file read-only\r\n\n\t    02h segment wrap in DTA\r\n\n\tCX = number of records written\r\n",
      "29": " DOS 1+ - PARSE FILENAME INTO FCB\r\n\tAL = parsing options (see #01380)\r\n\n\tDS:SI -> filename string (both '*' and '?' wildcards OK)\r\n\n\tES:DI -> buffer for unopened FCB\r\n\nReturn: AL = result code\r\n\n\t    00h successful parse, no wildcards encountered\r\n\n\t    01h successful parse, wildcards present\r\n\n\t    FFh failed (invalid drive specifier)\r\n\n\tDS:SI -> first unparsed character\r\n\n\tES:DI buffer filled with unopened FCB (see #01345)\r\n",
      "2A": " DOS 1+ - GET SYSTEM DATE\r\nReturn: CX = year (1980-2099)\r\n\n\tDH = month\r\n\n\tDL = day\r\n",
      "2B": " bitFOSSI - INSTALLATION CHECK\r\n\tCX = 6269h ('bi')\r\n\n\tDX = 7449h ('tI')\r\n\nReturn: AL = FFh if not installed\r\n\n\tAL = 53h ('S') if bitFOSSI is installed\r\n\n\t    CX = 444Eh ('DN')\r\n\n\t    DX = 2D46h ('-F')\r\n\n\t    ES = resident code segment\r\n\n\t    ES:DI -> identification data\r\n",
      "2C": " DOS 1+ - GET SYSTEM TIME\r\nReturn: CH = hour\r\n\n\tCL = minute\r\n\n\tDH = second\r\n\n\tDL = 1/100 seconds\r\n",
      "2D": " DOS 1+ - SET SYSTEM TIME\r\n\tCH = hour\r\n\n\tCL = minute\r\n\n\tDH = second\r\n\n\tDL = 1/100 seconds\r\n\nReturn: AL = result\r\n\n\t    00h successful\r\n\n\t    FFh invalid time, system time unchanged\r\n",
      "2E": " DOS 1+ - SET VERIFY FLAG\r\n\tDL = 00h (DOS 1.x/2.x only)\r\n\n\tAL = new state of verify flag\r\n\n\t    00h off\r\n\n\t    01h on\r\n",
      "2F": " DOS 2+ - GET DISK TRANSFER AREA ADDRESS\r\nReturn: ES:BX -> current DTA\r\n",
      "30": " Phar Lap 386/DOS-Extender, Intel Code Builder - INSTALLATION CHECK\r\n\tEAX = 00003000h\r\n\n\tEBX = 50484152h (\"PHAR\")\r\n\nReturn: AL = major DOS version\r\n\n\tAH = minor DOS version\r\n\n\tEAX bits 31-16 = 4458h ('DX') if 386/DOS-extender installed\r\n\n\t    BL = ASCII major version number\r\n\n\tEAX bits 31-16 = 4243h ('BC') if Intel Code Builder installed\r\n\n\t    EDX = address of GDA\r\n",
      "31": " DOS 2+ - TERMINATE AND STAY RESIDENT\r\n\tAL = return code\r\n\n\tDX = number of paragraphs to keep resident\r\n\nReturn: never\r\n",
      "32": " DOS 2+ - GET DOS DRIVE PARAMETER BLOCK FOR SPECIFIC DRIVE\r\n\tDL = drive number (00h = default, 01h = A:, etc)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tDS:BX -> Drive Parameter Block (DPB) (see #01395) for specified\r\n\n\t\t\t  drive\r\n\n\t    FFh invalid or network drive\r\n",
      "33": " DOS 2+ - EXTENDED BREAK CHECKING\r\n\tAL = subfunction\r\n\n\t    00h get current extended break state\r\n\n\t\tReturn: DL = current state, 00h = off, 01h = on\r\n\n\t    01h set state of extended ^C/^Break checking\r\n\n\t\tDL = new state\r\n\n\t\t    00h off, check only on character I/O functions\r\n\n\t\t    01h on, check on all DOS functions\r\n\n\t\tReturn: (Novell DOS 7) DL = old state of extended Break checks\r\n",
      "34": " DOS 2+ - GET ADDRESS OF INDOS FLAG\r\nReturn: ES:BX -> one-byte InDOS flag\r\n",
      "35": " DOS 2+ - GET INTERRUPT VECTOR\r\n\tAL = interrupt number\r\n\nReturn: ES:BX -> current interrupt handler\r\n",
      "36": " DOS 2+ - GET FREE DISK SPACE\r\n\tDL = drive number (00h = default, 01h = A:, etc)\r\n\nReturn: AX = FFFFh if invalid drive\r\n\n\telse\r\n\n\t    AX = sectors per cluster\r\n\n\t    BX = number of free clusters\r\n\n\t    CX = bytes per sector\r\n\n\t    DX = total clusters on drive\r\n",
      "37": " DOS 2.x and 3.3+ only - \"AVAILDEV\" - SPECIFY \\DEV\\ PREFIX USE\r\n\tAL = subfunction\r\n\n\t    02h get availdev flag\r\n\n\t\tReturn: DL = 00h \\DEV\\ must precede character device names\r\n\n\t\t\t   = nonzero \\DEV\\ is optional\r\n\n\t    03h set availdev flag\r\n\n\t\tDL = new state\r\n\n\t\t    00h\t\t\\DEV\\ is mandatory\r\n\n\t\t    nonzero\t\\DEV\\ is optional\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    FFh unsupported subfunction\r\n",
      "38": " DOS 3.0+ - SET COUNTRY CODE\r\n\tDX = FFFFh\r\n\n\tAL = 01h thru FEh for specific country with code <255\r\n\n\tAL = FFh for specific country with code >= 255\r\n\n\t   BX = 16-bit country code (see #01400)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n",
      "39": " DOS 2+ - \"MKDIR\" - CREATE SUBDIRECTORY\r\n\tDS:DX -> ASCIZ pathname\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h,05h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "3A": " DOS 2+ - \"RMDIR\" - REMOVE SUBDIRECTORY\r\n\tDS:DX -> ASCIZ pathname of directory to be removed\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h,05h,06h,10h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "3B": " DOS 2+ - \"CHDIR\" - SET CURRENT DIRECTORY\r\n\tDS:DX -> ASCIZ pathname to become current directory (max 64 bytes)\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "3C": " DOS 2+ - \"CREAT\" - CREATE OR TRUNCATE FILE\r\n\tCX = file attributes (see #01401)\r\n\n\tDS:DX -> ASCIZ filename\r\n\nReturn: CF clear if successful\r\n\n\t    AX = file handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h,04h,05h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "3D": " DOS 2+ - \"OPEN\" - OPEN EXISTING FILE\r\n\tAL = access and sharing modes (see #01402)\r\n\n\tDS:DX -> ASCIZ filename\r\n\n\tCL = attribute mask of files to look for (server call only)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = file handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,02h,03h,04h,05h,0Ch,56h) (see #01680 at AH=59h)\r\n",
      "3E": " DOS 2+ - \"CLOSE\" - CLOSE FILE\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "3F": " DOS 2+ - \"READ\" - READ FROM FILE OR DEVICE\r\n\tBX = file handle\r\n\n\tCX = number of bytes to read\r\n\n\tDS:DX -> buffer for data\r\n\nReturn: CF clear if successful\r\n\n\t    AX = number of bytes actually read (0 if at EOF before call)\r\n\n\tCF set on error\r\n\n\t    AX = error code (05h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "40": " DOS 2+ - \"WRITE\" - WRITE TO FILE OR DEVICE\r\n\tBX = file handle\r\n\n\tCX = number of bytes to write\r\n\n\tDS:DX -> data to write\r\n\nReturn: CF clear if successful\r\n\n\t    AX = number of bytes actually written\r\n\n\tCF set on error\r\n\n\t    AX = error code (05h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "41": " DOS 2+ - \"UNLINK\" - DELETE FILE\r\n\tDS:DX -> ASCIZ filename (no wildcards, but see notes)\r\n\n\tCL = attribute mask for deletion (server call only, see notes)\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed (DOS 3.3) AL seems to be drive of deleted file\r\n\n\tCF set on error\r\n\n\t    AX = error code (02h,03h,05h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "42": " DOS 2+ - \"LSEEK\" - SET CURRENT FILE POSITION\r\n\tAL = origin of move\r\n\n\t    00h start of file\r\n\n\t    01h current file position\r\n\n\t    02h end of file\r\n\n\tBX = file handle\r\n\n\tCX:DX = (signed) offset from origin of new file position\r\n\nReturn: CF clear if successful\r\n\n\t    DX:AX = new file position in bytes from start of file\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "45": " DOS 2+ - \"DUP\" - DUPLICATE FILE HANDLE\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    AX = new handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (04h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "46": " DOS 2+ - \"DUP2\", \"FORCEDUP\" - FORCE DUPLICATE FILE HANDLE\r\n\tBX = file handle\r\n\n\tCX = file handle to become duplicate of first handle\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (04h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "47": " DOS 2+ - \"CWD\" - GET CURRENT DIRECTORY\r\n\tDL = drive number (00h = default, 01h = A:, etc)\r\n\n\tDS:SI -> 64-byte buffer for ASCIZ pathname\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 0100h (undocumented)\r\n\n\tCF set on error\r\n\n\t    AX = error code (0Fh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "48": " DOS 2+ - ALLOCATE MEMORY\r\n\tBX = number of paragraphs to allocate\r\n\nReturn: CF clear if successful\r\n\n\t    AX = segment of allocated block\r\n\n\tCF set on error\r\n\n\t    AX = error code (07h,08h) (see #01680 at AH=59h/BX=0000h)\r\n\n\t    BX = size of largest available block\r\n",
      "49": " DOS 2+ - FREE MEMORY\r\n\tES = segment of block to free\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (07h,09h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4A": " DOS 2+ - RESIZE MEMORY BLOCK\r\n\tBX = new size in paragraphs\r\n\n\tES = segment of block to resize\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (07h,08h,09h) (see #01680 at AH=59h/BX=0000h)\r\n\n\t    BX = maximum paragraphs available for specified memory block\r\n",
      "4B": " DOS 2+ - \"EXEC\" - LOAD AND/OR EXECUTE PROGRAM\r\n\tAL = type of load\r\n\n\t    00h load and execute\r\n\n\t    01h load but do not execute\r\n\n\t    03h load overlay (see #01591)\r\n\n\t    04h load and execute in background (European MS-DOS 4.0 only)\r\n\n\t\t\"Exec & Go\" (see also AH=80h)\r\n\n\tDS:DX -> ASCIZ program name (must include extension)\r\n\n\tES:BX -> parameter block (see #01590,#01591,#01592)\r\n\n\tCX = mode (subfunction 04h only)\r\n\n\t\t0000h child placed in zombie mode after termination\r\n\n\t\t0001h child's return code discarded on termination\r\n\nReturn: CF clear if successful\r\n\n\t    BX,DX destroyed\r\n\n\t    if subfunction 01h, process ID set to new program's PSP; get with\r\n\n\t\tINT 21/AH=62h\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,02h,05h,08h,0Ah,0Bh) (see #01680 at AH=59h)\r\n",
      "4C": " DOS 2+ - \"EXIT\" - TERMINATE WITH RETURN CODE\r\n\tAL = return code\r\n\nReturn: never returns\r\n",
      "4D": " DOS 2+ - GET RETURN CODE (ERRORLEVEL)\r\nReturn: AH = termination type\r\n\n\t    00h normal (INT 20,INT 21/AH=00h, or INT 21/AH=4Ch)\r\n\n\t    01h control-C abort\r\n\n\t    02h critical error abort\r\n\n\t    03h terminate and stay resident (INT 21/AH=31h or INT 27)\r\n\n\tAL = return code\r\n\n\tCF clear\r\n",
      "4E": " DOS 2+ - \"FINDFIRST\" - FIND FIRST MATCHING FILE\r\n\tAL = special flag for use by APPEND (refer to note below)\r\n\n\tCX = file attribute mask (see #01420 at AX=4301h) (bits 0 and 5 ignored)\r\n\n\t    0088h (Novell DOS 7) find first deleted file\r\n\n\tDS:DX -> ASCIZ file specification (may include path and wildcards)\r\n\nReturn: CF clear if successful\r\n\n\t    Disk Transfer Area filled with FindFirst data block (see #01626)\r\n\n\tCF set on error\r\n\n\t    AX = error code (02h,03h,12h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4F": " DOS 2+ - \"FINDNEXT\" - FIND NEXT MATCHING FILE\r\n\tDisk Transfer Area contains data block from previous FindFirst or\r\n\n\t  FindNext call\r\n\nReturn: CF clear if successful\r\n\n\t    Disk Transfer Area updated\r\n\n\tCF set on error\r\n\n\t    AX = error code (12h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "50": " DOS 2+ internal - SET CURRENT PROCESS ID (SET PSP ADDRESS)\r\n\tBX = segment of PSP for new process\r\n",
      "51": " DOS 2+ internal - GET CURRENT PROCESS ID (GET PSP ADDRESS)\r\nReturn: BX = segment of PSP for current process\r\n",
      "52": " DOS 2+ internal - \"SYSVARS\" - GET LIST OF LISTS\r\nReturn: ES:BX -> DOS list of lists (see #01627)\r\n",
      "53": " DOS 2+ internal - TRANSLATE BIOS PARAMETER BLOCK TO DRIVE PARAM BLOCK\r\n\tDS:SI -> BIOS Parameter Block (see #01663)\r\n\n\tES:BP -> buffer for Drive Parameter Block (see #01395 at AH=32h)\r\n\n\t    DBP drive byte must be set to valid drive (Windows95-OSR2)\r\n\n\t---Windows95---\r\n\n\tCX = signature 4558h ('EX') for FAT32 extended BPB/DPB (see #01664)\r\n\n\tDX = signature 4152h ('AR') for FAT32 extended BPB/DPB\r\n\nReturn: ES:BP buffer filled\r\n",
      "54": " DOS 2+ - GET VERIFY FLAG\r\nReturn: AL = verify flag\r\n\n\t    00h off\r\n\n\t    01h on (all disk writes verified after writing)\r\n",
      "55": " DOS 2+ internal - CREATE CHILD PSP\r\n\tDX = segment at which to create new PSP\r\n\n\tSI = (DOS 3.0+) value to place in memory size field at DX:[0002h]\r\n\nReturn: AL destroyed\r\n",
      "56": " DOS 2+ - \"RENAME\" - RENAME FILE\r\n\tDS:DX -> ASCIZ filename of existing file (no wildcards, but see below)\r\n\n\tES:DI -> ASCIZ new filename (no wildcards)\r\n\n\tCL = attribute mask (server call only, see below)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (02h,03h,05h,11h) (see #01680)\r\n",
      "58": " DOS 5+ - GET OR SET UMB LINK STATE\r\n\tAL = subfunction\r\n\n\t    02h get UMB link state\r\n\n\t\tReturn: AL = current link state\r\n\n\t\t\t    00h UMBs not part of DOS memory chain\r\n\n\t\t\t    01h UMBs in DOS memory chain\r\n\n\t    03h set UMB link state\r\n\n\t\tBX = new link state\r\n\n\t\t    0000h remove UMBs from DOS memory chain\r\n\n\t\t    0001h add UMBs to DOS memory chain\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h) (see #01680)\r\n",
      "59": " European MS-DOS 4.0 - GET HARD ERROR INFORMATION\r\n\tBX = 0001h\r\n\nReturn: ES:DI -> hard error information packet (see #01685) for most recent\r\n\n\t\thard (critical) error\r\n",
      "5A": " DOS 3.0+ - CREATE TEMPORARY FILE\r\n\tCX = file attribute (see #01420 at AX=4301h)\r\n\n\tDS:DX -> ASCIZ path ending with a '\\' + 13 zero bytes to receive the\r\n\n\t\tgenerated filename\r\n\nReturn: CF clear if successful\r\n\n\t    AX = file handle opened for read/write in compatibility mode\r\n\n\t    DS:DX pathname extended with generated name for temporary file\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h,04h,05h) (see #01680)\r\n",
      "5B": " DOS 3.0+ - CREATE NEW FILE\r\n\tCX = file attribute (see #01420 at AX=4301h)\r\n\n\tDS:DX -> ASCIZ filename\r\n\nReturn: CF clear if successful\r\n\n\t    AX = file handle opened for read/write in compatibility mode\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h,04h,05h,50h) (see #01680)\r\n",
      "5C": " DOS 3.0+ - \"FLOCK\" - RECORD LOCKING\r\n\tAL = subfunction\r\n\n\t    00h lock region of file\r\n\n\t    01h unlock region of file\r\n\n\tBX = file handle\r\n\n\tCX:DX = start offset of region within file\r\n\n\tSI:DI = length of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,06h,21h,24h) (see #01680)\r\n",
      "60": " DOS 3.0+ - \"TRUENAME\" - CANONICALIZE FILENAME OR PATH\r\n\tDS:SI -> ASCIZ filename or path\r\n\n\tES:DI -> 128-byte buffer for canonicalized name\r\n\nReturn: CF set on error\r\n\n\t    AX = error code\r\n\n\t\t02h invalid component in directory path or drive letter only\r\n\n\t\t03h malformed path or invalid drive letter\r\n\n\t    ES:DI buffer unchanged\r\n\n\tCF clear if successful\r\n\n\t    AH = 00h or 3Ah (DOS 6.1/6.2 for character device)\r\n\n\t    AL = destroyed (00h or 2Fh or 5Ch or last character of current\r\n\n\t\t  directory on drive)\r\n\n\t    buffer filled with qualified name of form D:\\PATH\\FILE.EXT or\r\n\n\t      \\\\MACHINE\\PATH\\FILE.EXT\r\n",
      "61": " DOS 3.0+ - UNUSED (RESERVED FOR NETWORK USE)\r\nReturn: AL = 00h\r\n",
      "62": " DOS 3.0+ - GET CURRENT PSP ADDRESS\r\nReturn: BX = segment of PSP for current process\r\n",
      "64": " DOS 3.2+ internal - SET DEVICE DRIVER LOOKAHEAD FLAG\r\n\tAL = flag\r\n\n\t\t00h (default) call device driver function 5 (non-dest read)\r\n\n\t\t\tbefore INT 21/AH=01h,08h,0Ah\r\n\n\t    nonzero don't call driver function 5\r\n\nReturn: nothing (MS-DOS)\r\n\n\tCF set, AX=error code??? (DR DOS 5.0, which does not support this call)\r\n",
      "65": " DOS 4.0+ internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION\r\n\tAL = function\r\n\n\t    A0h capitalize filename character\r\n\n\t\tDL = character to capitalize\r\n\n\t\tReturn: DL = capitalized character\r\n\n\t    A1h capitalize counted filename string\r\n\n\t\tDS:DX -> filename string to capitalize\r\n\n\t\tCX = length of string\r\n\n\t    A2h capitalize ASCIZ filename\r\n\n\t\tDS:DX -> ASCIZ filename to capitalize\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n",
      "67": " DOS 3.3+ - SET HANDLE COUNT\r\n\tBX = size of new file handle table for process\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n",
      "68": " DOS 3.3+ - \"FFLUSH\" - COMMIT FILE\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    all data still in DOS disk buffers is written to disk immediately,\r\n\n\t      and the file's directory entry is updated\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n",
      "69": " DOS 4.0+ internal - GET/SET DISK SERIAL NUMBER\r\n\tAL = subfunction\r\n\n\t    00h get serial number\r\n\n\t    01h set serial number\r\n\n\tBL = drive (0=default, 1=A, 2=B, etc)\r\n\n\tBH = info level (00h only for DOS; OS/2 allows other levels)\r\n\n\tDS:DX -> disk info (see #01766)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    AX destroyed\r\n\n\t    (AL = 00h) buffer filled with appropriate values from extended BPB\r\n\n\t    (AL = 01h) extended BPB on disk set to values from buffer\r\n",
      "6A": " DOS 4.0+ - COMMIT FILE\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 68h\r\n\n\tCF set on error\r\n\n\t    AX = error code (06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "6B": " DOS 5+ - NULL FUNCTION\r\nReturn: AL = 00h\r\n",
      "6D": " DOS 5+ ROM - FIND FIRST ROM PROGRAM\r\n\tDS:DX -> ASCIZ program name (may contain wildcrds)\r\n\nReturn: CF clear if found\r\n\n\t    Disk Transfer Area filled with ROM search structure (see #01771)\r\n\n\tCF set if not found\r\n\n\t    AX = error code\r\n\n\t\t0002h name not found in ROM\r\n\n\t\t0003h name contains colon or backslash\r\n\n\t---if not supported (DOS <5, MS-DOS 5+ non-ROM versions)---\r\n\n\tAL = 00h\r\n",
      "6E": " DOS 5+ ROM - FIND NEXT ROM PROGRAM\r\n\tDisk Transfer Area contains result of previous FindFirst ROM\r\n\n\t  (see AH=6Dh)\r\n\nReturn: CF clear if found\r\n\n\t    Disk Transfer Area filled with updated ROM search structure\r\n\n\t      (see #01771)\r\n\n\tCF set if not found\r\n\n\t    AX = 0012h (no more matches)\r\n\n\t---if not supported (DOS <5, MS-DOS 5+ non-ROM versions)---\r\n\n\tAL = 00h\r\n",
      "70": " MS-DOS 7 (Windows95) - GET/SET INTERNATIONALIZATION INFORMATION\r\n\tAL = subfunction\r\n\n\t    00h get ??? info\r\n\n\t\tCX = buffer size (3Ah bytes needed)\r\n\n\t\tES:DI -> buffer\r\n\n\t    01h set above info\r\n\n\t\tCX = number of bytes to set\r\n\n\t\tDS:SI -> buffer containing ??? info (see #01774)\r\n\n\t    02h set general internationalization info (see also AX=6500h)\r\n\n\t\tDS:SI -> buffer containing info (see #01775)\r\n\n\t\tCX = buffer size in bytes (up to 26h bytes used)\r\n\n\t\tfirst three bytes are skipped, the rest is copied to somewhere\r\n\n\t\t  in the DOS data segment\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI buffer filled (func 00h) (see #01774)\r\n\n\t    CX = number of bytes actually set or returned\r\n\n\t\t  (max 003Ah for functions 00h and 01h under v7.00, 0026h for\r\n\n\t\t  function 02h)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7000h if function not supported\r\n",
      "71": " Windows95 - LONG FILENAME FUNCTIONS\r\n\tAL = function\r\n\n\t    0Dh reset drive (see AX=710Dh)\r\n\n\t    39h create directory (see AX=7139h)\r\n\n\t    3Ah remove directory (see AX=713Ah)\r\n\n\t    3Bh set current directory (see AX=713Bh)\r\n\n\t    41h delete file (see AX=7141h)\r\n\n\t    43h get/set file attributes (see AX=7143h)\r\n\n\t    47h get current directory (see AX=7147h)\r\n\n\t    4Eh find first file (see AX=714Eh)\r\n\n\t    4Fh find next file (see AX=714Fh)\r\n\n\t    56h move (rename) file (see AX=7156h)\r\n\n\t    60h truename (see AX=7160h/CL=00h,AX=7160h/CL=02h)\r\n\n\t    6Ch create/open file (see AX=716Ch)\r\n\n\t    A0h get volume information (see AX=71A0h)\r\n\n\t    A1h terminate FindFirst/FindNext (see AX=71A1h)\r\n\n\t    A6h get file information (see AX=71A6h)\r\n\n\t    A7h time conversion (see AX=71A7h/BL=00h,AX=71A7h/BL=01h)\r\n\n\t    A8h generate short filename (see AX=71A8h)\r\n\n\t    A9h server create/open file (see AX=71A9h)\r\n\n\t    AAh create/terminate SUBST (see AX=71AAh/BH=00h,AX=71AAh/BH=02h)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n\n\tCF clear if successful\r\n\n\t    other registers as for corresponding \"old\" DOS function\r\n",
      "72": " Windows95 beta - LFN-FindClose\r\n\tdetails not available\r\n\nReturn:\tCF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7200h if function not supported (e.g. under bare MS-DOS 7)\r\n",
      "73": " MS-DOS 7 - DRIVE LOCKING AND FLUSHING\r\n\tDL = drive (0=current, 1=A:, etc.)\r\n\n\tCL = which flag to get or set\r\n\n\t    00h drive flag???\r\n\n\t    01h drive's dirty-buffers flag\r\n\n\tAL = subfunction\r\n\n\t    00h get indicated flag\r\n\n\t    01h set ???\r\n\n\t\tCH = new value for indicated flag\r\n\n\t\t    bit 1: ??? (CL=00h only)\r\n\n\t\t    bit 3: dirty buffers exist for selected drive (CL=01h only)\r\n\nReturn: CF clear if successful\r\n\n\t    for AL=00h:\r\n\n\t\tAL = value of CL on entry\r\n\n\t\tfor CL=00h: AH = new flag and 06h (i.e. bits 1 and 2 used)\r\n\n\t\tfor CL=01h: AH = new flag and 08h (i.e. bit 3 used)\r\n\n\t\t(flag being taken from a table of bytes)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,0Fh,etc.) (see #01680)\r\n\n\t\t7300h if function not supported\r\n",
      "80": " European MS-DOS 4.0 - \"AEXEC\" - EXECUTE PROGRAM IN BACKGROUND\r\n\tCX = mode\r\n\n\t    0000h place child in zombie mode on exit to preserve exit code\r\n\n\t    0001h discard child process and exit code on termination\r\n\n\tDS:DX -> ASCIZ full program name\r\n\n\tES:BX -> parameter block (as for AX=4B00h)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = Command Subgroup ID (CSID)\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n",
      "81": " European MS-DOS 4.0 - \"FREEZE\" - STOP A PROCESS\r\n\tBX = flag (00h freeze command subtree, 01h only specified process)\r\n\n\tCX = Process ID of head of command subtree\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (no such process)\r\n",
      "82": " European MS-DOS 4.0 - \"RESUME\" - RESTART A PROCESS\r\n\tBX = flag (00h resume command subtree, 01h only specified process)\r\n\n\tCX = Process ID of head of command subtree\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (no such process)\r\n",
      "83": " European MS-DOS 4.0 - \"PARTITION\" - GET/SET FOREGROUND PARTITION SIZE\r\n\tAL = function\r\n\n\t    00h get size\r\n\n\t    01h set new size\r\n\n\t\tBX = new size in paragraphs\r\n\nReturn: CF clear if successful\r\n\n\t    BX = current size (function 00h) or old size (function 01h)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,07h,0Dh)(see #01680 at AH=59h/BX=0000h)\r\n",
      "85": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "86": " European MS-DOS 4.0 - \"SETFILETABLE\" - INSTALL NEW FILE HANDLE TABLE\r\n\tBX = total number of file handles in new table\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (06h,08h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "87": " European MS-DOS 4.0 - \"GETPID\" - GET PROCESS IDENTIFIER\r\nReturn: AX = PID\r\n\n\tBX = parent process's PID\r\n\n\tCX = Command Subgroup ID (CSID)\r\n",
      "88": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "89": " European MS-DOS 4.0 - SLEEP\r\n\tCX = time in milliseconds or 0000h to give up time slice\r\n\nReturn: CF clear if successful\r\n\n\t    CX = 0000h\r\n\n\tCF set on error\r\n\n\t    AX = error code (interrupted system call)\r\n\n\t    CX = sleep time remaining\r\n",
      "8A": " European MS-DOS 4.0 - \"CWAIT\" - WAIT FOR CHILD TO TERMINATE\r\n\tBL = range (00h command subtree, 01h any child)\r\n\n\tBH = suspend flag\r\n\n\t    00h suspend if children exist but none are dead\r\n\n\t    01h return if no dead children\r\n\n\tCX = Process ID of head of command subtree\r\n\nReturn: CF clear if successful\r\n\n\t    AH = termination type (see #01792)\r\n\n\t    AL = return code from child or aborting signal\r\n\n\t    BX = PID of child (0000h if no dead children)\r\n\n\tCF set on error\r\n\n\t    AX = error code (no child,interrupted system call)\r\n",
      "8B": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "8C": " European MS-DOS 4.0 - SET SIGNAL HANDLER\r\n\tAL = signal number (see #01793)\r\n\n\tBL = action (see #01794)\r\n\n\tDS:DX -> signal handler (see #01795)\r\n\nReturn: CF clear if successful\r\n\n\t    AL = previous action\r\n\n\t    ES:BX -> previous signal handler\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,invalid SigNumber or Action)\r\n\n\t\t  (see #01680 at AH=59h/BX=0000h)\r\n",
      "8D": " European MS-DOS 4.0 - SEND SIGNAL\r\n\tAL = signal number (see #01793)\r\n\n\tBH = signal argument\r\n\n\tBL = action\r\n\n\t    00h send to entire command subtree\r\n\n\t    01h send only to specified process\r\n\n\tDX = Process ID\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,06h)(see #01680 at AH=59h/BX=0000h)\r\n",
      "8F": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "90": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "91": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "92": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "93": " European MS-DOS 4.0 - \"PIPE\" - CREATE A NEW PIPE\r\n\tCX = size in bytes\r\n\nReturn: CF clear if successful\r\n\n\t    AX = read handle\r\n\n\t    BX = write handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (08h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "94": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "95": " European MS-DOS 4.0 - HARD ERROR PROCESSING\r\n\tAL = new state\r\n\n\t   00h enabled\r\n\n\t   01h disabled, automatically fail hard errors\r\n\nReturn: AX = previous setting\r\n",
      "96": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "97": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "98": " European MS-DOS 4.0 - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "99": " European MS-DOS 4.0 - \"PBLOCK\" - BLOCK A PROCESS\r\n\tDS:BX -> memory location to block on\r\n\n\tCX = timeout in milliseconds\r\n\n\tDH = nonzero if interruptable\r\n\nReturn: CF clear if awakened by event\r\n\n\t    AX = 0000h\r\n\n\tCF set if unusual wakeup\r\n\n\t    ZF set if timeout, clear if interrupted by signal\r\n\n\t    AX = nonzero\r\n",
      "9A": " European MS-DOS 4.0 - \"PRUN\" - UNBLOCK A PROCESS\r\n\tDS:BX -> memory location processes may have blocked on\r\n\nReturn: AX = number of processes awakened\r\n\n\tZF set if no processes awakened\r\n",
      "E0": " DoubleDOS - MENU CONTROL\r\n\tAL = subfunction\r\n\n\t    01h exchange tasks\r\n\n\t    73h resume invisible job if suspended\r\n\n\t    74h kill other job\r\n\n\t    75h suspend invisible job\r\n",
      "E1": " DoubleDOS - CLEAR KEYBOARD BUFFER FOR CURRENT JOB\r\n",
      "E2": " OS/286, OS/386 - SET REAL PROCEDURE SIGNAL HANDLER\r\n\t???\r\n\nReturn: ???\r\n",
      "E3": " DoubleDOS - ADD CHARACTER TO KEYBOARD BUFFER OF CURRENT JOB\r\n\tAL = character\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h buffer full (128 characters)\r\n",
      "E5": " DoubleDOS - OTHER PROGRAM STATUS\r\nReturn: AL = status\r\n\n\t    00h no program in other partition\r\n\n\t    01h program in other partition is running\r\n\n\t    02h program in other partition is suspended\r\n",
      "E6": " OS/286, OS/386 - ISSUE REAL PROCEDURE SIGNAL FROM PROTECTED MODE\r\n\t???\r\n\nReturn: ???\r\n",
      "E7": " OS/286, OS/386 - CREATE CODE SEGMENT\r\n\t???\r\n\nReturn: ???\r\n",
      "E8": " DoubleDOS - SET/RESET KEYBOARD CONTROL FLAGS\r\n\tAL = program for which to set flags (00h this program, 01h other)\r\n\n\tDX = keyboard control flags (see #02088)\r\n\nReturn: DX = previous flags\r\n",
      "E9": " DoubleDOS - SET TIMESHARING PRIORITY\r\n\tAL = new priority (see #02089)\r\n\nReturn: AL = priority setting if AL=05h on entry\r\n",
      "EA": " OS/286, OS/386 - ALLOCATE HUGE SEGMENT\r\n\t???\r\n\nReturn: ???\r\n",
      "EB": " DoubleDOS - TURN ON TASK SWITCHING\r\nReturn: task switching turned on\r\n",
      "EC": " OS/286, OS/386 - BLOCK TRANSFER\r\n\t???\r\n\nReturn: ???\r\n",
      "ED": " OS/286, OS/386 - GET SEGMENT OR WINDOW DESCRIPTOR\r\n\t???\r\n\nReturn: ???\r\n",
      "EE": " DoubleDOS - GIVE AWAY TIME TO OTHER TASKS\r\n\tAL = number of 55ms time slices to give away\r\n\nReturn: returns after giving away time slices\r\n",
      "F0": " DoubleDOS - MENU CONTROL\r\n\tAL = subfunction\r\n\n\t    01h exchange tasks\r\n\n\t    73h resume invisible job if suspended\r\n\n\t    74h kill other job\r\n\n\t    75h suspend invisible job\r\n",
      "F1": " DoubleDOS - CLEAR KEYBOARD BUFFER FOR CURRENT JOB\r\n",
      "F2": " DoubleDOS - SEND CHARACTER TO KEYBOARD BUFFER OF OTHER JOB\r\n\tAL = character\r\n\nReturn: AL = status (see #02860 at INT 2F/AX=7A20h/BX=0000h)\r\n\n\t    00h successful\r\n\n\t    01h buffer full (128 characters)\r\n",
      "F3": " DoubleDOS - ADD CHARACTER TO KEYBOARD BUFFER OF CURRENT JOB\r\n\tAL = character\r\n\nReturn: AL = 00h successful\r\n\n\t     01h buffer full (128 characters)\r\n",
      "F5": " DoubleDOS - OTHER PROGRAM STATUS\r\nReturn: AL = program status\r\n\n\t    00h no program in other partition\r\n\n\t    01h program in other partition is running\r\n\n\t    02h program in other partition is suspended\r\n",
      "F8": " DoubleDOS - SET/RESET KEYBOARD CONTROL FLAGS\r\n\tAL = program for which to set flags\r\n\n\t    00h this program\r\n\n\t    01h other program\r\n\n\tDX = keyboard control flags (see #02088 at AH=E8h\"DoubleDOS\")\r\n\nReturn: DX = previous flags\r\n",
      "F9": " DoubleDOS - SET TIMESHARING PRIORITY\r\n\tAL = priority\r\n\n\t    00h visible program gets 70%, invisible gets 30% (default)\r\n\n\t    01h visible program gets 50%, invisible gets 50%\r\n\n\t    02h visible program gets 30%, invisible gets 70%\r\n\n\t    03h Top program gets 70%, bottom program gets 30%\r\n\n\t    04h Top program gets 30%, bottom program gets 70%\r\n\n\t    05h get current priority\r\n\n\t\tReturn: AL = priority setting\r\n",
      "FA": " DoubleDOS - TURN OFF TASK SWITCHING\r\nReturn: task switching turned off\r\n",
      "FB": " DoubleDOS - TURN ON TASK SWITCHING\r\nReturn: task switching turned on\r\n",
      "FC": " DoubleDOS - GET VIRTUAL SCREEN ADDRESS\r\nReturn: ES = segment of virtual screen\r\n",
      "FD": " DOS v2.11-2.13 - OEM FUNCTION\r\nReturn: AL = 00h if no OEM function handler installed (see AH=F8h\"OEM\")\r\n",
      "FE": " DoubleDOS - GIVE AWAY TIME TO OTHER TASKS\r\n\tAL = number of 55ms time slices to give away\r\n\nReturn: returns after giving away time slices\r\n",
      "FF": " Rational Systems DOS/4GW - ???\r\n\tDH = 17h\r\n\n\tAL = ???\r\n\n\tDL = ???\r\n\nReturn: ???\r\n"
    },
    "AX": {
      "2501": " Phar Lap 386/DOS-Extender - RESET DOS EXTENDER DATA STRUCTURES\r\n\tSS = application's original SS or DS (FlashTek X-32VM)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    caller is operating on X-32 stack (FlashTek X-32VM)\r\n",
      "2502": " Phar Lap 386/DOS-Extender - GET PROTECTED-MODE INTERRUPT VECTOR\r\n\tCL = interrupt number\r\n\nReturn: CF clear\r\n\n\tES:EBX = CS:EIP of protected-mode interrupt handler\r\n",
      "2503": " Phar Lap 386/DOS-Extender - GET REAL-MODE INTERRUPT VECTOR\r\n\tCL = interrupt number\r\n\nReturn: CF clear\r\n\n\tEBX = CS:IP of real-mode interrupt handler\r\n",
      "2504": " Phar Lap 386/DOS-Extender - SET PROTECTED-MODE INTERRUPT VECTOR\r\n\tCL = interrupt number\r\n\n\tDS:EDX = CS:EIP of protected-mode interrupt handler\r\n\nReturn: CF clear\r\n",
      "2505": " Phar Lap 386/DOS-Extender - SET REAL-MODE INTERRUPT VECTOR\r\n\tCL = interrupt number\r\n\n\tEBX = CS:IP of real-mode interrupt handler\r\n\nReturn: CF clear\r\n",
      "2506": " Phar Lap 386/DOS-Extender - SET INT TO ALWAYS GAIN CNTRL IN PR. MODE\r\n\tCL = interrupt number\r\n\n\tDS:EDX = CS:EIP of protected-mode interrupt handler\r\n\nReturn: CF clear\r\n",
      "2507": " Phar Lap 386/DOS-Extender - SET REAL- & PROTECTED-MODE INT VECTORS\r\n\tCL = interrupt number\r\n\n\tDS:EDX = CS:EIP of protected-mode interrupt handler\r\n\n\tEBX = CS:IP of real-mode interrupt handler\r\n\nReturn: CF clear\r\n",
      "2508": " Phar Lap 386/DOS-Extender - GET SEGMENT LINEAR BASE ADDRESS\r\n\tBX = segment selector\r\n\nReturn: CF clear if successful\r\n\n\t    ECX = linear base address of segment\r\n\n\tCF set if invalid segment selector\r\n",
      "2509": " FlashTek X-32VM - GET SYSTEM SEGMENTS AND SELECTORS\r\nReturn: CF clear\r\n\n\tEAX high word = default DS\r\n\n\tAX = alias for 16-bit data segment\r\n\n\tBX = real mode code segment\r\n\n\tEDX high word = selector covering full 4GB address space\r\n\n\tDX = default SS\r\n\n\tESI high word = PSP selector\r\n\n\tSI = environment selector\r\n",
      "250A": " Phar Lap 386/DOS-Extender - MAP PHYSICAL MEMORY AT END OF SEGMENT\r\n\tES = segment selector in the Local Descriptor Table (LDT) of segment\r\n\n\t     to modify\r\n\n\tEBX = physical base address of memory to map (multiple of 4K)\r\n\n\tECX = number of physical 4K pages to map\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = 32-bit offset in segment of mapped memory\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficient memory to create page tables\r\n\n\t\t09h invalid segment selector\r\n",
      "250C": " Phar Lap 386/DOS-Extender - GET HARDWARE INTERRUPT VECTORS\r\nReturn: CF clear\r\n\n\tAL = base interrupt vector for IRQ0-IRQ7\r\n\n\tAH = base interrupt vector for IRQ8-IRQ15\r\n\n\tBL = interrupt vector for BIOS print screen function (Phar Lap only)\r\n",
      "250D": " Phar Lap 386/DOS-Extender - GET REAL-MODE LINK INFORMATION\r\nReturn: CF clear\r\n\n\tEAX = CS:IP of real-mode callback procedure (see #01358) that will\r\n\n\t\t  call through from real mode to a protected-mode routine\r\n\n\tEBX = 32-bit real-mode address of intermode call data buffer\r\n\n\tECX = size in bytes of intermode call data buffer\r\n\n\tES:EDX = protected-mode address of intermode call data buffer\r\n",
      "250E": " Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE\r\n\tEBX = CS:IP of real-mode procedure to call\r\n\n\tECX = number of two-byte words to copy from protected-mode stack\r\n\n\t      to real-mode stack\r\n\nReturn: CF clear if successful\r\n\n\t    all segment registers unchanged\r\n\n\t    all general registers contain values set by real-mode procedure\r\n\n\t    all other flags set as they were left by real-mode procedure\r\n\n\t    stack unchanged\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t01h not enough real-mode stack space\r\n",
      "250F": " Phar Lap 386/DOS-Extender - CONVERT PROTECTED-MODE ADDRESS TO MS-DOS\r\n\tES:EBX = 48-bit protected-mode address to convert\r\n\n\tECX = 00000000h or length of data in bytes\r\n\nReturn: CF clear if successful (address < 1MB and contiguous)\r\n\n\t    ECX = 32-bit real-mode MS-DOS address\r\n\n\tCF set on error (address >= 1MB or not contiguous)\r\n\n\t    ECX = linear address\r\n",
      "2510": " Phar Lap 386/DOS-Extender - CALL REAL-MODE PROCEDURE, REGISTERS\r\n\tEBX = CS:IP of real-mode procedure to call\r\n\n\tECX = number of two-byte words to copy to protected-mode stack to\r\n\n\t      real-mode stack\r\n\n\tDS:EDX -> pointer to parameter block (see #01360)\r\n\nReturn: CF clear if successful\r\n\n\t    all segment registers unchanged,\r\n\n\t    EDX unchanged\r\n\n\t    all other general registers contain values set by real-mode proc\r\n\n\t    all other flags are set as they were left by real-mode procedure\r\n\n\t    real-mode register values are returned in the parameter block\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t01h not enough real-mode stack space\r\n",
      "2511": " Phar Lap 386/DOS-Extender - ISSUE REAL-MODE INTERRUPT\r\n\tDS:EDX -> parameter block (see #01361)\r\n\nReturn: all segment registers unchanged\r\n\n\tEDX unchanged\r\n\n\tall other registers contain values set by the real-mode int handler\r\n\n\tthe flags are set as they were left by the real-mode interrupt handler\r\n\n\treal-mode register values are returned in the parameter block\r\n",
      "2512": " Phar Lap 386/DOS-Extender - LOAD PROGRAM FOR DEBUGGING\r\n\tDS:EDX -> pointer to ASCIZ program name\r\n\n\tES:EBX -> pointer to parameter block (see #01363)\r\n\n\tECX = size in bytes of LDT buffer\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = number of segment descriptors in LDT\r\n\n\tCF set on error\r\n\n\t    EAX = error code (see #01362)\r\n",
      "2513": " Phar Lap 386/DOS-Extender - ALIAS SEGMENT DESCRIPTOR\r\n\tBX = segment selector of descriptor in GDT or LDT\r\n\n\tCL = access-rights byte for alias descriptor\r\n\n\tCH = use-type bit (USE16 or USE32) for alias descriptor\r\n\nReturn: CF clear if successful\r\n\n\t    AX = segment selector for created alias\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficient memory (can't grow LDT)\r\n\n\t\t09h invalid segment selector in BX\r\n",
      "2514": " Phar Lap 386/DOS-Extender - CHANGE SEGMENT ATTRIBUTES\r\n\tBX = segment selector of descriptor in GDT or LDT\r\n\n\tCL = new access-rights byte\r\n\n\tCH = new use-type bit (USE16 or USE32)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t09h invalid selector in BX\r\n",
      "2515": " Phar Lap 386/DOS-Extender - GET SEGMENT ATTRIBUTES\r\n\tBX = segment selector of descriptor in GDT or LDT\r\n\nReturn: CF clear if successful\r\n\n\t    CL = access-rights byte for segment\r\n\n\t    CH = use-type bit (USE16 or USE32)\r\n\n\tECX<16-31> destroyed\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t09h invalid segment selector in BX\r\n",
      "2516": " Phar Lap 386/DOS-Extender v2.2+ - FREE ALL MEMORY OWNED BY LDT\r\nReturn: CF clear\r\n",
      "2517": " Phar Lap 386/DOS-Extender v2.1c+ - GET INFO ON DOS DATA BUFFER\r\nReturn: CF clear\r\n\n\tES:EBX -> data buffer (protected mode address)\r\n\n\tECX -> data buffer (real mode address)\r\n\n\tEDX = size of data buffer in bytes\r\n",
      "2518": " Phar Lap 386/DOS-Extender 2.1c+ - SPECIFY HANDLER FOR MOVED SEGMENTS\r\n\tES:EBX -> function to call when a segment is moved\r\n\nReturn: CF clear\r\n\n\tES:EBX -> previous handler\r\n",
      "2519": " Phar Lap 386/DOS-Extender VMM - GET ADDITIONAL MEMORY ERROR INFO\r\nReturn: CF clear\r\n\n\tEAX = error code\r\n\n\t    0000h  no error\r\n\n\t    0001h  out of physical memory\r\n\n\t    0002h  out of swap space (unable to grow swap file)\r\n\n\t    0003h  out of LDT entries and unable to grow LDT\r\n\n\t    0004h  unable to change extended memory allocation mark\r\n\n\t    FFFFFFFFh\tpaging disabled\r\n",
      "251A": " Phar Lap 386/DOS-Extender VMM - LOCK PAGES IN MEMORY\r\n\tEDX = number of 4k pages to lock\r\n\n\tif BL = 00h\r\n\n\t    ECX = linear address of first page to lock\r\n\n\tif BL = 01h\r\n\n\t    ES:ECX -> pointer to first page to lock\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficient memory\r\n\n\t\t09h invalid address range\r\n",
      "251B": " Phar Lap 386/DOS-Extender VMM - UNLOCK PAGES\r\n\tEDX = number of pages to unlock\r\n\n\tif BL = 00h\r\n\n\t    ECX = linear address of first page to unlock\r\n\n\tif BL = 01h\r\n\n\t    ES:ECX -> pointer to first page to unlock\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t09h invalid address range\r\n",
      "251C": " Phar Lap 386/DOS-Extender VMM v2.1c+ - FREE PHYSICAL MEMORY PAGES\r\n\tBH = preservation flag (00h preserve contents, 01h discard contents)\r\n\n\tEDX = number of pages to free\r\n\n\tBL = address type\r\n\n\t    00h linear address\r\n\n\t\tECX = linear address of first page to be freed\r\n\n\t    01h pointer\r\n\n\t\tES:ECX -> first page to be freed\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h memory error, swap space full, no VMM or DPMI\r\n\n\t\t09h invalid address\r\n",
      "251D": " Phar Lap 386/DOS-Extender VMM v2.1c - READ PAGE-TABLE ENTRY\r\n\tBL = address type\r\n\n\t    00h linear address\r\n\n\t\tECX = linear address of page table entry to read\r\n\n\t    01h pointer\r\n\n\t\tES:ECX -> page table entry to read\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = contents of page table entry\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t09h invalid address or NOPAGE option set\r\n\n\t\t78h invalid under DPMI\r\n",
      "251E": " Phar Lap 386/DOS-Extender VMM v2.1c - WRITE PAGE-TABLE ENTRY\r\n\tBL = address type\r\n\n\t    00h linear address\r\n\n\t\tECX = linear address of page table entry to read\r\n\n\t    01h pointer\r\n\n\t\tES:ECX -> page table entry to read\r\n\n\tEDX = new value for page table entry\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t09h invalid address or NOPAGE option set\r\n\n\t\t82h not compatible with DPMI\r\n",
      "251F": " Phar Lap 386/DOS-Extender VMM - EXHANGE TWO PAGE-TABLE ENTRIES\r\n\tBL = address type\r\n\n\t    00h linear address\r\n\n\t\tECX = linear address of first page table entry\r\n\n\t\tEDX = linear address of second page table entry\r\n\n\t    01h pointer\r\n\n\t\tES:ECX -> first page table entry\r\n\n\t\tES:EDX -> second page table entry\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t09h invalid address or NOPAGE option set\r\n\n\t\t82h not compatible with DPMI\r\n",
      "2520": " Phar Lap 386/DOS-Extender VMM - GET MEMORY STATISTICS\r\n\tDS:EDX -> pointer to buffer at least 100 bytes in size (see #01364)\r\n\n\tBL = 0 (don't reset VM stats), 1 (reset VM stats)\r\n\nReturn: carry flag clear\r\n",
      "2521": " Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S EXTENDED MEM USAGE\r\n\tEBX = max 4k pages of physical extended memory which program may use\r\n\nReturn: CF clear if successful\r\n\n\t   EBX = maximum limit in pages\r\n\n\t   ECX = minimum limit in pages\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficient memory or -nopage switch used\r\n",
      "2522": " Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY ALTERNATE PAGE-FAULT HANDLR\r\n\tES:EBX -> alternate handler for page faults\r\n\nReturn: CF clear\r\n\n\tES:EBX -> previous page-fault handler\r\n",
      "2523": " Phar Lap 386/DOS-Ext VMM v2.2+ - SPECIFY OUT-OF-SWAP-SPACE HANDLER\r\n\t???\r\n\nReturn: ???\r\n",
      "2524": " Phar Lap 386/DOS-Ext VMM v2.2+ - INSTALL PAGE-REPLACEMENT HANDLERS\r\n\t???\r\n\nReturn: ???\r\n",
      "2525": " Phar Lap 386/DOS-Extender VMM - LIMIT PROGRAM'S CONVENT'L MEM USAGE\r\n\tEBX = limit in 4k pages of physical conventional memory which program\r\n\n\t      may use\r\n\nReturn: CF clear if successful\r\n\n\t    EBX = maximum limit in pages\r\n\n\t    ECX = minimum limit in pages\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficient memory or -nopage switch used\r\n",
      "2526": " Phar Lap 386/DOS-Extender - GET CONFIGURATION INFORMATION\r\n\t???\r\n\nReturn: ???\r\n",
      "2527": " Phar Lap 386/DOS-Extender VMM - EN/DISABLE STATE SAVE ON INTERRUPTS\r\n\tEBX = new status (00h disabled, 01h enabled)\r\n\nReturn: CF clear\r\n\n\tEBX = previous state save flag\r\n",
      "2528": " Phar Lap 386/DOS-Extender VMM - READ REGISTERS AFTER CTRL-C INT\r\n\tDS:EBX -> buffer for registers (see #01368)\r\n\nReturn: CF clear if successful\r\n\n\t    DS:EBX buffer filled\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t83h interrupt state save not enabled\r\n\n\t\t84h no active interrupt\r\n",
      "2529": " Phar Lap 386/DOS-Extender - LOAD FLAT MODEL .EXP or .REX FILE\r\n\t???\r\n\nReturn: ES:EBX -> parameter block (see #01369)\r\n\n\t???\r\n",
      "252A": " Phar Lap 386/DOS-Extender VMM - NEW LOAD PROGRAM FOR DEBUG\r\n\tDS:EDX -> ASCIZ program name\r\n\n\tES:EBX -> parameter block (see #01363)\r\n\n\tECX = size of LDT buffer in bytes\r\n\n\tESI = bit flags\r\n\n\t    bit 0: allow demand paging rather than loading entire program\r\n\n\t    bit 1: demand page from swap file rather than from .EXP\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = VMM handle or FFFFFFFFh if none\r\n\n\t    ECX = number of descriptors in LDT buffer\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t02h file error\r\n\n\t\t    EBX = file error code (see #01370)\r\n\n\t\t    ECX = DOS error code if EBX=1,2,3, or 8\r\n\n\t\t08h insufficient memory\r\n\n\t\t    EBX = memory error code (see #01371)\r\n\n\t\t80h LDT buffer too small\r\n\n\t\t87h called twice without intervening call to AX=2531h\r\n",
      "252B": " Phar Lap 386/DOS-Extender v4.1+ - MAP DATA FILE AT FILE OFFSET\r\n\tBH = 0Bh\r\n\n\tBL = subfunction\r\n\n\t    00h by linear address\r\n\n\t\tECX = linear address at which to map data file\r\n\n\t    01h by logical address\r\n\n\t\tES:ECX = logical address at which to map data file\r\n\n\tEDX = number of bytes to map\r\n\n\tDS:ESI -> mapping structure (see #01373)\r\n\n\tDS:EDI -> ASCIZ filename\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t0002h file error\r\n\n\t\t    ECX = phase (01h opening file, 02h seeking, 03h reading)\r\n\n\t\t    EDX = error code returned by DOS\r\n\n\t\t0009h invalid address\r\n\n\t\t0081h invalid parameters or 386|VMM not present\r\n\n\t\t0086h all 386|VMM file handles already in use\r\n",
      "252C": " Phar Lap 386/DOS-Ext VMM v3.0 - ADD UNMAPPED PAGES AT END OF SEGMENT\r\n\tBX = segment selector\r\n\n\tECX = number of 4K pages to add\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = offset in segment of beginning of unmapped pages\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficent memory\r\n\n\t\t09h invalid selector\r\n\n\t\t82h not supported by current DPMI\r\n",
      "252D": " Phar Lap 386/DOS-Extender VMM v2.3+ - CLOSE VMM FILE HANDLE\r\n\tEBX = VMM file handle\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code (81h invalid VMM handle)\r\n",
      "252E": " Phar Lap 386/DOS-Extender VMM v2.3+ - GET/SET VMM PARAMETERS\r\n\tCL = direction (00h get parameters, 01h set parameters)\r\n\n\tDS:EBX -> parameter buffer (see #01374)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code (81h bad parameter value)\r\n",
      "252F": " Phar Lap 386/DOS-Ext VMM v3.0 - WRITE RECORD TO VMM PAGE LOG FILE\r\n\tDS:EBX -> data to be written\r\n\n\tCX = size of data in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code (85h no page log file or not 386/VMM)\r\n",
      "2530": " Phar Lap 386/DOS-Ext VMM v2.3+ - SET SIZE OF BUFFER FOR DOS CALLS\r\n\tECX = size of data buffer in bytes (1024 to 65536)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t08h insufficient low memory\r\n\n\t\t81h invalid size\r\n",
      "2531": " Phar Lap 386/DOS-Extender VMM v3.0 - READ/WRITE LDT DESCRIPTOR\r\n\tBX = segment selector\r\n\n\tECX = direction (00h read, 01h write)\r\n\n\tDS:EDX -> 8-byte buffer for descriptor contents\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t81h invalid selector\r\n\n\t\t82h DPMI running, or not a code or data segment\r\n",
      "2532": " Phar Lap 386/DOS-Extender - GET EXCEPTION HANDLER VECTOR\r\n\tCL = exception number (00h-0Fh)\r\n\nReturn: CF clear if successful\r\n\n\t    ES:EBX = CS:EIP of current exception handler\r\n\n\tCF set on error (CL > 0Fh)\r\n",
      "2533": " Phar Lap 386/DOS-Extender - SET EXCEPTION HANDLER VECTOR\r\n\tCL = exception number (00h-0Fh)\r\n\n\tDS:EDX = CS:EIP of new exception handler\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error (CL > 0Fh)\r\n",
      "2534": " Phar Lap 386/DOS-Extender v3.0+ - GET INTERRUPT FLAG\r\nReturn: CF clear\r\n\n\tEAX = interrupt state (00h disabled, 01h enabled)\r\n",
      "2535": " Phar Lap 386/DOS-Extender v3.0+ - READ/WRITE SYSTEM REGISTERS\r\n\tEBX = direction (00h read registers, 01h write)\r\n\n\tDS:EDX -> system register record (see #01375)\r\n\nReturn: CF clear\r\n",
      "2536": " Phar Lap 386/DOS-Ext VMM v3.0+ - MIN/MAX EXTENDED/CONV MEMORY USAGE\r\n\tEBX = bit flags\r\n\n\t    bit 0: modifying conventional memory rather than extended memory\r\n\n\t    bit 1: setting maximum memory usage rather than minimum\r\n\n\tECX = new limit in 4K pages\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = new limit\r\n\n\tCF set on error\r\n\n\t    EAX = error code (08h memory error or -NOPAGE set)\r\n\n\t    EBX = maximum limit in pages\r\n\n\t    ECX = minimum limit in pages\r\n",
      "2537": " Phar Lap 386/DOS-Ext VMM v3.0 - ALLOCATE DOS MEMORY ABOVE DOS BUFFER\r\n\tBX = number of paragraphs to allocate\r\n\nReturn: CF clear if successful\r\n\n\t    AX = real-mode segment of allocated block\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t07h MS-DOS memory chain corrupted\r\n\n\t\t08h insufficient low memory\r\n\n\t    BX = size in paragraphs of largest free block\r\n",
      "2538": " Phar Lap 386/DOS-Ext VMM v3.0 - READ PROTMODE REGS AFTER SFTWARE INT\r\n\tDS:EBX -> buffer for registers (see #01368)\r\n\n\tECX = register record to retrieve\r\n\n\t    00h first interrupt state\r\n\n\t    01h next interrupt state\r\n\n\t\tEDX = handle for current interrupt state\r\n\nReturn: CF clear if successful\r\n\n\t    DS:EBX buffer filled\r\n\n\t    EDX = handle of current interrupt state\r\n\n\t    ESI = number of interrupt which occurred\r\n\n\tCF set on error\r\n\n\t    EAX = error code\r\n\n\t\t81h invalid handle in EDX\r\n\n\t\t83h register saving not enabled\r\n\n\t\t84h no more interrupt states\r\n",
      "2539": " Phar Lap 386/DOS-Ext VMM v3.0 - GET OFFSET OF .EXP FILE HEADER\r\n\tBX = MS-DOS file handle for open file\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = offset of .EXP header in file\r\n\n\tCF set on error\r\n\n\t    EAX = error code (02h file error)\r\n\n\t    EBX = file error code\r\n\n\t\t02h DOS error seeking\r\n\n\t\t03h DOS error reading\r\n\n\t\t04h invalid file type\r\n\n\t\t05h invalid file format\r\n\n\t    ECX = DOS error code if EBX=02h or 03h\r\n\n\tcurrent file position in file modified\r\n",
      "253A": " Phar Lap 386/DOS-Extender v3.0+ - INSTALL MOD. SEG FAILURE HANDLER\r\n\tES:EBX -> function to be called when INT 21/AH=4Ah is about to return\r\n\n\t\tan error\r\n\nReturn: CF clear\r\n\n\tES:EBX -> previous handler\r\n",
      "253B": " Phar Lap 386/DOS-Extender v3.0+ - JUMP TO REAL MODE CODE, NO CONTEXT\r\n\tDS:EBX -> buffer containing register contents (see #01368)\r\n\nReturn: never returns\r\n",
      "253C": " Phar Lap 386/DOS-Extender VMM v3.0+ - SHRINK 386|VMM SWAP FILE\r\nReturn: CF clear\r\n\n\tEAX = old size of swap file in bytes\r\n\n\tEBX = new size of swap file in bytes\r\n",
      "253D": " Phar Lap 386/DOS-Extender v4.0+ - READ/WRITE IDT DESCRIPTOR\r\n\tBL = interrupt number\r\n\n\tECX = direction (0 = read, 1 = write)\r\n\n\tDS:EDX -> 8-byte buffer for descriptor\r\n\nReturn: CF clear if successful\r\n\n\t    DS:EDX filled if reading\r\n\n\tCF set on error\r\n\n\t    EAX = error code (0082h if running under DPMI)\r\n",
      "253F": " Phar Lap 386/DOS-Extender v6.0+ - ALLOCATE LDT DESCRIPTOR\r\n\tBX = LDT descriptor to allocate (0000h for any)\r\n\n\t???\r\n\nReturn: ???\r\n",
      "2540": " Phar Lap 386/DOS-Extender v6.0+ - FORCE ALIAS OF SEGMENT\r\n\t???\r\n\nReturn: ???\r\n",
      "2544": " Phar Lap 386/DOS-Extender v6.0+ - FREE DLL\r\n\t???\r\n\nReturn: ???\r\n",
      "2545": " Phar Lap 386/DOS-Extender v6.0+ - GET/SET PROCEDURE ADDRESS\r\n\tECX = direction (00h get, 01h set)\r\n\n\t???\r\n\nReturn: ???\r\n",
      "2546": " Phar Lap 386/DOS-Extender v6.0+ - GET MODULE HANDLE\r\n\t???\r\n\nReturn: ???\r\n",
      "25C0": " Phar Lap 386/DOS-Extender - ALLOCATE MS-DOS MEMORY BLOCK\r\n\tBX = number of 16-byte paragraphs of MS-DOS memory requested\r\n\nReturn: CF clear if successful\r\n\n\t    AX = real-mode paragraph address of memory\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t07h MS-DOS memory control blocks destroyed\r\n\n\t\t08h insufficient memory\r\n\n\t    BX = size in paragraphs of largest available memory block\r\n",
      "25C1": " Phar Lap 386/DOS-Extender - RELEASE MS-DOS MEMORY BLOCK\r\n\tCX = real-mode paragraph address of memory block to free\r\n\nReturn: CF clear if successful\r\n\n\t    EAX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t07h MS-DOS memory control blocks destroyed\r\n\n\t\t09h invalid memory block address in CX\r\n",
      "25C2": " Phar Lap 386/DOS-Extender - MODIFY MS-DOS MEMORY BLOCK\r\n\tBX = new requested block size in paragraphs\r\n\n\tCX = real-mode paragraph address of memory block to modify\r\n\nReturn: CF clear if successful\r\n\n\t    EAX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t07h MS-DOS memory control blocks destroyed\r\n\n\t\t08h insufficient memory\r\n\n\t\t09h invalid memory block address in CX\r\n\n\t    BX = size in paragraphs of largest available memory block\r\n",
      "25C3": " Phar Lap 386/DOS-Extender - EXECUTE PROGRAM\r\n\tES:EBX -> pointer to parameter block (see #01377)\r\n\n\tDS:EDX -> pointer to ASCIZ program filename\r\n\nReturn: CF clear if successful\r\n\n\t    all registers unchanged\r\n\n\tCF set on error\r\n\n\t    EAX = error code (see #01376)\r\n",
      "2B01": " TAME v2.10+ - INSTALLATION CHECK\r\n\tCX = 5441h ('TA')\r\n\n\tDX = 4D45h ('ME')\r\n",
      "2D01": " PC-Mix - INSTALLATION CHECK\r\n\tCX = 7820h ('X ')\r\n\n\tDX = 6D69h ('MI')\r\n\nReturn: AL = 00h if installed\r\n",
      "3000": " CTask 2.0+ - INSTALLATION CHECK\r\n\tBX = 1234h\r\n\n\tDS:DX -> 8-byte version string (DX < FFF0h) \"CTask21\",00h for v2.1-2.2\r\n\nReturn: AL = DOS major version\r\n\n\tAH = DOS minor version\r\n\n\tCX:BX -> Ctask global data block\r\n",
      "3302": " DOS 3.x+ internal - GET AND SET EXTENDED CONTROL-BREAK CHECKING STATE\r\n\tDL = new state (00h for OFF, 01h for ON)\r\n\nReturn: DL = old state of extended BREAK checking\r\n",
      "3303": " DOS 3.4/4.0 - GET CURRENT CPSW STATE\r\nReturn: DL = current CPSW\r\n",
      "3304": " DOS 3.4/4.0 - SET CPSW STATE\r\n\tDL = new CPSW state\r\n\nReturn: nothing\r\n",
      "3305": " DOS 4.0+ - GET BOOT DRIVE\r\nReturn: DL = boot drive (1=A:,...)\r\n",
      "3306": " DOS 5+ - GET TRUE VERSION NUMBER\r\nReturn: BL = major version\r\n\n\tBH = minor version\r\n\n\tDL = revision (bits 2-0, all others 0)\r\n\n\tDH = version flags\r\n\n\t    bit 3: DOS is in ROM\r\n\n\t    bit 4: DOS is in HMA\r\n\n\tAL = FFh if true DOS version < 5.0\r\n",
      "3307": " Windows95 - SET/CLEAR DOS_FLAG\r\n\tDL = subfunction\r\n\n\t    00h clear bit 5 of \"DOS_FLAG\"\r\n\n\t    01h set bit 5 of \"DOS_FLAG\"\r\n\nReturn: ???\r\n",
      "3501": " FlashTek X-32VM - ALLOCATE PROTECTED-MODE SELECTOR\r\nReturn: CF clear if successful\r\n\n\t    BX = new selector\r\n\n\tCF set on error (no more selectors available)\r\n",
      "3502": " FlashTek X-32VM - DEALLOCATE PROTECTED-MODE SELECTOR\r\n\tBX = selector\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error (invalid selector)\r\n",
      "3503": " FlashTek X-32VM - SET SELECTOR BASE ADDRESS\r\n\tBX = selector\r\n\n\tECX = base address\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error (invalid selector)\r\n",
      "3504": " FlashTek X-32VM - GET SELECTOR BASE ADDRESS\r\n\tBX = selector\r\n\nReturn: CF clear if successful\r\n\n\t    ECX = absolute base address of selector\r\n\n\tCF set on error (invalid selector)\r\n",
      "3505": " FlashTek X-32VM - SET SELECTOR LIMIT\r\n\tBX = selector\r\n\n\tECX = desired limit\r\n\nReturn: CF clear if successful\r\n\n\t    ECX = actual limit set\r\n\n\tCF set on error (no more selectors available)\r\n",
      "350A": " FlashTek X-32VM - PHYSICAL ADDRESS MAPPING\r\n\tEBX = absolute physical address\r\n\n\tECX = size in bytes of area to map\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error (insufficient memory or service refused by DPMI host)\r\n",
      "350B": " FlashTek X-32VM - UPDATE AND RETURN AVAILABLE FREE MEMORY\r\n\tDS = default selector for DS\r\n\nReturn: CF clear\r\n\n\tEAX = maximum amount of memory which can be allocated via AX=350Ch\r\n",
      "350C": " FlashTek X-32VM - ALLOCATE A BLOCK OF MEMORY\r\n\tECX = size of block in bytes\r\n\n\tDS = default DS\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = near pointer to new block\r\n\n\t    EDX = new lowest legal value for stack\r\n\n\tCF set on error (requested size not multiple of 4K)\r\n",
      "350D": " FlashTek X-32VM - RESERVE BLOCK OF MEMORY FOR 32-BIT STACK\r\n\tEBX = current ESP value\r\n\n\tECX = size of block in bytes\r\n\n\tDS = default DS\r\n\nReturn: CF clear if successful\r\n\n\t    EBX = new value for ESP\r\n\n\t    EDX = suggested new limit for SS\r\n\n\tCF set on error\r\n",
      "3700": " DOS 2+ - \"SWITCHAR\" - GET SWITCH CHARACTER\r\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tDL = current switch character\r\n\n\t    FFh unsupported subfunction\r\n",
      "3701": " DOS 2+ - \"SWITCHAR\" - SET SWITCH CHARACTER\r\n\tDL = new switch character\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    FFh unsupported subfunction\r\n",
      "4300": " DOS 2+ - GET FILE ATTRIBUTES\r\n\tDS:DX -> ASCIZ filename\r\n\nReturn: CF clear if successful\r\n\n\t    CX = file attributes (see #01420)\r\n\n\t    AX = CX (DR DOS 5.0)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,02h,03h,05h) (see #01680 at AH=59h)\r\n",
      "4301": " DOS 2+ - \"CHMOD\" - SET FILE ATTRIBUTES\r\n\tCX = new file attributes (see #01420)\r\n\n\tDS:DX -> ASCIZ filename\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,02h,03h,05h) (see #01680 at AH=59h)\r\n",
      "4302": " MS-DOS 7 - GET COMPRESSED FILE SIZE\r\n\tDS:DX -> ASCIZ pathname for file or directory\r\n\nReturn: CF clear if successful\r\n\n\t    ??? = compressed size of file/directory in bytes\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "43FF": " MS-DOS 7.20 (Win98) - EXTENDED-LENGTH FILENAME OPERATIONS\r\n\tBP = 5053h ('PS')\r\n\n\tCL = function\r\n\n\t    39h \"mkdir\" create directory\r\n\n\t\tDS:DX -> ASCIZ pathname\r\n\n\t    56h rename file\r\n\n\t\tDS:DX -> ASCIZ filename of existing file (no wildcards)\r\n\n\t\tES:DI -> ASCIZ new filename (no wildcards)\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (03h,05h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4400": " DOS 2+ - IOCTL - GET DEVICE INFORMATION\r\n\tBX = handle\r\n\nReturn: CF clear if successful\r\n\n\t    DX = device information word (see #01423)\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4401": " DOS 2+ - IOCTL - SET DEVICE INFORMATION\r\n\tBX = handle (must refer to character device)\r\n\n\tDX = device information word (see #01423)\r\n\n\t    (DH must be zero for DOS version prior to 6.x)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4402": " Compaq AG1024.SYS - RGDI - GET DRIVER LOCATION\r\n\tBX = file handle for device \"$$$$RGDI\"\r\n\n\tCX = 0006h (size of returned data)\r\n\n\tDS:DX -> location record (see #01498)\r\n\nReturn: CF clear if successful\r\n\n\t    buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4403": " Compaq AG1024.SYS - RGDI - IOCTL OUTPUT\r\n\tBX = file handle referencing device \"$$$$RGDI\"\r\n\n\tDS:DX -> request packet (see #01528)\r\n\n\tCX ignored\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\t    data buffer filled (if applicable)\r\n\n\t    first word of request packet set to number of bytes of data\r\n\n\t      available (amount returned is smaller of this and requested\r\n\n\t      amount)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4404": " DOS 2+ - IOCTL - READ FROM BLOCK DEVICE CONTROL CHANNEL\r\n\tBL = drive number (00h = default, 01h = A:, etc.)\r\n\n\tCX = number of bytes to read\r\n\n\tDS:DX -> buffer\r\n\nReturn: CF clear if successful\r\n\n\t    AX = number of bytes actually read\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4405": " DOS 2+ - IOCTL - WRITE TO BLOCK DEVICE CONTROL CHANNEL\r\n\tBL = drive number (00h = default, 01h = A:, etc)\r\n\n\tCX = number of bytes to write\r\n\n\tDS:DX -> data to write\r\n\nReturn: CF clear if successful\r\n\n\t    AX = number of bytes actually written\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4406": " DOS 2+ - IOCTL - GET INPUT STATUS\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    AL = input status\r\n\n\t\t00h not ready (device) or at EOF (file)\r\n\n\t\tFFh ready\r\n\n\t    AH may be destroyed (refer to note)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4407": " DOS 2+ - IOCTL - GET OUTPUT STATUS\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    AL = input status\r\n\n\t\t00h not ready\r\n\n\t\tFFh ready\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,05h,06h,0Dh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4408": " DOS 3.0+ - IOCTL - CHECK IF BLOCK DEVICE REMOVABLE\r\n\tBL = drive number (00h = default, 01h = A:, etc)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = media type (0000h removable, 0001h fixed)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,0Fh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "4409": " DOS 3.1+ - IOCTL - CHECK IF BLOCK DEVICE REMOTE\r\n\tBL = drive number (00h = default, 01h = A:, etc)\r\n\nReturn: CF clear if successful\r\n\n\t    DX = device attribute word\r\n\n\t\tbit 15: drive is SUBSTituted\r\n\n\t\tbit 13: (DR DOS 3.41/5.0 local drives only) always set\r\n\n\t\t\tmedia ID needed\r\n\n\t\tbit 12: drive is remote\r\n\n\t\tbit  9: direct I/O not allowed\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,0Fh,15h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "440A": " DOS 3.1+ - IOCTL - CHECK IF HANDLE IS REMOTE\r\n\tBX = handle\r\n\nReturn: CF clear if successful\r\n\n\t    DX = attribute word (as stored in SFT)\r\n\n\t\tbit 15: set if remote\r\n\n\t\tbit 14: date/time not set on close\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,06h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "440B": " DOS 3.1+ - IOCTL - SET SHARING RETRY COUNT\r\n\tCX = pause between retries (default 1)\r\n\n\tDX = number of retries (default 3)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "440C": " DOS 3.2+ - IOCTL - GENERIC CHARACTER DEVICE REQUEST\r\n\tBX = device handle\r\n\n\tCH = category code (see #01545)\r\n\n\tCL = function number (see #01546)\r\n\n\tDS:DX -> parameter block (see #01547,#01548,#01549,#01550,#01551,#01552)\r\n\n\tSI = parameter to pass to driver (European MS-DOS 4.0, OS/2 comp box)\r\n\n\tDI = parameter to pass to driver (European MS-DOS 4.0, OS/2 comp box)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    DS:DX -> iteration count if CL=65h\r\n\n\t    SI = returned value (European MS-DOS 4.0, OS/2 comp box)\r\n\n\t    DI = returned value (European MS-DOS 4.0, OS/2 comp box)\r\n",
      "440D": " MS-DOS 7.0+ - GENERIC IOCTL - GET FIRST CLUSTER\r\n\tCX = 0871h / 4871h\r\n\n\t    (category code 08h for FAT12/16, 48h for FAT32; minor code 71h)\r\n\n\tBX = filename character set (see #01578)\r\n\n\tDS:DX -> ASCIZ pathname for file or directory\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (01h,02h,etc.) (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    DX:AX = first cluster number\r\n",
      "440E": " DOS 3.2+ - IOCTL - GET LOGICAL DRIVE MAP\r\n\tBL = drive number (00h=default,01h=A:,etc)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (01h,0Fh) (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    AL = 00h block device has only one logical drive assigned\r\n\n\t\t 1..26 the last letter used to reference the drive (1=A:,etc)\r\n",
      "440F": " DOS 3.2+ - IOCTL - SET LOGICAL DRIVE MAP\r\n\tBL = physical drive number (00h=default,01h=A:,etc))\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (01h,0Fh) (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    drive now responds to next logical drive number\r\n",
      "4410": " DOS 5+ - IOCTL - QUERY GENERIC IOCTL CAPABILITY (HANDLE)\r\n\tBX = handle for device\r\n\n\tCH = category code (see #01545)\r\n\n\tCL = function code (see #01546)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 0000h\tspecified IOCTL function is supported\r\n\n\tCF set on error\r\n\n\t    AL = 01h\tIOCTL capability not available\r\n",
      "4411": " DOS 5+ - IOCTL - QUERY GENERIC IOCTL CAPABILITY (DRIVE)\r\n\tBL = drive number\r\n\n\tCH = category code (see #01558)\r\n\n\tCL = function code (see #01559)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 0000h\tspecified IOCTL function is supported\r\n\n\tCF set on error\r\n\n\t    AL = 01h\tIOCTL capability not available\r\n",
      "4B05": " DOS 5+ - SET EXECUTION STATE\r\n\tDS:DX -> execution state structure (see #01625)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 0000h\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n",
      "5700": " DOS 2+ - GET FILE'S LAST-WRITTEN DATE AND TIME\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    CX = file's time (see #01665)\r\n\n\t    DX = file's date (see #01666)\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,06h) (see #01680)\r\n",
      "5701": " DOS 2+ - SET FILE'S LAST-WRITTEN DATE AND TIME\r\n\tBX = file handle\r\n\n\tCX = new time (see #01665)\r\n\n\tDX = new date (see #01666)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,06h) (see #01680)\r\n",
      "5702": " DOS 4.x only - GET EXTENDED ATTRIBUTES FOR FILE\r\n\tBX = file handle\r\n\n\tCX = size of result buffer or 0000h\r\n\n\tDS:SI -> EAP list (see #01667)\r\n\n\tES:DI -> buffer for returned EAV list (see #01670)\r\n\nReturn: CF clear if successful\r\n\n\t    CX = size of returned data\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n",
      "5703": " DOS 4.x only - GET EXTENDED ATTRIBUTE PROPERTIES\r\n\tBX = file handle\r\n\n\tCX = size of result buffer or 0000h\r\n\n\tES:DI -> result buffer\r\n\nReturn: CF clear if successful\r\n\n\t    CX = size of returned data\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\tES:DI -> zero word (DOS 4.0) if CX >= 2 on entry\r\n",
      "5704": " MS-DOS 7/Windows95 - GET LAST ACCESS DATE AND TIME\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    DX = last access date (see #01666)\r\n\n\t    CX = last access time (currently always 0000h)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "5705": " MS-DOS 7/Windows95 - SET LAST ACCESS DATE AND TIME\r\n\tBX = file handle\r\n\n\tCX = new last-access time (currently not supported, must be 0000h)\r\n\n\tDX = new last-access date (see #01666)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "5706": " MS-DOS 7/Windows95 - GET CREATION DATE AND TIME\r\n\tBX = file handle\r\n\nReturn: CF clear if successful\r\n\n\t    CX = creation time (see #01665)\r\n\n\t    DX = creation date (see #01666)\r\n\n\t    SI = number of 10-millisecond units past time in CX (0-199)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "5707": " MS-DOS 7/Windows95 - SET CREATION DATE AND TIME\r\n\tBX = file handle\r\n\n\tCX = new creation time (see #01665)\r\n\n\tDX = new creation date (see #01666)\r\n\n\tSI = new creation time: 10-millisecond units past time in CX (0-199)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "5D00": " DOS 3.1+ internal - SERVER FUNCTION CALL\r\n\tDS:DX -> DOS parameter list (see #01686)\r\n\n\tDPL contains all register values for a call to INT 21h\r\n\nReturn: as appropriate for function being called\r\n",
      "5D01": " DOS 3.1+ internal - COMMIT ALL FILES FOR SPECIFIED COMPUTER/PROCESS\r\n\tDS:DX -> DOS parameter list (see #01686), only computer ID and\r\n\n\t\t  process ID fields used\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\tCF clear if successful\r\n",
      "5D02": " DOS 3.1+ internal - SHARE.EXE - CLOSE FILE BY NAME\r\n\tDS:DX -> DOS parameter list (see #01686), only fields DX, DS,\r\n\n\t\t  computer ID, and process ID used\r\n\n\tDPL's DS:DX -> ASCIZ name of file to close\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\tCF clear if successful\r\n",
      "5D03": " DOS 3.1+ internal - SHARE.EXE - CLOSE ALL FILES FOR GIVEN COMPUTER\r\n\tDS:DX -> DOS parameter list (see #01686), only computer ID used\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\tCF clear if successful\r\n",
      "5D04": " DOS 3.1+ internal - SHARE.EXE - CLOSE ALL FILES FOR GIVEN PROCESS\r\n\tDS:DX -> DOS parameter list (see #01686), only computer ID and\r\n\n\t\t  process ID fields used\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\tCF clear if successful\r\n",
      "5D05": " DOS 3.1+ internal - SHARE.EXE - GET OPEN FILE LIST ENTRY\r\n\tDS:DX -> DOS parameter list (see #01686)\r\n\n\tDPL's BX = index of sharing record (see #01637 at AH=52h)\r\n\n\tDPL's CX = index of SFT in sharing record's SFT list\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI -> ASCIZ filename\r\n\n\t    BX = network machine number of SFT's owner\r\n\n\t    CX = number of locks held by SFT's owner\r\n\n\tCF set if either index out of range\r\n\n\t    AX = 0012h (no more files)\r\n",
      "5D06": " DOS 3.0+ internal - GET ADDRESS OF DOS SWAPPABLE DATA AREA\r\nReturn: CF set on error\r\n\n\t   AX = error code (see #01680)\r\n\n\tCF clear if successful\r\n\n\t    DS:SI -> nonreentrant data area (includes all three DOS stacks)\r\n\n\t\t(critical error flag is first byte) (see #01687)\r\n\n\t    CX = size in bytes of area which must be swapped while in DOS\r\n\n\t    DX = size in bytes of area which must always be swapped\r\n",
      "5D07": " DOS 3.1+ network - GET REDIRECTED PRINTER MODE\r\nReturn: DL = mode\r\n\n\t    00h redirected output is combined\r\n\n\t    01h redirected output in separate print jobs\r\n",
      "5D08": " DOS 3.1+ network - SET REDIRECTED PRINTER MODE\r\n\tDL = mode\r\n\n\t    00h redirected output is combined\r\n\n\t    01h redirected output placed in separate jobs, start new print job\r\n\n\t\tnow\r\n\nReturn:\tnothing\r\n",
      "5D09": " DOS 3.1+ network - FLUSH REDIRECTED PRINTER OUTPUT\r\nReturn:\tnothing\r\n",
      "5D0A": " DOS 3.1+ - SET EXTENDED ERROR INFORMATION\r\n\tDS:DX -> 11-word DOS parameter list (see #01686)\r\n\nReturn: nothing.  next call to AH=59h will return values from fields AX,BX,CX,\r\n\n\t  DX,DI, and ES in corresponding registers\r\n",
      "5D0B": " DOS 4.x only - internal - GET DOS SWAPPABLE DATA AREAS\r\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\tCF clear if successful\r\n\n\t    DS:SI -> swappable data area list (see #01689)\r\n",
      "5E00": " DOS 3.1+ network - GET MACHINE NAME\r\n\tDS:DX -> 16-byte buffer for ASCII machine name\r\n\nReturn: CF clear if successful\r\n\n\t    CH = validity\r\n\n\t\t00h name invalid\r\n\n\t\tnonzero valid\r\n\n\t\t    CL = NetBIOS number for machine name\r\n\n\t\t    DS:DX buffer filled with blank-paded name\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h) (see #01680 at AH=59h)\r\n",
      "5E01": " DOS 3.1+ network - SET MACHINE NAME\r\n\tCH = 00h undefine name (make it invalid)\r\n\n\t   <> 0\t define name\r\n\n\tCL = name number\r\n\n\tDS:DX -> 15-character blank-padded ASCIZ name\r\n",
      "5E02": " DOS 3.1+ network - SET NETWORK PRINTER SETUP STRING\r\n\tBX = redirection list index (see AX=5F02h)\r\n\n\tCX = length of setup string\r\n\n\tDS:SI -> setup string\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "5E03": " DOS 3.1+ network - GET NETWORK PRINTER SETUP STRING\r\n\tBX = redirection list index (see AX=5F02h)\r\n\n\tES:DI -> 64-byte buffer for setup string\r\n\nReturn: CF clear if successful\r\n\n\t    CX = length of setup string\r\n\n\t    ES:DI buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "5E04": " DOS 3.1+ network - SET PRINTER MODE\r\n\tBX = redirection list index (see AX=5F02h)\r\n\n\tDX = mode\r\n\n\t    bit 0: set if binary, clear if text (tabs expanded to blanks)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n",
      "5E05": " DOS 3.1+ network - GET PRINTER MODE\r\n\tBX = redirection list index (see AX=5F02h)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    DX = printer mode (see AX=5E04h)\r\n",
      "5F00": " DOS 3.1+ network - GET REDIRECTION MODE\r\n\tBL = redirection type\r\n\n\t    03h printer\r\n\n\t    04h disk drive\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    BH = redirection state\r\n\n\t\t00h off\r\n\n\t\t01h on\r\n",
      "5F01": " DOS 3.1+ network - SET REDIRECTION MODE\r\n\tBL = redirection type\r\n\n\t    03h printer\r\n\n\t    04h disk drive\r\n\n\tBH = redirection state\r\n\n\t    00h off\r\n\n\t    01h on\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n",
      "5F02": " DOS 3.1+ network - GET REDIRECTION LIST ENTRY\r\n\tBX = zero-based redirection list index\r\n\n\tCX = driver signature\r\n\n\t    0000h LANtastic\r\n\n\t    4E57h ('NW') NetWare\r\n\n\tDS:SI -> 16-byte buffer for ASCIZ local device name or drive letter\r\n\n\t\t  followed by colon\r\n\n\tES:DI -> 128-byte buffer for ASCIZ network name\r\n\nReturn: CF clear if successful\r\n\n\t    BH = device status\r\n\n\t\t00h valid\r\n\n\t\t01h invalid\r\n\n\t\t02h valid (connected from inside Windows for Workgroups v3.11)\r\n\n\t    BL = device type\r\n\n\t\t03h printer\r\n\n\t\t04h disk drive\r\n\n\t    CX = user data previously set with AX=5F03h\r\n\n\t    DS:SI and ES:DI buffers filled\r\n\n\t    DX,BP destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,12h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "5F03": " DOS 3.1+ network - REDIRECT DEVICE\r\n\tBL = device type\r\n\n\t    03h printer\r\n\n\t    04h disk drive\r\n\n\tCX = user data to save\r\n\n\t\t0000h for LANtastic\r\n\n\t\t4E57h (\"NW\") for NetWare 4.0 requester\r\n\n\tDS:SI -> ASCIZ local device name (16 bytes max)\r\n\n\tES:DI -> ASCIZ network name + ASCIZ password (128 bytes max total)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,03h,05h,08h,0Fh,12h) (see #01680 at AH=59h)\r\n",
      "5F04": " DOS 3.1+ network - CANCEL REDIRECTION\r\n\tDS:SI -> ASCIZ local device name or path\r\n\n\tCX = 4E57h (\"NW\") for NetWare 4.0 requester\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,03h,05h,08h,0Fh,12h) (see #01680 at AH=59h)\r\n",
      "5F05": " DOS 4.0+ network - GET EXTENDED REDIRECTION LIST ENTRY\r\n\tBX = redirection list index\r\n\n\tDS:SI -> buffer for ASCIZ source device name\r\n\n\tES:DI -> buffer for destination ASCIZ network path\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    AX = server's network process ID handle (10NET)\r\n\n\t    BH = device status flag (bit 0 clear if valid)\r\n\n\t    BL = device type (03h if printer, 04h if drive)\r\n\n\t    CX = stored parameter value (user data) from AX=5F03h\r\n\n\t    BP = NETBIOS local session number\r\n\n\t    DS:SI buffer filled\r\n\n\t    ES:DI buffer filled\r\n",
      "5F07": " DOS 5+ - ENABLE DRIVE\r\n\tDL = drive number (0=A:)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (0Fh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "5F08": " DOS 5+ - DISABLE DRIVE\r\n\tDL = drive number (0=A:)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (0Fh) (see #01680 at AH=59h/BX=0000h)\r\n",
      "6300": " DOS 3.2+ - GET DOUBLE BYTE CHARACTER SET LEAD-BYTE TABLE\r\nReturn: AL = error code\r\n\n\t    00h successful\r\n\n\t\tDS:SI -> DBCS table (see #01746)\r\n\n\t\tall other registers except CS:IP and SS:SP destroyed\r\n\n\t    FFh not supported\r\n",
      "6301": " DOS 2.25, DOS 3.2+ - SET KOREAN (HANGEUL) INPUT MODE\r\n\tDL = new mode\r\n\n\t    00h return only full characters on DOS keyboard input functions\r\n\n\t    01h return partially-formed (interim) characters also\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    FFh invalid mode\r\n",
      "6302": " DOS 2.25, DOS 3.2+ - GET KOREAN (HANGEUL) INPUT MODE\r\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tDL = current input mode\r\n\n\t\t    00h return only full characters (clears interim flag)\r\n\n\t\t    01h return partial characters (sets interim flag)\r\n\n\t    FFh not supported\r\n",
      "6523": " DOS 4.0+ - DETERMINE IF CHARACTER REPRESENTS YES/NO RESPONSE\r\n\tDL = character\r\n\n\tDH = second character of double-byte character (if applicable)\r\n\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\t    AX = type\r\n\n\t\t00h no\r\n\n\t\t01h yes\r\n\n\t\t02h neither yes nor no\r\n",
      "6601": " DOS 3.3+ - GET GLOBAL CODE PAGE TABLE\r\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    BX = active code page (see #01757)\r\n\n\t    DX = system code page (see #01757)\r\n",
      "6602": " DOS 3.3+ - SET GLOBAL CODE PAGE TABLE\r\n\tBX = active code page (see #01757)\r\n\n\tDX = system code page (active page at boot time)\r\n\nReturn: CF set on error\r\n\n\t    AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    AX = EB41h (Novell NWDOS v7.0 when NLSFUNC not installed and\r\n\n\t\t  request was for previously-active code page)\r\n",
      "6C00": " DOS 4.0+ - EXTENDED OPEN/CREATE\r\n\tBL = open mode as in AL for normal open (see also AH=3Dh)\r\n\n\t    bit 7: inheritance\r\n\n\t    bits 4-6: sharing mode\r\n\n\t    bit 3 reserved\r\n\n\t    bits 0-2: access mode\r\n\n\t\t100 read-only, do not modify file's last-access time (DOS 7.0)\r\n\n\tBH = flags\r\n\n\t    bit 6 = auto commit on every write (see also AH=68h)\r\n\n\t    bit 5 = return error rather than doing INT 24h\r\n\n\t    bit 4 = (FAT32) extended size (allow 4GB files instead of 2GB)\r\n\n\tCX = create attribute (see #01769)\r\n\n\tDL = action if file exists/does not exist (see #01770)\r\n\n\tDH = 00h (reserved)\r\n\n\tDS:SI -> ASCIZ file name\r\n\nReturn: CF set on error\r\n\n\t   AX = error code (see #01680 at AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t   AX = file handle\r\n\n\t   CX = status (see #01768)\r\n",
      "6F00": " DOS 5+ ROM - GET ROM SCAN START ADDRESS\r\nReturn: CF clear\r\n\n\tAL = 00h\r\n\n\t    BX = current ROM scan starting segment if function supported\r\n",
      "6F01": " DOS 5+ ROM - SET ROM SCAN START ADDRESS\r\n\tBX = new ROM scan starting address\r\n\nReturn: CF clear\r\n\n\tAL = 00h\r\n",
      "6F02": " DOS 5+ ROM - GET EXCLUSION REGION LIST\r\n\tES:BX -> buffer for exclusion region list (see #01773)\r\n\nReturn: CF clear\r\n\n\tAL = 00h\r\n\n\tES:BX = 0000h:0000h on error, unchanged if buffer filled\r\n",
      "6F03": " DOS 5+ ROM - SET EXCLUSION REGION LIST\r\n\tDS:DX -> new exclusion region list (see #01773)\r\n\nReturn: CF clear\r\n\n\tAL = 00h\r\n",
      "710D": " Windows95 - RESET DRIVE\r\n\tCX = action (see #01777)\r\n\n\tDX = drive number\r\n\nReturn: CF clear\r\n",
      "7139": " Windows95 - LONG FILENAME - MAKE DIRECTORY\r\n\tDS:DX -> ASCIZ long directory name (including path)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "713A": " Windows95 - LONG FILENAME - REMOVE DIRECTORY\r\n\tDS:DX -> ASCIZ long name of directory to remove\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "713B": " Windows95 - LONG FILENAME - CHANGE DIRECTORY\r\n\tDS:DX -> ASCIZ long name of directory to make current\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "7141": " Windows95 - LONG FILENAME - DELETE FILE\r\n\tDS:DX -> ASCIZ long name of file to delete\r\n\n\tSI = wildcard and attributes flag\r\n\n\t\t0000h wildcards are not allowed, and search attributes are\r\n\n\t\t\tignored\r\n\n\t\t0001h wildcards are allowed, and only files with matching\r\n\n\t\t\tnames and attributes are deleted\r\n\n\tCL = search attributes\r\n\n\tCH = must-match attributes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "7143": " Windows95 - LONG FILENAME - EXTENDED GET/SET FILE ATTRIBUTES\r\n\tDS:DX -> ASCIZ filename\r\n\n\tBL = action\r\n\n\t    00h retrieve attributes\r\n\n\t\tReturn:\tCX = file attributes (see #01420)\r\n\n\t    01h set attributes\r\n\n\t\tCX = attributes\r\n\n\t    02h get physical size of compressed file\r\n\n\t\tReturn: DX:AX = actual disk usage of file, in bytes\r\n\n\t    03h set last write date/time\r\n\n\t\tDI = new last-write date (see #01666)\r\n\n\t\tCX = new last-write time (see #01665)\r\n\n\t    04h get last write date/time\r\n\n\t\tReturn:\tCX = last write time (see #01665)\r\n\n\t\t\tDI = last write date (see #01666)\r\n\n\t    05h set last access date\r\n\n\t\tDI = new last-access date (see #01666)\r\n\n\t    06h get last access date\r\n\n\t\tReturn:\tDI = last access date (see #01666)\r\n\n\t    07h set creation date/time\r\n\n\t\tDI = new creation date (see #01666)\r\n\n\t\tCX = new creation time (see #01665)\r\n\n\t\tSI = hundredths (10-millisecond units past time in CX, 0-199)\r\n\n\t    08h get creation date/time\r\n\n\t\tReturn:\tCX = creation time (see #01665)\r\n\n\t\t\tDI = creation date (see #01666)\r\n\n\t\t\tSI = hundredths (10-millisecond units past time in CX)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "7147": " Windows95 - LONG FILENAME - GET CURRENT DIRECTORY\r\n\tDL = drive number (00h = current, 01h = A:, etc.)\r\n\n\tDS:SI -> buffer for ASCIZ directory name\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "714E": " Windows95 - LONG FILENAME - FIND FIRST MATCHING FILE\r\n\tCL = allowable-attributes mask (see #01420 at AX=4301h)\r\n\n\t      (bits 0 and 5 ignored)\r\n\n\tCH = required-attributes mask (see #01420)\r\n\n\tSI = date/time format (see #01778)\r\n\n\tDS:DX -> ASCIZ filespec (both \"*\" and \"*.*\" match any filename)\r\n\n\tES:DI -> FindData record (see #01779)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = filefind handle (needed to continue search)\r\n\n\t    CX = Unicode conversion flags (see #01780)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "714F": " Windows95 - LONG FILENAME - FIND NEXT MATCHING FILE\r\n\tBX = filefind handle (from AX=714Eh)\r\n\n\tSI = date/time format (see #01778)\r\n\n\tES:DI -> buffer for FindData record (see #01779)\r\n\nReturn: CF clear if successful\r\n\n\t    AH = 4Fh (undocumented)\r\n\n\t    AL destroyed (becomes low byte of filefind handle in Win95B)\r\n\n\t    CX = Unicode conversion flags (see #01780)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "7156": " Windows95 - LONG FILENAME - RENAME FILE\r\n\tDS:DX -> ASCIZ old file or directory name (long names allowed)\r\n\n\tES:DI -> ASCIZ new name (long names allowed)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "7160": " Windows95 - LONG FILENAME - GET CANONICAL LONG FILENAME OR PATH\r\n\tCL = 02h\r\n\n\tCH = SUBST expansion flag\r\n\n\t    00h return a path containing true path for a SUBSTed drive letter\r\n\n\t    80h return a path containing the SUBSTed drive letter\r\n\n\tDS:SI -> ASCIZ short filename or path\r\n\n\tES:DI -> 261-byte buffer for canonicalized long name\r\n\nReturn: CF set on error\r\n\n\t    AX = error code\r\n\n\t\t02h invalid component in directory path or drive letter only\r\n\n\t\t03h malformed path or invalid drive letter\r\n\n\t    ES:DI buffer unchanged\r\n\n\tCF clear if successful\r\n\n\t    ES:DI buffer filled with qualified long name (can contain\r\n\n\t\t  lowercase letters)\r\n",
      "716C": " Windows95 - LONG FILENAME - CREATE OR OPEN FILE\r\n\tBX = access mode and sharing flags (see #01782,also AX=6C00h)\r\n\n\tCX = attributes\r\n\n\tDX = action (see #01781)\r\n\n\tDS:SI -> ASCIZ filename\r\n\n\tDI = alias hint (number to append to short filename for disambiguation)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = file handle\r\n\n\t    CX = action taken\r\n\n\t\t0001h file opened\r\n\n\t\t0002h file created\r\n\n\t\t0003h file replaced\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "71A0": " Windows95 - LONG FILENAME - GET VOLUME INFORMATION\r\n\tDS:DX -> ASCIZ root name (e.g. \"C:\\\")\r\n\n\tES:DI -> buffer for file system name\r\n\n\tCX = size of ES:DI buffer\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed (0000h and 0200h seen)\r\n\n\t    BX = file system flags (see #01783)\r\n\n\t    CX = maximum length of file name [usually 255]\r\n\n\t    DX = maximum length of path [usually 260]\r\n\n\t    ES:DI buffer filled (ASCIZ, e.g. \"FAT\",\"NTFS\",\"CDFS\")\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "71A1": " Windows95 - LONG FILENAME - \"FindClose\" - TERMINATE DIRECTORY SEARCH\r\n\tBX = filefind handle (from AX=714Eh)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t   AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "71A2": " Windows95 - internal - LONG FILENAME - FIND NEXT MATCHING FILE\r\n\tBX = filefind handle (from AX=714Eh)\r\n\n\tSI = date/time format (see #01778)\r\n\n\tES:DI -> buffer for FindData record (see #01779)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 71A2h\r\n\n\t    CX = Unicode conversion flags (see #01780)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "71A3": " Windows95 - internal\r\n\t???\r\n\nReturn: ???\r\n",
      "71A4": " Windows95 - internal\r\n\t???\r\n\nReturn: ???\r\n",
      "71A5": " Windows95 - internal\r\n\t???\r\n\nReturn: ???\r\n",
      "71A6": " Windows95 - LONG FILENAME - GET FILE INFO BY HANDLE\r\n\tBX = file handle\r\n\n\tDS:DX -> buffer for file information (see #01784)\r\n\n\tCF set\r\n\nReturn: CF clear if successful\r\n\n\t    file information record filled\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "71A7": " Windows95 - LONG FILENAME - DOS TIME TO FILE TIME\r\n\tBL = 01h\r\n\n\tCX = DOS time (see #01665)\r\n\n\tDX = DOS date (see #01666)\r\n\n\tBH = hundredths (10-millisecond units past time in CX)\r\n\n\tES:DI -> buffer for QWORD file time\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "71A8": " Windows95 - LONG FILENAME - GENERATE SHORT FILENAME\r\n\tDS:SI -> ASCIZ long filename (no path allowed!)\r\n\n\tES:DI -> buffer for ASCIZ short filename\r\n\n\tDH = short name's format\r\n\n\t    00h 11-char directory entry/FCB filename format\r\n\n\t    01h DOS 8.3\r\n\n\tDL = character sets\r\n\n\t    bits 7-4: short name's character set (see #01785)\r\n\n\t    bits 3-0: long name's character set (see #01785)\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t7100h if function not supported\r\n",
      "71A9": " Windows95 - LONG FILENAME - SERVER CREATE OR OPEN FILE\r\n\tBX = access mode and sharing flags (see #01782,also AX=6C00h)\r\n\n\tCX = attributes\r\n\n\tDX = action (see #01781)\r\n\n\tDS:SI -> ASCIZ filename\r\n\n\tDI = alias hint (number to append to short filename for disambiguation)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = global file handle\r\n\n\t    CX = action taken\r\n\n\t\t0001h file opened\r\n\n\t\t0002h file created\r\n\n\t\t0003h file replaced\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "71AA": " Windows95 - LONG FILENAME - QUERY SUBST\r\n\tBH = 02h\r\n\n\tBL = drive number (01h = A:, etc.)\r\n\n\tDS:DX -> buffer for ASCIZ pathname associated with drive letter\r\n\nReturn: CF clear if successful\r\n\n\t    DS:DX buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #01680)\r\n\n\t\t7100h if function not supported\r\n",
      "7302": " Windows95 - FAT32 - \"Get_ExtDPB\" - GET EXTENDED DPB\r\n\tDL = drive number (00h=default, 01h=A:, etc.)\r\n\n\tES:DI -> buffer for returned data (see #01786)\r\n\n\tCX = length of buffer (003Fh for Windows95)\r\n\n\tSI = signature (undocumented, must be F1A6h to get device driver\r\n\n\t      address and next-DBP pointer) (see #01787)\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t       0018h bad buffer length\r\n",
      "7303": " Windows95 - FAT32 - GET EXTENDED FREE SPACE ON DRIVE\r\n\tDS:DX -> ASCIZ string for drive (\"C:\\\" or \"\\\\SERVER\\Share\")\r\n\n\tES:DI -> buffer for extended free space structure (see #01789)\r\n\n\tCX = length of buffer for extended free space\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "7304": " Windows95 - FAT32 - Set DPB TO USE FOR FORMATTING\r\n\tDL = drive number (00h=default, 01h=A:, etc.)\r\n\n\tCX = size of buffer (must be at least 18h)\r\n\n\tES:DI -> buffer for Set_DPBforFormat structure (see #01790)\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI buffer updated\r\n\n\tCF set on error\r\n\n\t    AX = error code (18h = bad length in CX)\r\n",
      "7305": " Windows95 - FAT32 - EXTENDED ABSOLUTE DISK READ/WRITE\r\n\tCX = FFFFh\r\n\n\tDL = drive number (01h=A:, etc.)\r\n\n\tSI = read/write mode flags (see #01791)\r\n\n\tDS:BX -> disk I/O packet (see #02548 at INT 25)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "7734": " SCROLLit v1.7 - INSTALLATION CHECK\r\nReturn: DX = 3477h if installed\r\n\n\t    AX = segment of resident code\r\n",
      "8400": " European MS-DOS 4.0 - \"CREATMEM\" - CREATE A SHARED MEMORY AREA\r\n\tBX = size in bytes (0000h = 65536)\r\n\n\tCX = flags\r\n\n\t    bit 6: zero-initialize segment\r\n\n\tDS:DX -> ASCIZ name (must begin with \"\\SHAREMEM\\\")\r\n\nReturn: CF clear if successful\r\n\n\t    AX = segment address of shared memory global object\r\n\n\tCF set on error\r\n\n\t    AX = error code (06h,08h) (see #01680 at AH=59h/BX=0000h)\r\n",
      "8401": " European MS-DOS 4.0 - \"GETMEM\" - OBTAIN ACCESS TO SHARED MEMORY AREA\r\n\tCX = flags\r\n\n\t    bit 7: writable segment (ignored by MS-DOS 4.0)\r\n\n\tDS:DX -> ASCIZ name (must begin with \"\\SHAREMEM\\\")\r\n\nReturn: CF clear if successful\r\n\n\t    AX = segment address of shared memory global object\r\n\n\t    CX = size in bytes\r\n\n\tCF set on error\r\n\n\t    AX = error code (invalid name)\r\n",
      "8402": " European MS-DOS 4.0 - \"RELEASEMEM\" - FREE SHARED MEMORY AREA\r\n\tBX = handle (segment address of shared memory object)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (no such name)\r\n",
      "8E00": " European MS-DOS 4.0 - \"SETPRI\" - GET/SET PROCESS PRIORITY\r\n\tBH = 00h\r\n\n\tBL = action\r\n\n\t    00h set priority for command subtree\r\n\n\t    01h set priority for specified process only\r\n\n\tCX = Process ID\r\n\n\tDH = 00h\r\n\n\tDL = change in priority (00h to get priority)\r\n\nReturn: CF clear if successful\r\n\n\t    DL = process priority\r\n\n\t    DH destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h,no such process)(see #01680 at AH=59h)\r\n",
      "DF00": " Software Carousel - INSTALLATION CHECK\r\n\tDX = 534Ch (\"SL\")\r\n\n\tDI = 534Ch (\"SL\")\r\n\nReturn: AX = 00FFh if installed\r\n\n\t    ???\r\n",
      "DF01": " Software Carousel - SWITCH TO ANOTHER TASK\r\n\tBL = task number (00h = next task)\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,02h) (see #01813)\r\n",
      "DF02": " Software Carousel - KILL PROGRAM IN MEMORY PARTITION\r\n\tBL = task number\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,03h) (see #01813)\r\n",
      "DF03": " Software Carousel - GET PARTITION SIZE AND PROGRAM STATUS\r\n\tBL = task number\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t\tBL = partition state (00h no program running, 01h prog running)\r\n\n\t\tDX = partition size in KB\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h) (see #01813)\r\n",
      "DF04": " Software Carousel - GET PARTITION NAME\r\n\tBL = task number\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t\tCX = length of name (00h if default partition name)\r\n\n\t\tES:BX -> partition name (if CX nonzero)\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h) (see #01813)\r\n",
      "DF05": " Software Carousel - CHANGE PARTITION SIZE\r\n\tBL = task number\r\n\n\tDX = new size in KB\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,04h,05h) (see #01813)\r\n\n\tBX = minimum size allowed\r\n\n\tCX = maximum size available\r\n",
      "DF06": " Software Carousel - CHANGE PARTITION NAME\r\n\tBL = task number\r\n\n\tCX = length of new name (00h to use default, max 18h)\r\n\n\tDS:SI -> new name\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h) (see #01813)\r\n",
      "DF07": " Software Carousel - SEND COMMAND TO MEMORY SECTION\r\n\tBL = task number\r\n\n\tCX = length of command (max 8 chars)\r\n\n\tDS:SI -> command line\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,06h) (see #01813)\r\n",
      "DF08": " Software Carousel - SELECTIVELY ENABLE/DISABLE MENU AND SWITCHING\r\n\tBL = new state of keyboard (00h disabled, 01h enabled)\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n",
      "DF09": " Software Carousel - BOOT THE SYSTEM\r\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,03h) (see #01813)\r\n",
      "DF0A": " Software Carousel - GET MEMORY SIZE/PARTITION NUMBER OF CURRENT TASK\r\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t\tBL = task number\r\n\n\t\tDX = memory size in KB\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,03h) (see #01813)\r\n",
      "DF0B": " Software Carousel - SET TASK SWITCH CALLBACK\r\n\tBH = interrupt number or 00h\r\n\n\tBL = function number to invoke on partition switch\r\n\n\tCL = function number to call when it is safe for resident programs\r\n\n\t\tto perform DOS calls\r\n\n\tDS:DX -> FAR function to call if BH=00h\r\n\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n\n\t    FFh unsucessful\r\n\n\t\tAH = error code (01h,03h) (see #01813)\r\n",
      "DF0C": " Software Carousel - ENABLE DOS-CALL SAFETY NOTIFICATION\r\nReturn: AL = status\r\n\n\t    00h Carousel not running\r\n\n\t    01h successful\r\n",
      "E400": " OS/286, OS/386 - CHAIN TO REAL-MODE HANDLER\r\n\t???\r\n\nReturn: ???\r\n",
      "E402": " OS/286, OS/386 - SET PROTECTED-MODE TASK GATE\r\n\t???\r\n\nReturn: ???\r\n",
      "E403": " OS/286, OS/386 - REMOVE PROTECTED-MODE TASK GATE\r\n\t???\r\n\nReturn: ???\r\n",
      "E500": " OS/286, OS/386 - HEAP MANAGEMENT STRATEGY\r\n\t???\r\n\nReturn: ???\r\n",
      "E501": " OS/286, OS/386 - FORCE HEAP COMPACTION\r\n\t???\r\n\nReturn: ???\r\n",
      "EB00": " OS/386 VMM - GET A PAGE TABLE ENTRY BY LINEAR ADDRESS\r\n\t???\r\n\nReturn: ???\r\n",
      "EB02": " OS/386 VMM - GET A PAGE TABLE ENTRY BY 16-BIT SEGMENT:OFFSET\r\n\t???\r\n\nReturn: ???\r\n",
      "EB03": " OS/386 VMM - FREE MAPPED PAGES\r\n\t???\r\n\nReturn: ???\r\n",
      "EB04": " OS/386 VMM - GET A PAGE TABLE ENTRY BY 32-BIT SEGMENT:OFFSET\r\n\t???\r\n\nReturn: ???\r\n",
      "EB05": " OS/386 VMM - MAP PAGES\r\n\t???\r\n\nReturn: ???\r\n",
      "EB06": " OS/386 VMM - LOCK PAGES IN MEMORY\r\n\t???\r\n\nReturn: ???\r\n",
      "EB07": " OS/386 VMM - UNLOCK MEMORY PAGES\r\n\t???\r\n\nReturn: ???\r\n",
      "F400": " DoubleDOS - INSTALLATION CHECK/PROGRAM STATUS\r\nReturn: AL = program status\r\n\n\t    00h if DoubleDOS not present\r\n\n\t    01h if running in visible DoubleDOS partition\r\n\n\t    02h if running in the invisible DoubleDOS partition\r\n",
      "FF00": " Rational Systems DOS/4G - INSTALLATION CHECK\r\n\tDX = 0078h\r\n\nReturn: AL <> 00h if installed\r\n\n\t    GS = segment of kernel if nonzero\r\n"
    }
  },
  "22": " DOS 1+ - PROGRAM TERMINATION ADDRESS\r\n",
  "23": " DOS 1+ - CONTROL-C/CONTROL-BREAK HANDLER\r\n",
  "24": " DOS 1+ - CRITICAL ERROR HANDLER\r\n",
  "25": {
    "CX": {
      "FFFF": " DOS 3.31+ - ABSOLUTE DISK READ (32M-2047M hard-disk partition)\r\n\tAL = drive number (0=A, 1=B, etc)\r\n\n\tDS:BX -> disk read packet (see #02548)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AH = status (see #02547)\r\n\n\t    AL = error code (same as passed to INT 24 in DI)\r\n\n\t    AX = 0207h for FAT32 drive -- use INT 21/AX=7305h\r\n\n\tmay destroy all other registers except segment registers; Win9X always\r\n\n\t  sets SI to 0000h due to an apparent coding bug\r\n"
    }
  },
  "26": {
    "CX": {
      "FFFF": " DOS 3.31+ - ABSOLUTE DISK WRITE (32M-2047M hard-disk partition)\r\n\tAL = drive number (0=A, 1=B, etc)\r\n\n\tDS:BX -> disk write packet (see #02552)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AH = status (see #02547)\r\n\n\t    AL = error code (same as passed to INT 24 in DI)\r\n\n\tmay destroy all other registers except segment registers\r\n"
    }
  },
  "27": " DOS 1+ - TERMINATE AND STAY RESIDENT\r\n\tDX = number of bytes to keep resident (max FFF0h)\r\n\n\tCS = segment of PSP\r\n\nReturn: never\r\n",
  "28": " DOS 2+ - DOS IDLE INTERRUPT\r\n\tSS:SP = top of MS-DOS stack for I/O functions\r\n\nReturn: all registers preserved\r\n",
  "29": " DOS 2+ - FAST CONSOLE OUTPUT\r\n\tAL = character to display\r\n\nReturn: nothing\r\n\n\tBX may be destroyed by some versions of DOS 3.3\r\n",
  "2A": {
    "AH": {
      "80": " NETWORK - BEGIN DOS CRITICAL SECTION\r\n\tAL = critical section number (00h-0Fh) (see #02555)\r\n",
      "81": " NETWORK - END DOS CRITICAL SECTION\r\n\tAL = critical section number (00h-0Fh) (see #02555)\r\n",
      "82": " NETWORK - END DOS CRITICAL SECTIONS 0 THROUGH 7\r\n"
    }
  },
  "2B": " DOS 2+ - RESERVED\r\n",
  "2C": " DOS 2+ - RESERVED\r\n",
  "2D": {
    "AL": {
      "10": " Screen Thief v1.00 - FREE HIGH MEMORY BUFFERS\r\n\tAH = AMIS multiplex number for Screen Thief\r\n\nReturn: nothing\r\n"
    }
  },
  "2F": {
    "AX": {
      "0800": " DRIVER.SYS support - INSTALLATION CHECK\r\nReturn: AL = status\r\n\n\t    00h not installed, OK to install\r\n\n\t    01h not installed, not OK to install\r\n\n\t    FFh installed\r\n",
      "0801": " DRIVER.SYS support - ADD NEW BLOCK DEVICE\r\n\tDS:DI -> drive data table (see #02601,#02602,#02603)\r\n\nReturn: AX,BX,SI,ES destroyed\r\n",
      "0802": " DRIVER.SYS support - EXECUTE DEVICE DRIVER REQUEST\r\n\tES:BX -> device driver request header (see #02597)\r\n\nReturn: request header updated as per requested operation\r\n\n\tSTACK:\tWORD\toriginal flags from INT call (left by RETF in device\r\n\n\t\t\t  driver, at least in DOS 5.0-6.22)\r\n",
      "0803": " DOS 4.0+ DRIVER.SYS support - GET DRIVE DATA TABLE LIST\r\nReturn: DS:DI -> first drive data table in list (see #02601,#02602,#02603)\r\n",
      "1002": " Novell DOS 7+ FDOS EXTENSIONS - READ BUFFERS\r\n\tCH = FFh (pre-read required)\r\n\n\tCL = buffer type (here FAT, DIR, or DATA, see below)\r\n\n\tAH:DX = 24 bit sector number\r\n\nReturn:\tES:SI -> buffer control block\r\n",
      "1003": " Novell DOS 7+ FDOS EXTENSIONS - FLUSH BUFFERS\r\n\tBL = drive???\r\n\n\tBH = buffer type to flush (BF_ISFAT+BF_ISDIR+BF_ISDATA)\r\n\nReturn: nothing???\r\n",
      "1004": " Novell DOS 7+ FDOS EXTENSIONS - FREE FAT CHAIN\r\n\tBX = first block to release on current drive\r\n\nReturn: nothing\r\n",
      "1005": " Novell DOS 7+ FDOS EXTENSIONS - ALLOCATE CLUSTER\r\n\tBX = block from which to start search (e.g. current end of file)\r\n\n\t    0000h = start of disk\r\n\nReturn: AX or BX??? = allocated cluster (already marked as End of Chain)\r\n\n\t    or 0000h if none available\r\n",
      "1006": " Novell DOS 7+ FDOS EXTENSIONS - NEXT CLUSTER / READ FAT???\r\n\tBX = current cluster number\r\n\nReturn:\tAX or BX??? = next cluster in chain\r\n",
      "1007": " Novell DOS 7+ FDOS EXTENSIONS - UPDATE FAT ENTRY / WRITE FAT???\r\n\tBX = FAT entry to change\r\n\n\tDX = new value\r\n\nReturn:\tnothing\r\n",
      "1008": " Novell DOS 7+ FDOS EXTENSIONS - FIXUP CHECKSUMS / DIR UPDATE???\r\n\tBX = segment of directory buffer\r\n\n\tCX = cluster to fixup (0 = root)\r\n\n\tDI = directory entry index (truncated to cluster if subdirectory)\r\n\n\tBX:SI -> directory entry (single entry for hashing)\r\n\nReturn:\tnothing\r\n",
      "1009": " Novell DOS 7+ FDOS EXTENSIONS - DIRECTORY BUFFER INFO\r\nReturn: ES:DI -> 128-byte directory record buffer\r\n\n\tES:SI -> directory BCB structure (see #04101)\r\n",
      "1200": " DOS 3.0+ internal - INSTALLATION CHECK\r\nReturn: AL = FFh (for compatibility with other INT 2F functions)\r\n",
      "1201": " DOS 3.0+ internal - CLOSE CURRENT FILE\r\n\tSS = DOS DS = DOS kernel data seg (must be using a DOS internal stack)\r\n\n\tSDA current SFT pointer -> SFT of file to close\r\n\nReturn: CF set on error\r\n\n\tES:DI -> SFT for file\r\n\n\tCX undefined (new reference count of SFT in many versions)\r\n\n\tBX destroyed\r\n",
      "1202": " DOS 3.0+ internal - GET INTERRUPT ADDRESS\r\n\tSTACK: WORD vector number\r\n\nReturn: ES:BX -> interrupt vector (DWORD containing handler's address)\r\n\n\tSTACK unchanged\r\n",
      "1203": " DOS 3.0+ internal - GET DOS DATA SEGMENT\r\nReturn: DS = data segment of IBMDOS.COM/MSDOS.SYS\r\n",
      "1204": " DOS 3.0+ internal - NORMALIZE PATH SEPARATOR\r\n\tSTACK: WORD character to normalize\r\n\nReturn: AL = normalized character (forward slash turned to backslash, all\r\n\n\t\t  others unchanged)\r\n\n\tZF set if path separator\r\n\n\tSTACK unchanged\r\n",
      "1205": " DOS 3.0+ internal - OUTPUT CHARACTER TO STANDARD OUTPUT\r\n\tSTACK: WORD character to output\r\n\nReturn: STACK unchanged\r\n",
      "1206": " DOS 3.0+ internal - INVOKE CRITICAL ERROR\r\n\tDI = error code\r\n\n\tBP:SI -> device driver header (see #01646)\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tSTACK: WORD value to be passed to INT 24 in AX\r\n\nReturn: AL = 0-3 for Abort, Retry, Ignore, Fail\r\n\n\tSTACK unchanged\r\n",
      "1207": " DOS 3.0+ internal - MAKE DISK BUFFER MOST-RECENTLY USED\r\n\tDS:DI -> disk buffer\r\n\nReturn: nothing\r\n",
      "1208": " DOS 3.0+ internal - DECREMENT SFT REFERENCE COUNT\r\n\tES:DI -> SFT\r\n\nReturn: AX = original value of reference count\r\n",
      "1209": " DOS 3.0+ internal - FLUSH AND FREE DISK BUFFER\r\n\tDS:DI -> disk buffer\r\n\nReturn: disk buffer marked unused, contents written to disk if buffer dirty\r\n",
      "120A": " DOS 3.0+ internal - PERFORM CRITICAL ERROR INTERRUPT\r\n\tDS = SS = DOS DS (must be using a DOS internal stack)\r\n\n\tSTACK: WORD extended error code\r\n\nReturn: AL = user response (0=ignore, 1=retry, 2=abort, 3=fail)\r\n\n\tCF clear if retry, set otherwise\r\n\n\tSTACK unchanged\r\n",
      "120B": " DOS 3.0+ internal - SIGNAL SHARING VIOLATION TO USER\r\n\tES:DI -> system file table entry for previous open of file\r\n\n\tSTACK: WORD extended error code (should be 20h--sharing violation)\r\n\nReturn: CF clear if operation should be retried\r\n\n\tCF set if operation should not be retried\r\n\n\t    AX = error code (20h) (see #01680 at INT 21/AH=59h/BX=0000h)\r\n\n\tSTACK unchanged\r\n",
      "120C": " DOS 3.0+ internal - OPEN DEVICE AND SET SFT OWNER/MODE\r\n\tSDA current SFT pointer -> SFT for file\r\n\n\tDS = DOS DS\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: ES, DI, AX destroyed\r\n",
      "120D": " DOS 3.0+ internal - GET DATE AND TIME\r\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: AX = current date in packed format (see #01666 at INT 21/AX=5700h)\r\n\n\tDX = current time in packed format (see #01665 at INT 21/AX=5700h)\r\n",
      "120E": " DOS 3.0+ internal - MARK ALL DISK BUFFERS UNREFERENCED\r\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: DS:DI -> first disk buffer\r\n",
      "120F": " DOS 3.0+ internal - MAKE BUFFER MOST RECENTLY USED\r\n\tDS:DI -> disk buffer\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: DS:DI -> next buffer in buffer list\r\n",
      "1210": " DOS 3.0+ internal - FIND UNREFERENCED DISK BUFFER\r\n\tDS:DI -> first disk buffer to check\r\n\nReturn: ZF clear if found\r\n\n\t    DS:DI -> first unreferenced disk buffer\r\n\n\tZF set if not found\r\n",
      "1211": " DOS 3.0+ internal - NORMALIZE ASCIZ FILENAME\r\n\tDS:SI -> ASCIZ filename to normalize\r\n\n\tES:DI -> buffer for normalized filename\r\n\nReturn: destination buffer filled with uppercase filename, with slashes turned\r\n\n\tto backslashes\r\n",
      "1212": " DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING\r\n\tES:DI -> ASCIZ string\r\n\nReturn: CX = length of string\r\n",
      "1213": " DOS 3.0+ internal - UPPERCASE CHARACTER\r\n\tSTACK: WORD character to convert to uppercase\r\n\nReturn: AL = uppercase character\r\n\n\tSTACK unchanged\r\n",
      "1214": " DOS 3.0+ internal - COMPARE FAR POINTERS\r\n\tDS:SI = first pointer\r\n\n\tES:DI = second pointer\r\n\nReturn: ZF set if pointers are equal, ZF clear if not equal\r\n\n\tCF clear if pointers equal, CF set if not\r\n",
      "1215": " DOS 3.0+ internal - FLUSH BUFFER\r\n\tDS:DI -> disk buffer\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tSTACK: WORD drives for which to skip buffer\r\n\n\t\tignore buffer if drive same as high byte, or bytes differ and\r\n\n\t\t  the buffer is for a drive OTHER than that given in low byte\r\n\nReturn: STACK unchanged\r\n",
      "1216": " DOS 3.0+ internal - GET ADDRESS OF SYSTEM FILE TABLE ENTRY\r\n\tBX = system file table entry number\r\n\nReturn: CF clear if successful\r\n\n\t    ES:DI -> system file table entry\r\n\n\t    BX = relative entry number in system file table containing entry\r\n\n\t    AX destroyed\r\n\n\tCF set if BX greater than FILES=\r\n",
      "1217": " DOS 3.0+ internal - GET CURRENT DIRECTORY STRUCTURE FOR DRIVE\r\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tSTACK: WORD drive (0 = A:, 1 = B:, etc)\r\n\nReturn: CF set on error\r\n\n\t    (drive > LASTDRIVE)\r\n\n\tCF clear if successful\r\n\n\t    DS:SI -> current directory structure for specified drive\r\n\n\tSTACK unchanged\r\n",
      "1218": " DOS 3.0+ internal - GET CALLER'S REGISTERS\r\nReturn: DS:SI -> saved caller's AX,BX,CX,DX,SI,DI,BP,DS,ES (on stack)\r\n",
      "1219": " DOS 3.0+ internal - SET DRIVE???\r\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tSTACK: WORD drive (0 = default, 1 = A:, etc)\r\n\nReturn: ???\r\n\n\tSTACK unchanged\r\n",
      "121A": " DOS 3.0+ internal - GET FILE'S DRIVE\r\n\tDS:SI -> filename\r\n\nReturn: AL = drive (0 = default, 1 = A:, etc, FFh = invalid)\r\n\n\tDS:SI -> filename without leading X: (if present)\r\n",
      "121B": " DOS 3.0+ internal - SET YEAR/LENGTH OF FEBRUARY\r\n\tCL = year - 1980\r\n\nReturn: AL = number of days in February\r\n",
      "121C": " DOS 3.0+ internal - CHECKSUM MEMORY\r\n\tDS:SI -> start of memory to checksum\r\n\n\tCX = number of bytes\r\n\n\tDX = initial checksum\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: AX, CX destroyed\r\n\n\tDX = checksum\r\n\n\tDS:SI -> first byte after checksummed range\r\n",
      "121D": " DOS 3.0+ internal - SUM MEMORY\r\n\tDS:SI -> memory to add up\r\n\n\tCX = 0000h\r\n\n\tDX = limit\r\n\nReturn: AL = byte which exceeded limit\r\n\n\tCX = number of bytes before limit exceeded\r\n\n\tDX = remainder after adding first CX bytes\r\n\n\tDS:SI -> byte beyond the one which exceeded the limit\r\n",
      "121E": " DOS 3.0+ internal - COMPARE FILENAMES\r\n\tDS:SI -> first ASCIZ filename\r\n\n\tES:DI -> second ASCIZ filename\r\n\nReturn: ZF set if filenames equivalent, ZF clear if not\r\n",
      "121F": " DOS 3.0+ internal - BUILD CURRENT DIRECTORY STRUCTURE\r\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tSTACK: WORD drive letter\r\n\nReturn: ES:DI -> current directory structure (will be overwritten by next call)\r\n\n\tSTACK unchanged\r\n",
      "1220": " DOS 3.0+ internal - GET JOB FILE TABLE ENTRY\r\n\tBX = file handle\r\n\nReturn: CF set on error\r\n\n\t    AL = 6 (invalid file handle)\r\n\n\tCF clear if successful\r\n\n\t    ES:DI -> JFT entry for file handle in current process\r\n",
      "1221": " DOS 3.0+ internal - CANONICALIZE FILE NAME\r\n\tDS:SI -> file name to be fully qualified\r\n\n\tES:DI -> 128-byte buffer for resulting canonical file name\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: (see INT 21/AH=60h)\r\n",
      "1222": " DOS 3.0+ internal - SET EXTENDED ERROR INFO\r\n\tSS = DOS data segment\r\n\n\tSS:SI -> 4-byte records\r\n\n\t\tBYTE\terror code, FFh = last record\r\n\n\t\tBYTE\terror class, FFh = don't change\r\n\n\t\tBYTE\tsuggested action, FFh = don't change\r\n\n\t\tBYTE\terror locus, FFh = don't change\r\n\n\tSDA error code set\r\n\nReturn: SI destroyed\r\n\n\tSDA error class, error locus, and suggested action fields set\r\n",
      "1223": " DOS 3.0+ internal - CHECK IF CHARACTER DEVICE\r\n\tDS = DOS DS\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tSDA+218h (DOS 3.10-3.30) = eight-character blank-padded name\r\n\n\tSDA+22Bh (DOS 4.0-6.0) = eight-character blank-padded name\r\n\n\tSDA file attribute field set\r\n\n\tdirection flag clear (i.e. CLD)\r\n\nReturn: CF set if no character device by that name found\r\n\n\tCF clear if found\r\n\n\t    BH bits 4-0 copied from low byte of device attribute word\r\n\n\t    BH bit 5 set, bits 7-6 clear\r\n",
      "1224": " DOS 3.0+ internal - SHARING RETRY DELAY\r\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: after delay set by INT 21/AX=440Bh, unless in server call\r\n\n\t  (INT 21/AX=5D00h)\r\n",
      "1225": " DOS 3.0+ internal - GET LENGTH OF ASCIZ STRING\r\n\tDS:SI -> ASCIZ string\r\n\nReturn: CX = length of string\r\n",
      "1226": " DOS 3.3+ internal - OPEN FILE\r\n\tCL = access mode\r\n\n\tDS:DX -> ASCIZ filename\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: CF set on error\r\n\n\t    AL = error code (see #01680 at INT 21/AH=59h/BX=0000h)\r\n\n\tCF clear if successful\r\n\n\t    AX = file handle\r\n",
      "1227": " DOS 3.3+ internal - CLOSE FILE\r\n\tBX = file handle\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: CF set on error\r\n\n\t    AL = 06h invalid file handle\r\n\n\tCF clear if successful\r\n",
      "1228": " DOS 3.3+ internal - MOVE FILE POINTER\r\n\tBP = 4200h, 4201h, 4202h (see INT 21/AH=42h)\r\n\n\tBX = file handle\r\n\n\tCX:DX = offset in bytes\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: as for INT 21/AH=42h\r\n",
      "1229": " DOS 3.3+ internal - READ FROM FILE\r\n\tBX = file handle\r\n\n\tCX = number of bytes to read\r\n\n\tDS:DX -> buffer\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\nReturn: as for INT 21/AH=3Fh\"DOS\"\r\n",
      "122A": " DOS 3.3+ internal - SET FASTOPEN ENTRY POINT\r\n\tBX = entry point to set (0001h or 0002h)\r\n\n\tDS:SI -> FASTOPEN entry point (see #02611,#02612)\r\n\n\t\t(entry point not set if SI = FFFFh for DOS 4.0+)\r\n\nReturn: CF set if specified entry point already set\r\n",
      "122B": " DOS 3.3+ internal - IOCTL\r\n\tBP = 44xxh\r\n\n\tSS = DOS DS (must be using a DOS internal stack)\r\n\n\tadditional registers as appropriate for INT 21/AX=44xxh\r\n\nReturn: as for INT 21/AH=44h\r\n",
      "122C": " DOS 3.3+ internal - GET DEVICE CHAIN\r\nReturn: BX:AX -> header of second device driver (NUL is first) in driver chain\r\n",
      "122D": " DOS 3.3+ internal - GET EXTENDED ERROR CODE\r\n\tSS = DOS DS\r\n\nReturn: AX = current extended error code\r\n",
      "122E": " DOS 4.0+ internal - GET OR SET ERROR TABLE ADDRESSES\r\n\tDL = subfunction\r\n\n\t    00h get standard DOS error table (see #02614)\r\n\n\t\tReturn: ES:DI -> error table\r\n\n\t\t\t\t (DOS 4: errors 00h-12h,50h-5Bh)\r\n\n\t\t\t\t (DOS 5: errors 00h-26h,4Fh,51h-59h)\r\n\n\t    01h set standard DOS error table\r\n\n\t\tES:DI -> error table\r\n\n\t    02h get parameter error table (errors 00h-0Ah)\r\n\n\t\tReturn: ES:DI -> error table\r\n\n\t    03h set parameter error table\r\n\n\t\tES:DI -> error table\r\n\n\t    04h get critical/SHARE error table (errors 13h-2Bh)\r\n\n\t\tReturn: ES:DI -> error table\r\n\n\t    05h set critical/SHARE error table\r\n\n\t\tES:DI -> error table\r\n\n\t    06h get ??? error table\r\n\n\t\tReturn: ES:DI -> error table or 0000h:0000h\r\n\n\t    07h set ??? error table\r\n\n\t\tES:DI -> error table\r\n\n\t    08h get error message retriever (see #02615)\r\n\n\t\tReturn: ES:DI -> FAR procedure to fetch error message\r\n\n\t    09h set ??? error table\r\n\n\t\tES:DI -> error table\r\n",
      "122F": " DOS 4.x internal - SET DOS VERSION NUMBER TO RETURN\r\n\tDX = DOS version number (0000h = return true DOS version)\r\n",
      "1400": " European MS-DOS 4.0 POPUP - \"CheckPu\" - INSTALLATION CHECK\r\nReturn: AX = FFFFh if installed\r\n\n\t    BX = maximum memory required to save screen and keyboard info\r\n\n\tCF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t0002h invalid function\r\n\n\t\t0004h unknown error\r\n",
      "1401": " European MS-DOS 4.0 POPUP - \"PostPu\" - OPEN/CLOSE POPUP SCREEN\r\n\tDL = function (00h open, 01h close)\r\n\n\tDH = wait flag\r\n\n\t    00h block until screen opens\r\n\n\t    01h return error if screen is not available\r\n\n\t    02h urgent--always open screen immediately\r\n\nReturn: CF clear if successful\r\n\n\t    BX = amount of memory needed to save screen and keyboard info,\r\n\n\t\t0000h if default save location can be used (only if DH was 02h)\r\n\n\tCF set on error\r\n",
      "1402": " European MS-DOS 4.0 POPUP - \"SavePu\" - SAVE POPUP SCREEN\r\n\tES:DI -> save buffer (0000h:0000h for default buffer in POPUP)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #02625)\r\n",
      "1403": " European MS-DOS 4.0 POPUP - \"RestorePu\" - RESTORE SCREEN\r\n\tES:DI -> buffer containing saved screen\r\n\n\t\t(0000h:0000h for default buffer in POPUP)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (see #02625)\r\n",
      "1607": " Rational Systems DOS/4GW - ???\r\n\tBX = 22C0h\r\n\n\t???\r\n\nReturn: ???\r\n",
      "160E": " MS-DOS 7 kernel - BOOT LOGO SUPPORT???\r\n\tBL = subfunction\r\n\n\t    00h get ???\r\n\n\t\tAX = state of flag manipulated by subfn 04h and 05h\r\n\n\t\t    0000h clear\r\n\n\t\t    FFFFh set\r\n\n\t\tDX = ??? (0000h)\r\n\n\t    01h link in INT 10h??? handlers\r\n\n\t    02h unlink INT 10h??? handlers\r\n\n\t    03h ???\r\n\n\t    04h set ??? flag\r\n\n\t    05h clear ??? flag\r\n\nReturn: AX = 0000h if supported\r\n\n\t    ???\r\n",
      "160F": " MS-DOS 7 kernel - GET/SET ??? HANDLER\r\n\tBL = subfunction\r\n\n\t    00h get ??? handler\r\n\n\t\tReturn: AX = 0000h if supported\r\n\n\t\t\t    CX:DX -> handler to which control is passed after\r\n\n\t\t\t\t      ??? executes\r\n\n\t\t\t   = 160Fh inside a Windows 95B DOS box\r\n\n\t    01h set ??? handler\r\n\n\t\tCX:DX -> new handler for ???\r\n\n\t\tReturn: AX = 0000h if supported\r\n",
      "1611": " MS-DOS 7 kernel - GET SHELL PARAMETERS\r\nReturn: AX = 0000h if supported\r\n\n\t    DS:DX -> primary shell's executable name\r\n\n\t    DS:SI -> prinary shell command line (counted string)\r\n\n\t    BH = ??? (00h)\r\n\n\t    BL = ??? (00h,40h)\r\n",
      "1612": " MS-DOS 7 kernel - GET ???\r\nReturn: AX = 0000h if supported\r\n\n\t    ES:BX -> DOS 7 kernel data (see #02641)\r\n",
      "1613": " MS-DOS 7 kernel - GET SYSTEM.DAT (REGISTRY FILE) PATHNAME\r\n\tES:DI -> buffer for full ASCIZ pathname to Windows95 SYSTEM.DAT\r\n\n\tCX = buffer size in bytes\r\n\nReturn: AX = 0000h if supported\r\n\n\t    ES:DI buffer filled\r\n\n\t    CX = number of bytes copied into buffer\r\n",
      "1614": " MS-DOS 7 kernel - SET SYSTEM.DAT (REGISTRY FILE) PATHNAME\r\n\tES:DI -> ASCIZ pathname to Windows95 SYSTEM.DAT\r\n\nReturn: AX = status\r\n\n\t    0000h if successful\r\n\n\t    1614h not supported\r\n\n\t    other: maximum length of pathname (004Eh for v4.00.950)\r\n",
      "1686": " DOS Protected-Mode Interface - DETECT MODE\r\nReturn: AX = 0000h if operating in protected mode under DPMI (INT 31 available)\r\n\n\tAX nonzero if in real/V86 mode or no DPMI (INT 31 not available)\r\n",
      "1687": " DOS Protected-Mode Interface - INSTALLATION CHECK\r\nReturn: AX = 0000h if installed\r\n\n\t    BX = flags\r\n\n\t\tbit 0: 32-bit programs supported\r\n\n\t    CL = processor type (02h=80286, 03h=80386, 04h=80486)\r\n\n\t    DH = DPMI major version\r\n\n\t    DL = two-digit DPMI minor version (binary)\r\n\n\t    SI = number of paragraphs of DOS extender private data\r\n\n\t    ES:DI -> DPMI mode-switch entry point (see #02718)\r\n\n\tAX nonzero if not installed\r\n",
      "168A": " DPMI 0.9+ - GET VENDOR-SPECIFIC API ENTRY POINT\r\n\tDS:(E)SI = selector:offset of ASCIZ vendor name (see #02719)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t       ES:(E)DI -> extended API entry point\r\n\n\t    8Ah unsuccessful\r\n",
      "1690": " MS-DOS 7 kernel - GET/SET ???\r\n\tES:BX -> ???\r\n\nReturn: ES:BX -> ??? data (see #02722)\r\n",
      "1A00": " AVATAR.SYS - INSTALLATION CHECK\r\n\tBX = 4156h ('AV')\r\n\n\tCX = 4154h ('AT')\r\n\n\tDX = 4152h ('AR')\r\n\nReturn: AL = FFh if installed\r\n\n\t    CF clear\r\n\n\t    BX = AVATAR protocol level supported\r\n\n\t    CX = driver type\r\n\n\t\t0000h AVATAR.SYS\r\n\n\t\t4456h DVAVATAR.COM inside DESQview window\r\n\n\t    DX = 0016h\r\n",
      "1A01": " DOS 4.0+ ANSI.SYS internal - GET/SET DISPLAY INFORMATION\r\n\tCL = function\r\n\n\t    7Fh for GET\r\n\n\t    5Fh for SET\r\n\n\tDS:DX -> parm block as for INT 21,AX=440Ch,CX=037Fh/035Fh respectively\r\n\nReturn: CF clear if successful\r\n\n\t    AX destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (many non-standard)\r\n",
      "1A02": " DOS 4.0+ ANSI.SYS internal - MISCELLANEOUS REQUESTS\r\n\tDS:DX -> parameter block (see #02735)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n",
      "1A3C": " AVATAR.SYS v0.11 - ???\r\n\t???\r\n\nReturn: CX = 0000h\r\n",
      "1A3E": " AVATAR.SYS v0.11 - ???\r\n\tCL = ???\r\n\n\tCH = ???\r\n\n\tDL = ???\r\n\n\tDH = ???\r\n\nReturn: CL = ???\r\n\n\tCH = ???\r\n\n\tDL = ???\r\n\n\tDH = ???\r\n",
      "1A42": " AVATAR Serial Dispatcher - INSTALL IRQ3 HANDLER\r\n\tBX = 4156h ('AV')\r\n\n\tES:DI -> FAR handler for serial port using IRQ3\r\n\n\tDS = data segment needed by handler\r\n\nReturn: AX = status/return value\r\n\n\t    0000h if no more room\r\n\n\t    1A42h if ASD not installed\r\n\n\t    else handle to use when uninstalling\r\n",
      "1A43": " AVATAR Serial Dispatcher - INSTALL IRQ4 HANDLER\r\n\tBX = 4156h ('AV')\r\n\n\tES:DI -> FAR handler for serial port using IRQ4\r\n\n\tDS = data segment needed by handler\r\n\nReturn: AX = status/return value\r\n\n\t    0000h if no more room\r\n\n\t    1A43h if ASD not installed\r\n\n\t    else handle to use when uninstalling\r\n",
      "1A44": " AVATAR.SYS v0.11+ - GET DATA SEGMENT\r\n\tBX = 4156h ('AV')\r\n\nReturn: AX = 0000h\r\n\n\tDS = data segment\r\n\n\tCX = size of data segment\r\n",
      "1A52": " AVATAR.SYS v0.11 - GET ???\r\n\tCX = size of buffer\r\n\n\tES:DI -> buffer\r\n\nReturn: ??? copied into user buffer\r\n",
      "1A53": " AVATAR.SYS v0.11 - ???\r\n\tCL = ??? (00h-05h)\r\n\n\t???\r\n\nReturn: ???\r\n",
      "1A62": " AVATAR Serial Dispatcher - UNINSTALL IRQ3 HANDLER\r\n\tBX = 4156h ('AV')\r\n\n\tCX = handle for IRQ routine returned by AX=1A42h\r\n",
      "1A63": " AVATAR Serial Dispatcher - UNINSTALL IRQ4 HANDLER\r\n\tBX = 4156h ('AV')\r\n\n\tCX = handle for IRQ routine returned by AX=1A43h\r\n",
      "1A72": " AVATAR.SYS v0.11 - GET ??? SIZE\r\nReturn: CX = maximum size of ???\r\n",
      "1A7B": " AVATAR.SYS v0.11 - ???\r\nReturn: AX = 0000h\r\n\n\tCX = 0000h\r\n",
      "1A7D": " AVATAR.SYS v0.11 - ???\r\nReturn: AX = ???\r\n",
      "1AA3": " ANSIPLUS v4.03+ - GET/SET ANSIPLUS INTERNAL VARIABLES\r\n\tBH = function\r\n\n\t    00h get current/default colors\r\n\n\t\tReturn: CH = default colors\r\n\n\t\t\tCL = current colors\r\n\n\t    01h set current/default colors\r\n\n\t\tCH = default colors (00h = leave unchanged)\r\n\n\t\tCL = current colors\r\n\n\t    02h get current subscreen region\r\n\n\t\tReturn: BH,BL = true screen rows,columns\r\n\n\t\t\tCH,CL = top left row,column of region\r\n\n\t\t\tDH,DL = bottom right row,column of region\r\n\n\t    03h set subscreen region\r\n\n\t\tCH,CL = top left row,column of region\r\n\n\t\tDH,DL = bottom right row,column of region\r\n\n\t    04h get driver features (bits 0-31)\r\n\n\t\tReturn: DX:CX = current feature bits\r\n\n\t    05h set driver features (bits 0-31)\r\n\n\t\tDX:CX = feature bits\r\n\n\t    06h get driver features (bits 32-63)\r\n\n\t\tReturn: DX:CX = current feature bits\r\n\n\t    07h set driver features (bits 32-63)\r\n\n\t\tDX:CX = feature bits\r\n\n\t    other: reserved for future use\r\n",
      "1AA4": " ANSIPLUS v4.02+ - GET/SET ANSIPLUS SMOOTH SCROLLING RATE\r\n\tBL = function\r\n\n\t    00h get scrolling rate\r\n\n\t    01h set scrolling rate\r\n\n\t\tBH = new minimum scrolling rate in scan lines per retrace\r\n\nReturn: BH = smooth scrolling rate\r\n",
      "1AA5": " ANSIPLUS v4.00+ - GET/SET ANSIPLUS CLIPBOARD\r\n\tDH = subfunction\r\n\n\t    00h get clipboard information\r\n\n\t    01h get clipboard text\r\n\n\t    02h set clipboard text\r\n\n\t    03h append text to clipboard\r\n\n\t    04h clear clipboard\r\n\n\t    05h paste clipboard to keyboard\r\n\n\tES:BX -> data area for subfunctions 01h, 02h, and 03h\r\n\n\tCX = size of data area (maximum size for subfunction 01h, actual size\r\n\n\t    to add to clipboard for subfunctions 02h and 03h)\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h unsupported subfunction (reduced capability driver)\r\n\n\t    02h insufficient space\r\n\n\t    A5h unsupported function (ANSIPLUS before v4.00)\r\n\n\tES:BX -> ANSIPLUS local clipboard data\r\n\n\tCX = number of bytes currently in local clipboard\r\n\n\tDX = maximum size of local clipboard\r\n",
      "1AA6": " ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS DRIVER\r\n\tBH = function\r\n\n\t    00h get hooked interrupts\r\n\n\t    01h set hooked interrupts mask\r\n\n\t\tBL = new interrupts mask (see #02737)\r\n\nReturn: BL = previous interrupts mask (see #02737)\r\n",
      "1AA7": " ANSIPLUS v4.00+ - ENABLE/DISABLE ANSIPLUS FEATURES\r\n\tBL = function\r\n\n\t    00h prevent scroll-back saves\r\n\n\t    01h enable scroll-back saves\r\n\n\t    02h disable key reprogramming and lock changes by escape sequences\r\n\n\t    03h enable key reprogramming by escape sequences\r\n\n\t    04h\tdisable and lock key stacking changes by escape sequences\r\n\n\t    05h allow key stacking by escape sequences\r\n\nReturn: nothing\r\n",
      "1AA8": " ANSIPLUS v3.10+ - GET NEXT ANSIPLUS SCROLLBACK LINE\r\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tES:BX -> screen line (character and attribute pairs)\r\n\n\t\tCX = length of line in bytes, 0000h if no more lines or\r\n\n\t\t      unsupported video mode\r\n\n\t    01h unsupported video mode active\r\n\n\t    02h screen currently scrolled back\r\n\n\t    03h reduced capability driver\r\n\n\t    A8h unsupported function (driver before v3.10)\r\n",
      "1AA9": " ANSIPLUS v3.10+ - GET ANSIPLUS SCROLLBACK INFORMATION\r\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t\tBX = current number of lines in scrollback buffer\r\n\n\t\tCX = number of bytes in one line\r\n\n\t    01h unsupported video mode active\r\n\n\t    02h screen currently scrolled back\r\n\n\t    03h reduced capability driver\r\n\n\t    A9h unsupported function (driver before v3.10)\r\n",
      "1AAA": " ANSIPLUS v3.01+ - GET/SET ANSIPLUS SCREEN SAVER BLANKING TIME\r\n\tBX = function\r\n\n\t    FFFFh to get current blanking time\r\n\n\t    other to set time\r\n\n\t\tCX = blanking time in clock ticks (0000h-7FFFh)\r\n\nReturn: BX = current blanking time\r\n\n\tCX = blanking time when last set\r\n",
      "1AAB": " ANSIPLUS v3.01+ - SET ANSIPLUS KEY REPEAT RATE\r\n\tBX = repeat rate in characters per second\r\n\n\t    0000h use BIOS repeat rate\r\n\nReturn: nothing\r\n",
      "1AAC": " ANSIPLUS v3.00+ - LOAD CHARACTER GENERATOR\r\n\tBH = number of bytes per character pattern\r\n\n\tBL = VGA/EGA character table to be loaded\r\n\n\tCX = number of characters to load\r\n\n\tDX = starting character code (offset into Map2 block)\r\n\n\tES:BP -> user character table to be loaded\r\n\nReturn: AX = 1100h\r\n",
      "1AAD": " AVATAR.SYS v0.11 - ???\r\n\tDX = 0000h\r\n\n\tCX = subfunction (00h-0Ch)\r\n\n\t???\r\n\nReturn: AX = 0000h if DX was nonzero\r\n\n\t???\r\n",
      "2300": " DR DOS 5.0 GRAFTABL - INSTALLATION CHECK\r\nReturn: AH = FFh\r\n",
      "2700": " DR DOS 6.0 TaskMAX - INSTALLATION CHECK\r\nReturn: AL = status\r\n\n\t    00h not installed\r\n\n\t    FFh installed\r\n",
      "2701": " DR DOS 6.0 TaskMAX - GET STATUS\r\nReturn: AX = maximum simultaneous tasks\r\n\n\tBX = index into TASK_IDS of current foreground task\r\n\n\tCX = currently-active tasks\r\n\n\tDX = version number (DL = major, DH = minor)\r\n\n\t    (DR DOS 6.0 = 0001h, Novell DOS 7 = 0002h)\r\n\n\tES:SI -> TASK_IDS\r\n\n\tES:DI -> name table (array of 8-byte names, NUL-terminated if <8 chars)\r\n",
      "2702": " DR DOS 6.0 TaskMAX - GET PER-TASK EMS LIMIT\r\nReturn: DX = maximum pages INT 67/AH=42h will report available\r\n",
      "2703": " DR DOS 6.0 TaskMAX - SET PER-TASK EMS LIMIT\r\n\tDX = maximum pages INT 67/AH=42h should report available\r\n\nReturn: DX = new maximum for reporting\r\n",
      "2704": " DR DOS 6.0 TaskMAX - REGISTER/UNREGISTER TASK MANAGER\r\n\tDL = subfunction\r\n\n\t    00h unregister task manager\r\n\n\t    01h register task manager\r\n\nReturn: DL = status\r\n\n\t    00h registered\r\n\n\t    01h unregistered\r\n",
      "2705": " DR DOS 6.0 TaskMAX - ENABLE/DISABLE DIRECT SWITCHING\r\n\tDL = subfunction\r\n\n\t    00h disable keystrokes for switching to next/prev/specified task\r\n\n\t    01h enable\r\n\nReturn: nothing\r\n",
      "2706": " DR DOS 6.0 TaskMAX - SWITCH TO SPECIFIED TASK\r\n\tDX = task index (see AX=2701h) of task to be activated\r\n\nReturn: DX = task index of previously-active task\r\n",
      "2707": " DR DOS 6.0 TaskMAX - CREATE NEW TASK\r\n\tDS:DX -> ASCIZ pathname of executable\r\n\n\tES:BX -> parameter block (see #02738)\r\n\n\tCX = number of ticks before automatic return to task manager\r\n\n\t\t(0000h = run until termination or explicitly switched)\r\n\nReturn: DX = new task's task index (FFFFh if task terminated)\r\n",
      "2708": " DR DOS 6.0 TaskMAX - DELETE TASK\r\n\tDX = task index\r\n\nReturn: DX = FFFFh (task deleted)\r\n",
      "2709": " DR DOS 6.0 TaskMAX - NAME TASK\r\n\tDX = task index\r\n\n\tDS:SI -> 8-byte name (8 NULs = remove name)\r\n\nReturn: AL = task flags\r\n\n\t    00h ID unused or task terminated\r\n\n\t    01h ID in use, task name table entry valid\r\n\n\t    81h ID in use, task name fixed\r\n\n\tBX = task ID\r\n\n\tES:DI -> name in task name table (see AX=2701h)\r\n",
      "270A": " DR DOS 6.0 TaskMAX - CONVERT TASK INDEX TO TASK ID\r\n\tDX = task index\r\n\nReturn: DX = task ID (FFFFh if index invalid)\r\n",
      "270B": " DR DOS 6.0 TaskMAX - CONVERT TASK ID TO TASK INDEX\r\n\tDX = task ID\r\n\nReturn: DX = task index (FFFFh if task not active)\r\n",
      "270C": " DR DOS 6.0 TaskMAX - CHECK OPEN FILES\r\n\tDX = task index\r\n\nReturn: AX = number of files currently open for specified task\r\n",
      "270D": " DR DOS 6.0 TaskMAX - CHECK IF TASK RUNNING PRIMARY COMMAND INTERPRETER\r\n\tDX = task index\r\n\nReturn: DX = status\r\n\n\t    0000h if primary command interpreter (COMMAND.COM, etc.) running\r\n\n\t    0001h if not in root shell for task\r\n",
      "270E": " DR DOS 6.0 TaskMAX - GET/SET TEXT PASTE LEAD-IN\r\n\tCX = length of string (max 15 keystrokes, 0000h to get current string)\r\n\n\tDS:SI -> pasting lead-in string (character/scan-code pairs)\r\n\nReturn: ES:DI -> current lead-in string\r\n",
      "270F": " DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE LEAD-IN\r\n\tCX = length of string (max 15 keystrokes, 0000h to get current string)\r\n\n\tDS:SI -> pasting lead-in string (character/scan-code pairs)\r\n\nReturn: ES:DI -> current lead-in string\r\n",
      "2710": " DR DOS 6.0 TaskMAX - GET/SET PASTE LINE TERMINATOR STRING\r\n\tCX = length of string (max 15 keystrokes, 0000h to get current string)\r\n\n\tDS:SI -> pasting terminator string (character/scan-code pairs)\r\n\nReturn: ES:DI -> current terminator string\r\n",
      "2711": " DR DOS 6.0 TaskMAX - GET/SET NUMERIC PASTE DECIMAL POINT\r\n\tDX = ASCII code for separator (FFFFh to get current)\r\n\nReturn: DL = current separator character\r\n",
      "2712": " DR DOS 6.0 TaskMAX - INITIATE EXPORTING TASK DATA\r\n\tDX = task index\r\n",
      "2713": " DR DOS 6.0 TaskMAX - INITIATE PASTE OPERATION\r\n\tDX = task index\r\n\n\tCX = paste mode\r\n\n\t    0000h alphanumeric\r\n\n\t    0001h numeric\r\n\n\t    0002h text\r\n",
      "2714": " DR DOS 6.0 TaskMAX - GET SWAP SPACE INFO\r\nReturn: CX = total KB of swap space\r\n\n\tDX = available KB of swap space\r\n",
      "2715": " DR DOS 6.0 TaskMAX - SWITCH TO TASK MANAGER\r\nReturn: only after calling task is again selected\r\n",
      "2716": " DR DOS 6.0 TaskMAX - GET PASTE BUFFER STATUS\r\nReturn: AX = 0000h if AX=2716h,AX=2717h,AX=2718h supported\r\n\n\t    CX = bytes in paste buffer\r\n\n\t    DX = current generation number (updated after every copy operation)\r\n",
      "2717": " DR DOS 6.0 TaskMAX - PASTE DATA DIRECTLY TO APPLICATION BUFFER\r\n\tCX = bytes in destination buffer\r\n\n\tES:DI -> destination buffer\r\n\nReturn: AX = 0000h if function supported\r\n\n\t    CX = bytes actually copied (FFFFh if buffer too small)\r\n\n\t    DX = current generation number for paste buffer\r\n",
      "2718": " DR DOS 6.0 TaskMAX - COPY DATA DIRECTLY INTO PASTE BUFFER\r\n\tCX = bytes in source buffer\r\n\n\tDS:SI -> source buffer (plain ASCII, lines terminated with CR LF)\r\n\nReturn: AX = 0000h if function supported\r\n\n\t    CX = bytes actually copied\r\n\n\t    DX = current generation number for paste buffer\r\n",
      "271C": " Novell DOS 7 TaskMGR - ???\r\n\tDX = ???\r\n\n\t    bit 0: ???\r\n\nReturn: ???\r\n\n\t---if DX bit 0 set---\r\n\n\tAX = 0031h\r\n\n\tCX = 0000h\r\n",
      "2781": " Novell DOS 7 TaskMGR - BEGIN CRITICAL SECTION???\r\nReturn: ???\r\n",
      "2782": " Novell DOS 7 TaskMGR - END CRITICAL SECTION???\r\nReturn: ???\r\n",
      "278F": " Novell DOS 7 TaskMGR - ??? API\r\n\tas for INT 2F/AX=2780h\r\n\nReturn: as for INT 2F/AX=2780h\r\n",
      "2E00": " Novell DOS 7 - GRAFTABL - INSTALLATION CHECK\r\nReturn: AH = FFh if installed\r\n",
      "3912": " Kingswood ANSI display driver - SET FLAGS\r\n\tBL = 04h\r\n\n\tCL = new flags (see #02745)\r\n\nReturn: AL = old flags\r\n\n\tSI,DI,DS,ES preserved\r\n",
      "4021": " Diamond Stealth64 Video - STLTH64.VXD - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "4022": " Diamond Stealth64 Video - STLTH64.VXD - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "4023": " Diamond Stealth64 Video - STLTH64.VXD - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "4027": " Diamond Stealth64 Video - DMSSTL.DRV - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "4040": " PharLap 286|DOS-Extender Lite v2.5 - ???\r\nReturn: BX:CX -> ???\r\n",
      "43E0": " DOS Protected Mode Services (DPMS) v1.0 - INSTALLATION CHECK\r\n\tBX = 0000h\r\n\n\tCX = 4450h ('DP')\r\n\n\tDX = 4D53h ('MS')\r\n\nReturn: AX = 0000h if installed\r\n\n\t    CF clear\r\n\n\t    ES:DI -> server structure (see #02791)\r\n\n\t    ES:BX -> registration structure (pre-NWDOS 7 beta spec) (see #02793)\r\n",
      "4601": " MS Windows WINOLDAP - SWITCHING ???\r\nReturn: ???\r\n",
      "4602": " MS Windows WINOLDAP - SWITCHING ???\r\nReturn: ???\r\n",
      "4A00": " DOS 5+ - FLOPPY-DISK LOGICAL DRIVE CHANGE NOTIFICATION\r\n\tCX = 0000h\r\n\n\tDH = new drive number\r\n\n\tDL = current drive number\r\n\nReturn: CX = FFFFh to skip \"Insert diskette for drive X:\" message\r\n",
      "4A01": " DOS 5+ - QUERY FREE HMA SPACE\r\nReturn: BX = number of bytes available in HMA (0000h if DOS not using HMA)\r\n\n\tES:DI -> start of available HMA area (FFFFh:FFFFh if not using HMA)\r\n",
      "4A02": " DOS 5+ - ALLOCATE HMA SPACE\r\n\tBX = number of bytes\r\n\nReturn: ES:DI -> start of allocated HMA block or FFFFh:FFFFh\r\n\n\tBX = number of bytes actually allocated (rounded up to next paragraph\r\n\n\t      for DOS 5.0 and 6.0)\r\n",
      "4A03": " Windows95 - DOS KERNEL - (DE)ALLOCATE HMA MEMORY BLOCK\r\n\tCX = segment of block's owner???\r\n\n\tDL = subfunction\r\n\n\t    00h allocate block\r\n\n\t\tBX = number of bytes\r\n\n\t\tReturn: DI=FFFFh if unable to allocate\r\n\n\t\t\tES:DI -> allocated block\r\n\n\t    01h resize block\r\n\n\t\tES:DI -> previously-allocated block\r\n\n\t\tBX = new size in bytes (must be less than original size???)\r\n\n\t\tReturn: DI=FFFFh if unable to allocate\r\n\n\t\t\tES:DI -> reallocated block\r\n\n\t\tNote:\tthe contents of the original block are NOT copied\r\n\n\t    02h free block???\r\n\n\t\tES:DI -> block to be freed\r\n",
      "4A04": " Windows95 - DOS KERNEL - GET START OF HMA MEMORY CHAIN\r\nReturn: AX = 0000h if function supported\r\n\n\t    ES:DI -> first HMA memory control block (see #02800)\r\n",
      "4A05": " DOS 5+ DOSSHELL - TASK SWITCHING API???\r\n\tSI = function\r\n\n\t    0000h reset???\r\n\n\t    0001h ???\r\n\n\t\tES:BP -> 80-byte buffer containing ???\r\n\n\t    0002h ???\r\n\n\t    0003h ???\r\n\n\t    0004h ???\r\n\n\t\tBL = ???\r\n\n\t    0005h ???\r\n\n\t    0006h get ???\r\n\n\t\tReturn: ES:SI -> ???\r\n\n\t    0007h get ???\r\n\n\t\tReturn: AX = ???\r\n\n\t    0008h get ???\r\n\n\t\tReturn: DX:AX -> ??? (internal control data of some kind)\r\n\n\t    0009h get ???\r\n\n\t\tReturn: ES:SI -> ??? (apparently identical to function 0006h)\r\n\n\t    000Ah ???\r\n\n\t\tBL = length of buffer\r\n\n\t\tES:BP -> buffer containing ???\r\n\n\t    000Bh get ???\r\n\n\t\tReturn: AX = ???\r\n\n\t    000Ch ???\r\n\n\t\tBL = ???\r\n\n\t\tReturn: if BL nonzero on entry\r\n\n\t\t\t    DX:AX -> ???\r\n\n\t\t\tif BL = 00h on entry\r\n\n\t\t\t    ES:SI -> ???\r\n",
      "4A06": " DOS 5+ - DOS SUPERVISOR \"REBOOT PANEL\" - ADJUST MEMORY SIZE\r\n\tDX = segment following last byte of conventional memory\r\n\nReturn: DX = segment following last byte of memory available for use by DOS\r\n",
      "4A16": " Windows95 - OPEN BOOT LOG\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh boot log file already open\r\n\n\t    else  DOS error code\r\n\n\tBX destroyed\r\n",
      "4A17": " Windows95 - WRITE TO BOOT LOG\r\n\tCX = number of bytes to write\r\n\n\tDS:DX -> message to write (must include CR-LF if it is desired)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh boot log file not open\r\n\n\t    else  DOS error code\r\n",
      "4A18": " Windows95 - CLOSE BOOT LOG\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh boot log file not open\r\n\n\t    else  DOS error code from closing file\r\n\n\tBX destroyed\r\n",
      "4A21": " Windows95 - ???\r\nReturn: AX destroyed\r\n",
      "4A31": " Windows95 - ???\r\n\tCL = new value for ???\r\n\n\tDS:SI -> BYTE to be set to CL\r\n\nReturn: nothing\r\n",
      "4A32": " Windows95 - PATCH ???\r\n\tBL = subfunction\r\n\n\t    00h get ???\r\n\n\t\tReturn: AX = flag: subfunction 04h has been used (0000h/FFFFh)\r\n\n\t\t\tDX = ??? (0000h/?)\r\n\n\t    01h\tpatch ??? in IO.SYS (segment 0070h)\r\n\n\t    02h unpatch ??? in IO.SYS\r\n\n\t    03h ???\r\n\n\t    04h set ???, then do subfunction 01h\r\n\n\t    05h unset ???, then do subfunction 02h\r\n\n\t    else\r\n\n\t\tReturn: nothing\r\n",
      "4A33": " Windows95 - CHECK MS-DOS VERSION 7\r\nReturn: AX = 0000h for MS-DOS 7.00+\r\n\n\t    (officially) BX,DX,SI,DS may be destroyed\r\n\n\t    (undoc) DS:DX -> ASCIZ primary shell executable name\r\n\n\t    (undoc) DS:SI -> CONFIG.SYS SHELL= command line (counted string)\r\n\n\t    (undoc) BH = ??? (0000h)\r\n\n\t    (undoc) BL = ??? (0000h)\r\n\n\tAX nonzero (usually 4A33h) if MS-DOS 6- or other DOS\r\n",
      "4B01": " DOS 5+ TASK SWITCHER - BUILD CALLOUT CHAIN\r\n\tCX:DX -> task switcher entry point (see #02819)\r\n\n\tES:BX = 0000h:0000h\r\n\nReturn: ES:BX -> callback info structure (see #02817) or 0000h:0000h\r\n",
      "4B02": " DOS 5+ TASK SWITCHER - INSTALLATION CHECK\r\n\tBX = 0000h\r\n\n\tES:DI = 0000h:0000h\r\n\nReturn: ES:DI = 0000h:0000h if task switcher not loaded\r\n\n\tES:DI -> task switcher entry point (see #02819) if loaded\r\n\n\t    AX = 0000h\r\n",
      "4B03": " DOS 5+ TASK SWITCHER - ALLOCATE SWITCHER ID\r\n\tES:DI -> task switcher entry point (see #02819)\r\n\nReturn: AX = 0000h\r\n\n\tBX = switcher ID (0001h-000Fh), or 0000h if no more available\r\n",
      "4B04": " DOS 5+ TASK SWITCHER - FREE SWITCHER ID\r\n\tBX = switcher ID\r\n\n\tES:DI -> task switcher entry point (see #02819)\r\n\nReturn: AX = 0000h\r\n\n\tBX = status\r\n\n\t    0000h successful\r\n\n\t    other error (invalid ID or ID not allocated)\r\n",
      "4B05": " DOS 5+ TASK SWITCHER - IDENTIFY INSTANCE DATA\r\n\tES:BX = 0000h:0000h\r\n\n\tCX:DX -> task switcher entry point (see #02819)\r\n\nReturn: ES:BX -> startup info structure (see #02822) or 0000h:0000h\r\n",
      "6400": " SCRNSAV2.COM - INSTALLATION CHECK\r\nReturn: AL = installation state\r\n\n\t    00h not installed\r\n\n\t    FFh installed\r\n",
      "96C7": " STRETCH - INSTALLATION CHECK\r\nReturn: AX = AAAAh if installed\r\n",
      "9800": " S3RMDRV.SYS - INSTALLATION CHECK / VERSION CHECK\r\n\tBX = function\r\n\n\t    0000h installation check\r\n\n\t\tReturn: AX = 524Dh ('RM') if installed\r\n\n\t    0001h get driver version\r\n\n\t\tReturn: AX = driver version (AH=major, AL=BCD minor)\r\n",
      "9803": " S3RMDRV.SYS - COPY ??? INTO USER BUFFER\r\n\tDX:BX -> 116-byte buffer for ASCIZ ???\r\n\nReturn: AX = 0000h\r\n\n\tDX:BX buffer filled with string stored in driver from its parameter\r\n\n\t  list when it was loaded\r\n",
      "AC00": " QRIP/TSR - GIVE CPU TO QRIP\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC01": " QRIP/TSR - CHANGE INTERNAL FLAGS\r\n\tDI = 1092h\r\n\n\tBX = flags to be turned on (see #02966)\r\n\n\tCX = flags to be turned off (see #02966)\r\n\nReturn: AX = 9142h if installed\r\n\n\t    DX = DOS-takeover flag (nonzero if QRIP able to take over DOS)\r\n\n\t    ---if DX nonzero---\r\n\n\t    BX = QRIP version number in hex (BH = major, BL = minor)\r\n\n\t    CX = new flags (see #02966)\r\n",
      "AC02": " QRIP/TSR - TURN OFF GRAPHICS SCREEN\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC03": " QRIP/TSR - TURN ON GRAPHICS SCREEN\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC04": " QRIP/TSR - OUTPUT STRING THROUGH QRIP\r\n\tDI = 1092h\r\n\n\tDX:BX -> string\r\n\n\tCX = length of string\r\n\nReturn: nothing\r\n",
      "AC05": " QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP\r\n\tDI = 1092h\r\n\n\tDX:BX -> ASCIZ string\r\n\nReturn: nothing\r\n",
      "AC06": " QRIP/TSR - RECEIVE CHARACTERS FROM QRIP\r\n\tDI = 1092h\r\n\nReturn: AX = character to send to BBS (0001h-00FFh) or special code (see #02967)\r\n\n\tBX = string-waiting flag\r\n\n\t    0001h entire string waiting to be sent to terminal (call AX=AC0Ch)\r\n\n\tCX = DX = AX\r\n",
      "AC07": " QRIP/TSR - GET FONT DIRECTORY\r\n\tDI = 1092h\r\n\nReturn: DX:BX -> 80-byte internal buffer containing ASCIZ font directory name\r\n",
      "AC08": " QRIP/TSR - GET ICON DIRECTORY\r\n\tDI = 1092h\r\n\nReturn: DX:BX -> 80-byte internal buffer containing ASCIZ icon directory name\r\n",
      "AC09": " QRIP/TSR - OUTPUT STRING THROUGH QRIP\r\n\tDI = 1092h\r\n\n\tDX:BX -> string\r\n\n\tCX = length of string\r\n\nReturn: AX = character to send to BBS (0001h-00FFh) or special code (see #02967)\r\n\n\tBX = string-waiting flag\r\n\n\t    0001h entire string waiting to be sent to terminal (call AX=AC0Ch)\r\n\n\tCX = DX = AX\r\n",
      "AC0A": " QRIP/TSR - OUTPUT NULL-TERMINATED STRING THROUGH QRIP\r\n\tDI = 1092h\r\n\n\tDX:BX -> ASCIZ string\r\n\nReturn: AX = character to send to BBS (0001h-00FFh) or special code (see #02967)\r\n\n\tBX = string-waiting flag\r\n\n\t    0001h entire string waiting to be sent to terminal (call AX=AC0Ch)\r\n\n\tCX = DX = AX\r\n",
      "AC0B": " QRIP/TSR - EXECUTE RIP \"END SCENE\" COMMAND\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC0C": " QRIP/TSR - GET STRING TO BE SENT TO BBS\r\n\tDI = 1092h\r\n\nReturn: AX = status\r\n\n\t    0000h nothing to be sent\r\n\n\t    0001h a string is waiting to be sent\r\n\n\t\tDX:BX -> string to be sent (may contain NULs)\r\n\n\t\tCX = length of string\r\n\n\t    0002h special code waiting (call AX=AC06h)\r\n",
      "AC0D": " QRIP/TSR - SET PROTECTED SCREEN AREA\r\n\tDI = 1092h\r\n\n\tCL = number of text lines at bottom of screen to protect (00h = off)\r\n\n\tBL = attribute with which to fill area (bit 7 = high-int. background)\r\n\nReturn: nothing\r\n",
      "AC0E": " QRIP/TSR - WRITE ASCIZ STRING IN PROTECTED AREA\r\n\tDI = 1092h\r\n\n\tDX:BX -> ASCIZ string to be written\r\n\n\tCL = column at which to begin writing\r\n\n\tCH = row number within protected area (00h = first line)\r\n\nReturn: nothing\r\n",
      "AC0F": " QRIP/TSR - SCROLL PROTECTED AREA\r\n\tDI = 1092h\r\n\n\tBH,BL = row,column of upper-left corner in protected area\r\n\n\tDH,DL = row,column of lower-right corner\r\n\n\tCL = number of lines to scroll up\r\n\nReturn: nothing\r\n",
      "AC10": " QRIP/TSR - SET OUTPUT COLOR FOR PROTECTED AREA\r\n\tDI = 1092h\r\n\n\tBL = new attribute (bit 7 set for high-intensity background)\r\n\nReturn: nothing\r\n",
      "AC11": " QRIP/TSR - CONVERT PROTECTED AREA TO ENTIRE SCREEN\r\n\tDI = 1092h\r\n\n\tBX = mode (0000h = normal protect, 0001h = allow full-screen access)\r\n",
      "AC12": " QRIP/TSR - BEGIN POPUP-WINDOW MODE\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC13": " QRIP/TSR - END POPUP-WINDOW MODE\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC14": " QRIP/TSR - SAVE GRAPHICS SCREEN AND SWITCH TO TEXT MODE\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC15": " QRIP/TSR - RESTORE GRAPHICS SCREEN\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC16": " QRIP/TSR - REPORT MODE CHANGE TO QRIP\r\n\tDI = 1092h\r\n\n\tBL = new mode\r\n\n\t    00h terminate key wait\r\n\n\t    01h status bar on\r\n\n\t    02h status bar off\r\n\n\t    03h VT-102 mode on\r\n\n\t    04h VT-102 mode off\r\n\n\t    05h doorway mode on\r\n\n\t    06h doorway mode off\r\n\n\t    07h hotkeys mode on\r\n\n\t    08h hotkeys mode off\r\n\n\t    09h tabkey mode on\r\n\n\t    0Ah tabkey mode off\r\n\nReturn: nothing\r\n",
      "AC17": " QRIP/TSR - CALL (EXECUTE) A RIP FILE\r\n\tDI = 1092h\r\n\n\tDX:BX -> ASCIZ filename for RIP file to be executed\r\n\nReturn: nothing\r\n",
      "AC18": " QRIP/TSR - SEND USER KEY TO QRIP\r\n\tDI = 1092h\r\n\n\tBX = key (00xxh is normal ASCII, xx00h is an extended key)\r\n\nReturn: nothing\r\n",
      "AC19": " QRIP/TSR - HANGUP\r\n\tDI = 1092h\r\n\nReturn: nothing\r\n",
      "AC1A": " QRIP/TSR - GET RIP_ENTER_BLOCK_MODE INFORMATION\r\n\tDI = 1092h\r\n\nReturn: AH = requested protocol (see #02968)\r\n\n\tAL = file type (see #02969)\r\n\n\tDX:BX -> ASCIZ filename or 0000h:0000h\r\n\n\tCX = length of filename\r\n",
      "AC1B": " QRIP/TSR - SET SYSTEM FONT SIZE\r\n\tDI = 1092h\r\n\n\tBX = font size (see #02970)\r\n\nReturn: nothing\r\n",
      "ACF0": " QRIP/TSR - INSTALLATION CHECK\r\n\tDI = 1092h\r\n\nReturn: AX = 9142h if installed\r\n\n\t    DX = DOS-takeover flag (nonzero if QRIP able to take over DOS)\r\n\n\t    ---if DX nonzero---\r\n\n\t    BX = QRIP version number in hex (BH = major, BL = minor)\r\n\n\t    CX = current flags (see AX=AC01h)\r\n",
      "ACFF": " QRIP/TSR - UNINSTALL\r\n\tDI = 1092h\r\n\nReturn: AX = status\r\n\n\t    0000h unable to remove (interrupt vector hooked by another prog)\r\n\n\t    0001h successful\r\n\n\t    0002h unable to take over DOS at this time (retry uninstall)\r\n",
      "AD00": " DOS 3.3+ DISPLAY.SYS internal - INSTALLATION CHECK\r\nReturn: AL = FFh if installed\r\n\n\t    BX = ??? (0100h for MS-DOS 3.3+)\r\n",
      "AD01": " DOS 3.3+ DISPLAY.SYS internal - SET ACTIVE CODE PAGE\r\n\tBX = new code page (see #01757 at INT 21/AX=6602h)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = 0001h\r\n\n\tCF set on error (unsupported code page)\r\n\n\t    AX = 0000h\r\n",
      "AD02": " DOS 3.3+ DISPLAY.SYS internal - GET ACTIVE CODE PAGE\r\nReturn: CF set if code page never set\r\n\n\t    AX = 0001h\r\n\n\t    BX = FFFFh (assume first hardware code page)\r\n\n\tCF clear if successful\r\n\n\t    BX = current code page (see #01757 at INT 21/AX=6602h)\r\n",
      "AD03": " DOS 3.3+ DISPLAY.SYS internal - GET CODE PAGE INFORMATION\r\n\tES:DI -> buffer for code page information (see #02971)\r\n\n\tCX = size of buffer in bytes\r\n\nReturn: CF set if buffer too small\r\n\n\tCF clear if successful\r\n\n\t    ES:DI buffer filled\r\n",
      "AD04": " DOS 4.x only DISPLAY.SYS internal - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "AD10": " DOS 5+ DISPLAY.SYS internal - ???\r\n\t???\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "AD40": " DOS 4.0+ - ???\r\n\tDX = ???\r\n\n\t???\r\n\nReturn: ???\r\n",
      "AD41": " Arabic/Hebrew DOS 5.0???+ - GET CURRENT FONTPAGE\r\n\t(CX = 0000h)\r\n\nReturn: CX = current fontpage\r\n",
      "AD42": " Arabic/Hebrew DOS 5.0???+ SET CURRENT FONTPAGE\r\n\tCX = fontpage (> 0)\r\n\nReturn: ???\r\n",
      "AD43": " Arabic/Hebrew DOS 5.0???+ - GET FONTPAGE STATUS???\r\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h-0Ah codepage info not found\r\n\n\t    0Bh bad codepage info file\r\n\n\t    0Ch font page not found or not available with codepage\r\n\n\t    else device prepare error\r\n",
      "B000": " DOS 3.3+ GRAFTABL.COM - INSTALLATION CHECK\r\nReturn: AL = status\r\n\n\t    00h not installed, OK to install\r\n\n\t    01h not installed, not OK to install\r\n\n\t    FFh installed\r\n",
      "B001": " DOS 3.3+ GRAFTABL.COM - GET GRAPHICS FONT TABLE\r\n\tDS:BX -> DWORD buffer for address of 8x8 font table\r\n\nReturn: buffer filled\r\n\n\tAL = FFh\r\n",
      "BC00": " Windows 3.0, DOS 5+ EGA.SYS - INSTALLATION CHECK\r\nReturn: AL = state\r\n\n\t    00h not installed, OK to install\r\n\n\t    01h not installed, not OK to install\r\n\n\t    FFh installed\r\n\n\t\tBX = 5456h (\"TV\")\r\n",
      "BC06": " MS Windows 3.0, DOS 5+ EGA.SYS - GET VERSION INFO\r\nReturn: BX = 5456h (\"TV\")\r\n\n\tCH = major version\r\n\n\tCL = minor version\r\n\n\tDL = revision\r\n",
      "C000": " TSENGP.COM - INSTALLATION CHECK\r\nReturn: AL = status\r\n\n\t    00h not installed, OK to install\r\n\n\t    FFh installed\r\n\n\t\tDS = segment of resident code\r\n",
      "C001": " AD-DOS - GET RESIDENT CODE SEGMENT\r\n\tES = 0000h\r\n\nReturn: AL = 00h if successful\r\n\n\t    ES = AD-DOS TSR Code Segment\r\n",
      "C002": " QMR - DISABLE QMR\r\nReturn: ES = QMR code segment\r\n\n\tAL destroyed\r\n",
      "C003": " QMR - ENABLE QMR\r\nReturn: ES = QMR code segment\r\n\n\tAL destroyed\r\n",
      "C004": " AD-DOS - GET MINUTES TO WAIT\r\nReturn: AL = 00h if successful\r\n\n\t    BX = minutes to wait before blanking screen\r\n",
      "C005": " AD-DOS - SET BLANKER STATUS\r\n\tBX = new state (0000h inactive, 0001h active) (default 0001h)\r\n\nReturn: AL = 00h if successful\r\n",
      "C006": " AD-DOS - GET BLANKER STATUS\r\nReturn: AL = 00h if successful\r\n\n\t    BX = current state of screen blanker (0000h inactive, 0001h active)\r\n",
      "C007": " AD-DOS - SET HOT KEY\r\n\tBX = hot key\r\n\n\tCL = hot key shift status\r\n\nReturn: AL = 00h if successful\r\n",
      "C008": " AD-DOS - GET CURRENT HOT KEY\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t\tBX = Hot Key\r\n\n\t\tCL = Hot Key Shift Status\r\n\n\t    0008h otherwise\r\n",
      "C009": " AD-DOS - UNBLANK MONITOR\r\nReturn: AL = 00h if successful\r\n",
      "C00A": " AD-DOS - ???\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t\tBH = ??\r\n\n\t\tBL = ??\r\n\n\t    000Ah failed\r\n",
      "C00B": " AD-DOS - ???\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    000Bh failed\r\n",
      "C00C": " AD-DOS - SET ??? INTERNAL FLAG TO 01h\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    000Ch failed\r\n",
      "C00E": " AD-DOS - SET PASSWORD STATUS\r\n\tBX = new state (0000h disabled, 0001h enabled)\r\n\nReturn: ???\r\n",
      "C00F": " AD-DOS - GET PASSWORD STATUS\r\nReturn: BX = current state (0000h disabled, 0001h enabled)\r\n",
      "C020": " AD-DOS - GET AND RESET VxD API STATUS\r\nReturn: AL = 00h if successful\r\n\n\t    BX = VxD API Status\r\n\n\t\t0000h no error\r\n\n\t\t0001h error\r\n\n\t\t0100h neither Windows 3.X enhanced mode nor Windows/386 2.x\r\n\n\t\t\t  is running\r\n\n\t\t0200h VM API entry point not found (VxD not installed)\r\n",
      "C04E": " Explosiv v2.00+ - NON-TSR EXECUTING CHECK\r\nReturn: AL = 4Fh if Explosiv is running but not memory-resident\r\n",
      "C050": " Explosiv v2.00+ - INSTALLATION CHECK\r\nReturn: AL = 51h if installed\r\n\n\t---v3.0+ ---\r\n\n\t    BX = interval in clock ticks\r\n\n\t    CH = animation display color (00h mono, 01h tinge, 02h color)\r\n\n\t    CL = animation delay factor\r\n\n\t    DH = animation parameters\r\n\n\t    DL = INT 10 checking (00h on, 01h off)\r\n\n\t    SI = number of bytes available for animation code\r\n\n\t    DI = display type (00h VGA, 01h EGA, 02h CGA, 03h HGC, 04h MDA)\r\n",
      "C052": " Explosiv v2.00+ - UNINSTALL\r\n\tDX:BX = address to return to on successful uninstall\r\n\nReturn: at specified address if successful\r\n\n\tAL = 53h on error\r\n",
      "C054": " Explosiv v3.0+ - UPDATE PARAMETERS\r\n\tBX = new interval in clock ticks\r\n\n\tCH = animation display color (00h mono, 01h tinge, 02h color)\r\n\n\tCL = animation delay factor\r\n\n\tDH = animation parameters\r\n\n\tDL = INT 10 checking (00h on, 01h off)\r\n",
      "C055": " Explosiv v2.x - SET BLANKING INTERVAL\r\n\tBX = new interval in clock ticks\r\n",
      "C056": " Explosiv v3.0+ - ENABLE/DISABLE EXPLOSIV\r\n\tBX = new state\r\n\n\t    0000h disabled\r\n\n\t    0100h enabled\r\n\n\t    0101h enabled, but never blank\r\n\n\t    0102h enabled, always blank\r\n",
      "C057": " Explosiv v2.x - SET ANIMATION DELAY FACTOR\r\n\tBL = delay factor\r\n",
      "C058": " Explosiv v3.0+ - LOAD NEW ANIMATION DISPLAY CODE\r\n\tBX = file handle for file containing display code\r\n\n\tCX = number of bytes to load\r\n\n\tDX = offset at which animation code should be loaded\r\n\nReturn: AL = status (see #03033)\r\n",
      "C059": " Explosiv v2.x - DISABLE EXPLOSIV\r\n",
      "C05A": " Explosiv v2.x - ENABLE EXPLOSIV\r\n\tBL = ???\r\n",
      "C05B": " Explosiv v2.x - CHANGE ANIMATION DISPLAY\r\n\tBL = animation display\r\n",
      "C05C": " Explosiv v2.x - SET INT 10 CHECKING\r\n\tBL = new state of INT 10 checking (00h enabled, 01h disabled)\r\n",
      "C700": " COLAP - INSTALLATION CHECK\r\n\tCX = 434Ch  \"CL\"\r\n\nReturn: AL = FFh if installed\r\n",
      "D000": " ZWmous - INSTALLATION CHECK\r\nReturn: AX = 5A57h (\"ZW\") if installed\r\n\n\t    BX = segment of resident code\r\n",
      "D201": " Quarterdeck RPCI - VIDRAM v5.0+ - INSTALLATION CHECK\r\n\tBX = 5649h (\"VI\")\r\n\n\tCX = 4452h (\"DR\")\r\n\n\tDX = 414Dh (\"AM\")\r\n\nReturn: BX = 4F4Bh (\"OK\")\r\n\n\tES:DI -> VIDRAM entry point (see #03080)\r\n",
      "D600": " VEDIT VSWAP - INSTALLATION CHECK\r\nReturn: AL = D6h if installed\r\n",
      "D601": " VEDIT VSWAP - ???\r\n\tBL = subfunction number???\r\n\nReturn: BL = return code ???\r\n\n\tES = resident portion's data??? segment\r\n\n\tDX = resident portion's code segment\r\n",
      "D602": " VEDIT VSWAP - EXEC PROGRAM WITH SWAP\r\n\tother registers set as for INT 21/AX=4B00h\r\n\nReturn: CF set on error\r\n\n\t    AL = error code\r\n\n\t\t82h = failure due to ???\r\n\n\tCF clear on success\r\n",
      "E300": " Blank - INSTALLATION CHECK\r\nReturn: AL = FFh if installed\r\n\n\t    ES = resident code segment\r\n",
      "ED00": " Phar Lap DOS EXTENDERS - INSTALLATION CHECK\r\n\tBL = DOS extender ID (see #03110)\r\n\nReturn: AL = status\r\n\n\t    00h not installed\r\n\n\t    FFh installed\r\n\n\t\tSI = 5048h (\"PH\")\r\n\n\t\tDI = 4152h (\"AR\")\r\n\n\t\tCH = major version number\r\n\n\t\tCL = minor version number\r\n\n\t\tDX = flags\r\n\n\t\t    bit 0: running under DPMI\r\n\n\t\t    bit 1: running under Phar Lap VMM\r\n\n\t\tif running under DPMI:\r\n\n\t\t    BX = DPMI version (BH = major, BL = minor)\r\n",
      "ED03": " Phar Lap 386/DOS-Extender v4.1 - GET EXTENDER ENTRY POINT\r\n\tCX = real-mode code segment\r\n\n\tDX = real-mode data segment\r\n\nReturn: CF clear if successful\r\n\n\t    CX = protected-mode code segment selector\r\n\n\t    DX = protected-mode data segment selector\r\n\n\t    ES:DI -> real-mode entry point for calling protected-mode functions\r\n\n\t\t      (see INT 21/AX=250Dh)\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t0008h unable to allocate LDT descriptors\r\n",
      "ED10": " Pharlap DOS Extender - ???\r\n\tBL = 05h\r\n\n\tES:SI -> ??? structure\r\n\nReturn: AX = ???\r\n\n\tSI = ???\r\n\n\tDI = ???\r\n",
      "ED11": " Pharlap DOS Extender - FATAL EXIT TO REAL MODE ???\r\n\tBL = 05h\r\n\n\tCX = ???\r\n\n\tDX = ???\r\n\n\tES:SI -> ??? structure\r\n\n\tSS:SP = new stack ???\r\n\nReturn: ???\r\n",
      "ED80": " Phar Lap 286|DOS Extender Lite v2.5 - ???\r\n\tBL = DOS extender ID (see #03110)\r\n\n\tSI = 5048h (\"PH\")\r\n\n\tDI = 4152h (\"AR\")\r\n\n\t???\r\n\nReturn: ???\r\n",
      "F100": " DOS EXTENDER INSTALLATION CHECK\r\nReturn: AL = FFh if DOS extender present\r\n\n\t    SI = 444Fh (\"DO\")\r\n\n\t    DI = 5358h (\"SX\")\r\n",
      "FB42": " Borland RTM.EXE 1.0 - ???\r\n\tBX = 1003h\r\n\n\t???\r\n\nReturn: ???\r\n",
      "FB43": " Borland C++ 3.0 DPMILOAD.EXE - NULL FUNCTION\r\n\tBX = subfunction (at least 0000h-000Eh)\r\n",
      "FBA1": " TKERNEL (Borland DOS extender) - UNINSTALL\r\n\tBX = 0084h\r\n\n\tES:DI -> response buffer (see #03137)\r\n\nReturn: ES:DI buffer filled\r\n",
      "FEEF": " RTS Control TSR - INSTALLATION CHECK\r\nReturn: AX = EFFEh if installed\r\n\n\t    BX = port address\r\n"
    },
    "AH": {
      "13": " DOS 3.2+ - SET DISK INTERRUPT HANDLER\r\n\tDS:DX -> interrupt handler disk driver calls on read/write\r\n\n\tES:BX = address to restore INT 13 to on system halt (exit from root\r\n\n\t\t shell) or warm boot (INT 19)\r\n\nReturn: DS:DX set by previous invocation of this function\r\n\n\tES:BX set by previous invocation of this function\r\n",
      "23": " DR DOS 5.0 GRAFTABL - GET GRAPHICS DATA\r\n\tAL nonzero\r\n\nReturn: AH = FFh\r\n\n\tES:BX -> graphics data (8 bytes for each character from 80h to FFh)\r\n",
      "2E": " Novell DOS 7 - GRAFTABL - GET FONT TABLE\r\n\tAL nonzero\r\n\nReturn: AH = FFh if installed\r\n\n\t    ES:BX -> graphics data (8 bytes per character from 80h to FFh)\r\n",
      "44": " DOS Extender support???\r\n\tAL = function (at least 0Bh, 15h, 17h)\r\n\n\t???\r\n\nReturn: ???\r\n",
      "46": " Windows/286 DOS Extender\r\n\tAL = subfunction (03h,04h)\r\n\nReturn: ???\r\n",
      "93": " InnerMission v1.7+ - INSTALLATION CHECK\r\n\tBX = CX = AX\r\n\nReturn: AL = state\r\n\n\t    FFh if installed and BX=CX=AX on entry\r\n\n\t\tBX = segment of resident code\r\n\n\t    01h if installed but BX or CX differ from AX (multiplex number not\r\n\n\t\t  available)\r\n",
      "A1": " Ergo DOS extenders - INSTALLATION CHECK\r\n\tBX = 0081h\r\n\n\tAL = which\r\n\n\t    FEh OS/286,OS/386\r\n\n\t    FFh HummingBoard DOS extender\r\n\n\tES:DI -> 16-byte buffer\r\n\nReturn: if installed, first four bytes of ES:DI buffer are \"IABH\"\r\n",
      "F1": " RTKernel v4.0 - INSTALLATION CHECK\r\n\tAL = 00h\r\n\nReturn: AX = FFFFh if present\r\n\n\t    CX = 00F1h\r\n"
    }
  },
  "30": " (NOT A VECTOR!) - DOS 1+ - FAR JMP instruction for CP/M-style calls\r\n",
  "31": {
    "AX": {
      "0000": " DPMI 0.9+ - ALLOCATE LDT DESCRIPTORS\r\n\tCX = number of descriptors to allocate\r\n\nReturn: CF clear if successful\r\n\n\t    AX = base selector\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (see #03143)\r\n",
      "0001": " DPMI 0.9+ - FREE LDT DESCRIPTOR\r\n\tBX = selector to free\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8022h) (see #03143)\r\n",
      "0002": " DPMI 0.9+ - SEGMENT TO DESCRIPTOR\r\n\tBX = real mode segment\r\n\nReturn: CF clear if successful\r\n\n\t    AX = selector corresponding to real mode segment (64K limit)\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8011h) (see #03143)\r\n",
      "0003": " DPMI 0.9+ - GET NEXT SELECTOR INCREMENT VALUE\r\nReturn: CF clear\r\n\n\t    AX = value to add to get next sequential selector\r\n",
      "0004": " DPMI 0.9+ - LOCK SELECTOR\r\n\tBX = selector to lock (prevent paging)\r\n\nReturn: ???\r\n",
      "0005": " DPMI 0.9+ - UNLOCK SELECTOR\r\n\tBX = selector to unlock (permit paging)\r\n\nReturn: ???\r\n",
      "0006": " DPMI 0.9+ - GET SEGMENT BASE ADDRESS\r\n\tBX = selector\r\n\nReturn: CF clear if successful\r\n\n\t    CX:DX = linear base address of segment\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8022h) (see #03143)\r\n",
      "0007": " DPMI 0.9+ - SET SEGMENT BASE ADDRESS\r\n\tBX = selector\r\n\n\tCX:DX = linear base address\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8022h,8025h) (see #03143)\r\n",
      "0008": " DPMI 0.9+ - SET SEGMENT LIMIT\r\n\tBX = selector\r\n\n\tCX:DX = segment limit\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8021h,8022h,8025h) (see #03143)\r\n",
      "0009": " DPMI 0.9+ - SET DESCRIPTOR ACCESS RIGHTS\r\n\tBX = selector\r\n\n\tCL = access rights/type byte (see #00502 at INT 15/AH=89h)\r\n\n\tCH = 80386 extended rights/type byte (see #00505 at INT 15/AH=89h)\r\n\n\t    (32-bit DPMI implementations only)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8021h,8022h,8025h) (see #03143)\r\n",
      "000A": " DPMI 0.9+ - CREATE ALIAS DESCRIPTOR\r\n\tBX = selector\r\n\nReturn: CF clear if successful\r\n\n\t    AX = new data selector\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8011h,8022h) (see #03143)\r\n",
      "000B": " DPMI 0.9+ - GET DESCRIPTOR\r\n\tBX = LDT selector\r\n\n\tES:(E)DI -> 8-byte buffer for copy of descriptor\r\n\nReturn: CF clear if successful\r\n\n\t    buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8022h) (see #03143)\r\n",
      "000C": " DPMI 0.9+ - SET DESCRIPTOR\r\n\tBX = LDT selector\r\n\n\tES:(E)DI -> 8-byte buffer containing descriptor\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8021h,8022h,8025h) (see #03143)\r\n",
      "000D": " DPMI 0.9+ - ALLOCATE SPECIFIC LDT DESCRIPTOR\r\n\tBX = LDT selector\r\n\nReturn: CF clear if successful\r\n\n\t    descriptor allocated\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8011h,8022h) (see #03143)\r\n",
      "000E": " DPMI 1.0+ - GET MULTIPLE DESCRIPTORS\r\n\tCX = number of descriptors to copy\r\n\n\tES:(E)DI -> descriptor buffer (see #03144)\r\n\nReturn: CF clear if successful\r\n\n\t    descriptors copied\r\n\n\tCF set on error\r\n\n\t    AX = error code (8022h) (see #03143)\r\n\n\t    CX = number of descriptors successfully copied\r\n",
      "000F": " DPMI 1.0+ - SET MULTIPLE DESCRIPTORS\r\n\tCX = number of descriptors to copy\r\n\n\tES:(E)DI -> descriptor buffer (see #03145)\r\n\nReturn: CF clear if successful\r\n\n\t    descriptors copied\r\n\n\tCF set on error\r\n\n\t    AX = error code (8021h,8022h,8025h) (see #03143)\r\n\n\t    CX = number of descriptors successfully copied\r\n",
      "0100": " DPMI 0.9+ - ALLOCATE DOS MEMORY BLOCK\r\n\tBX = number of paragraphs to allocate\r\n\nReturn: CF clear if successful\r\n\n\t    AX = real mode segment of allocated block\r\n\n\t    DX = first selector for allocated block\r\n\n\tCF set on error\r\n\n\t    AX = DOS error code (07h,08h) (see #01680 at INT 21/AH=59h/BX=0000h)\r\n\n\t\t(DPMI 1.0+) DPMI error code (8011h) (see #03143)\r\n\n\t    BX = size (in paragraphs) of largest available block\r\n",
      "0101": " DPMI 0.9+ - FREE DOS MEMORY BLOCK\r\n\tDX = selector of block\r\n\nReturn: CF set if successful\r\n\n\tCF set on error\r\n\n\t    AX = DOS error code (07h,09h) (see #01680 at INT 21/AH=59h/BX=0000h)\r\n",
      "0102": " DPMI 0.9+ - RESIZE DOS MEMORY BLOCK\r\n\tBX = new block size in paragraphs\r\n\n\tDX = selector of block\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = DOS error code (07h,08h,09h)\r\n\n\t\t  (see #01680 at INT 21/AH=59h/BX=0000h)\r\n\n\t\t(DPMI 1.0+) DPMI error code (8011h,8022h) (see #03143)\r\n\n\t    BX = maximum block size (in paragraphs) possible\r\n",
      "0200": " DPMI 0.9+ - GET REAL MODE INTERRUPT VECTOR\r\n\tBL = interrupt number\r\n\nReturn: CF clear\r\n\n\tCX:DX = segment:offset of real mode interrupt handler\r\n",
      "0201": " DPMI 0.9+ - SET REAL MODE INTERRUPT VECTOR\r\n\tBL = interrupt number\r\n\n\tCX:DX = segment:offset of real mode handler\r\n\nReturn: CF clear\r\n",
      "0202": " DPMI 0.9+ - GET PROCESSOR EXCEPTION HANDLER VECTOR\r\n\tBL = exception number (00h-1Fh)\r\n\nReturn: CF clear if successful\r\n\n\t    CX:(E)DX = selector:offset of handler\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8021h) (see #03143)\r\n",
      "0203": " DPMI 0.9+ - SET PROCESSOR EXCEPTION HANDLER VECTOR\r\n\tBL = exception number (00h-1Fh)\r\n\n\tCX:(E)DX = selector:offset of handler\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8021h,8022h) (see #03143)\r\n",
      "0204": " DPMI 0.9+ - GET PROTECTED MODE INTERRUPT VECTOR\r\n\tBL = interrupt number\r\n\nReturn: CF clear\r\n\n\tCX:(E)DX = selector:offset of handler\r\n",
      "0205": " DPMI 0.9+ - SET PROTECTED MODE INTERRUPT VECTOR\r\n\tBL = interrupt number\r\n\n\tCX:(E)DX = selector:offset of handler\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8022h) (see #03143)\r\n",
      "0210": " DPMI 1.0+ - GET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER\r\n\tBL = exception number (00h-1Fh)\r\n\nReturn: CF clear if successful\r\n\n\t    CX:(E)DX = selector:offset of exception handler\r\n\n\tCF set on error\r\n\n\t    AX = error code (8021h) (see #03143)\r\n",
      "0211": " DPMI 1.0+ - GET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER\r\n\tBL = exception number (00h-1Fh)\r\n\nReturn: CF clear if successful\r\n\n\t    CX:(E)DX = selector:offset of exception handler\r\n\n\tCF set on error\r\n\n\t    AX = error code (8021h) (see #03143)\r\n",
      "0212": " DPMI 1.0+ - SET PROTECTED MODE EXTENDED PROCESSOR EXCEPTION HANDLER\r\n\tBL = exception or fault number (00h-1Fh)\r\n\n\tCX:(E)DX = exception handler selector:offset\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8021h,8022h) (see #03143)\r\n",
      "0213": " DPMI 1.0+ - SET REAL MODE EXTENDED PROCESSOR EXCEPTION HANDLER\r\n\tBL = exception or fault number (00h-1Fh)\r\n\n\tCX:(E)DX = exception handler selector:offset\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8021h,8022h) (see #03143)\r\n",
      "0300": " DPMI 0.9+ - SIMULATE REAL MODE INTERRUPT\r\n\tBL = interrupt number\r\n\n\tBH = flags\r\n\n\t    bit 0: reset the interrupt controller and A20 line (DPMI 0.9)\r\n\n\t\t    reserved, must be 0 (DPMI 1.0+)\r\n\n\t    others: reserved, must be 0\r\n\n\tCX = number of words to copy from protected mode to real mode stack\r\n\n\tES:(E)DI = selector:offset of real mode call structure (see #03148)\r\n\nReturn: CF clear if successful\r\n\n\t    real mode call structure modified (all fields except SS:SP, CS:IP\r\n\n\t      filled with return values from real mode interrupt)\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8012h,8013h,8014h,8021h)(see #03143)\r\n\n\tprotected mode stack unchanged\r\n",
      "0301": " DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH FAR RETURN FRAME\r\n\tBH = flags\r\n\n\t    bit 0: reset the interrupt controller and A20 line (DPMI 0.9)\r\n\n\t\t    reserved, must be 0 (DPMI 1.0+)\r\n\n\t    others: reserved must be 0\r\n\n\tCX = number of words to copy from protected mode to real mode stack\r\n\n\tES:(E)DI = selector:offset of real mode call structure\r\n\n\t\t  (see #03148 at INT 31/AX=0300h)\r\n\nReturn: CF clear if successful\r\n\n\t    real mode call structure modified (all fields except SS:SP, CS:IP\r\n\n\t      filled with return values from real mode interrupt)\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8012h,8013h,8014h,8021h)(see #03143)\r\n\n\tprotected mode stack unchanged\r\n",
      "0302": " DPMI 0.9+ - CALL REAL MODE PROCEDURE WITH IRET FRAME\r\n\tBH = flags\r\n\n\t    bit 0: reset the interrupt controller and A20 line (DPMI 0.9)\r\n\n\t\t    reserved, must be 0 (DPMI 1.0+)\r\n\n\t    others: reserved, must be 0\r\n\n\tCX = number of words to copy from protected mode to real mode stack\r\n\n\tES:(E)DI = selector:offset of real mode call structure\r\n\n\t\t  (see #03148 at INT 31/AX=0300h)\r\n\nReturn: CF clear if successful\r\n\n\t    real mode call structure modified (all fields except SS:SP, CS:IP\r\n\n\t      filled with return values from real mode interrupt)\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8012h,8013h,8014h,8021h)(see #03143)\r\n\n\tprotected mode stack unchanged\r\n",
      "0303": " DPMI 0.9+ - ALLOCATE REAL MODE CALLBACK ADDRESS\r\n\tDS:(E)SI = selector:offset of procedure to call\r\n\n\tES:(E)DI = selector:offset of real mode call structure (see #03148)\r\n\nReturn: CF clear if successful\r\n\n\t    CX:DX = segment:offset of real mode call address (see #03149)\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8015h) (see #03143)\r\n",
      "0304": " DPMI 0.9+ - FREE REAL MODE CALLBACK ADDRESS\r\n\tCX:DX = real mode callback address\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8024h) (see #03143)\r\n",
      "0305": " DPMI 0.9+ - GET STATE SAVE/RESTORE ADDRESSES\r\nReturn: CF clear\r\n\n\tAX = size in bytes of state buffer\r\n\n\tBX:CX = real mode address of procedure to save/restore state\r\n\n\tSI:(E)DI = protected mode procedure to save/restore state (see #03150)\r\n",
      "0306": " DPMI 0.9+ - GET RAW MODE SWITCH ADDRESSES\r\nReturn: CF clear\r\n\n\tBX:CX -> procedure to switch from real to protected mode (see #03151)\r\n\n\tSI:(E)DI -> procedure to switch from protected to real mode\r\n",
      "0400": " DPMI 0.9+ - GET DPMI VERSION\r\nReturn: CF clear\r\n\n\tAH = major version of DPMI spec supported\r\n\n\tAL = two-digit minor version of DPMI spec supported\r\n\n\tBX = DPMI host flags (see #03152)\r\n\n\tCL = processor type (02h=80286, 03h=80386, 04h=80486)\r\n\n\tDH = curr value of virtual master interrupt controller base interrupt\r\n\n\tDL = curr value of virtual slave interrupt controller base interrupt\r\n",
      "0401": " DPMI 1.0+ - GET DPMI CAPABILITIES\r\n\tES:(E)DI -> 128-byte buffer for host description (see #03153)\r\n\nReturn: CF clear if successful\r\n\n\t    AX = capabilities (see #03154)\r\n\n\t    CX = reserved (00h)\r\n\n\t    DX = reserved (00h)\r\n\n\t    buffer filled\r\n\n\tCF set on error (DPMI 0.9 only)\r\n",
      "0500": " DPMI 0.9+ - GET FREE MEMORY INFORMATION\r\n\tES:(E)DI -> buffer for memory information (see #03155)\r\n\nReturn: CF clear\r\n",
      "0501": " DPMI 0.9+ - ALLOCATE MEMORY BLOCK\r\n\tBX:CX = size in bytes\r\n\nReturn: CF clear if successful\r\n\n\t    BX:CX = linear address of block\r\n\n\t    SI:DI = memory block handle for resizing and freeing block\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8012h-8014h,8016h,8021h)(see #03143)\r\n",
      "0502": " DPMI 0.9+ - FREE MEMORY BLOCK\r\n\tSI:DI = handle of memory block\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8023h) (see #03143)\r\n",
      "0503": " DPMI 0.9+ - RESIZE MEMORY BLOCK\r\n\tBX:CX = new size in bytes (nonzero)\r\n\n\tSI:DI = handle of memory block\r\n\nReturn: CF clear if successful\r\n\n\t    BX:CX = new linear address\r\n\n\t    SI:DI = new handle of memory block\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8012h-8014h,8016h,8021h,8023h)\r\n\n\t\t(see #03143)\r\n",
      "0504": " DPMI 1.0+ - ALLOCATE LINEAR MEMORY BLOCK\r\n\tEBX = page-aligned linear address of memory block (00000000h if any\r\n\n\t      address is acceptable)\r\n\n\tECX = size in bytes (nonzero)\r\n\n\tEDX = flags\r\n\n\t    bit 0: set to create committed pages instead of uncommitted pages\r\n\n\t    bits 1-31 reserved (0)\r\n\nReturn: CF clear if successful\r\n\n\t    EBX = linear address of memory block\r\n\n\t    ESI = memory block handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (8001h,8012h-8014h,8016h,8021h,8025h)(see #03143)\r\n",
      "0505": " DPMI 1.0+ - RESIZE LINEAR MEMORY BLOCK\r\n\tESI = memory block handle\r\n\n\tECX = new size in bytes (nonzero)\r\n\n\tEDX = flags\r\n\n\t    bit 0: create committed pages rather than uncommitted pages\r\n\n\t    bit 1: segment descriptor update required\r\n\n\t\tES:EBX -> buffer containing array of WORDs with selectors\r\n\n\t\tEDI = number of selectors in array\r\n\n\t    bits 2-31 reserved (0)\r\n\nReturn: CF clear if successful\r\n\n\t    EBX = new linear base address\r\n\n\t    ESI = new memory block handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (8001h,8012h-8014h,8016h,8021h,8023h)(see #03143)\r\n",
      "0506": " DPMI 1.0+ - GET PAGE ATTRIBUTES\r\n\tESI = memory block handle\r\n\n\tEBX = offset in memory block of first page\r\n\n\tECX = number of pages\r\n\n\tES:EDX -> array of WORDs to hold page attributes (see #03156)\r\n\nReturn: CF clear if successful\r\n\n\t    buffer filled\r\n\n\tCF set on error\r\n\n\t    AX = error code (8001h,8023h,8025h) (see #03143)\r\n",
      "0507": " DPMI 1.0+ - MODIFY PAGE ATTRIBUTES\r\n\tESI = memory block handle\r\n\n\tEBX = offset in memory block of first page\r\n\n\tECX = number of pages\r\n\n\tES:EDX -> array of WORDs with new page attributes (see #03156)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8001h,8002h,8013h,8014h,8021h,8023h,8025h)\r\n\n\t\t(see #03143)\r\n\n\t    ECX = number of pages which have been set\r\n",
      "0508": " DPMI 1.0+ - MAP DEVICE IN MEMORY BLOCK\r\n\tESI = memory block handle\r\n\n\tEBX = page-aligned offset within memory block of page(s) to be mapped\r\n\n\tECX = number of pages to map\r\n\n\tEDX = page-aligned physical address of device\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8001h,8003h,8023h,8025h) (see #03143)\r\n",
      "0509": " DPMI 1.0+ - MAP CONVENTIONAL MEMORY IN MEMORY BLOCK\r\n\tESI = memory block handle\r\n\n\tEBX = page-aligned offset within memory block of page(s) to map\r\n\n\tECX = number of pages to map\r\n\n\tEDX = page-aligned linear address of conventional (below 1M) memory\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8001h,8003h,8023h,8025h) (see #03143)\r\n",
      "050A": " DPMI 1.0+ - GET MEMORY BLOCK SIZE AND BASE\r\n\tSI:DI = memory block handle\r\n\nReturn: CF clear if successful\r\n\n\t    SI:DI = size in bytes\r\n\n\t    BX:CX = base address\r\n\n\tCF set on error\r\n\n\t    AX = error code (8023h) (see #03143)\r\n",
      "050B": " DPMI 1.0+ - GET MEMORY INFORMATION\r\n\tES:(E)DI -> 128-byte buffer for memory information (see #03157)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error (DPMI 0.9 only)\r\n",
      "0600": " DPMI 0.9+ - LOCK LINEAR REGION\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    none of the memory is locked\r\n\n\t    AX = error code (DPMI 1.0+) (8013h,8017h,8025h) (see #03143)\r\n",
      "0601": " DPMI 0.9+ - UNLOCK LINEAR REGION\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    none of the memory is unlocked\r\n\n\t    AX = error code (DPMI 1.0+) (8002h,8025h) (see #03143)\r\n",
      "0602": " DPMI 0.9+ - MARK REAL MODE REGION AS PAGEABLE\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    none of the memory is made pageable\r\n\n\t    AX = error code (DPMI 1.0+) (8002h,8025h) (see #03143)\r\n",
      "0603": " DPMI 0.9+ - RELOCK REAL MODE REGION\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    none of the memory is relocked\r\n\n\t    AX = error code (DPMI 1.0+) (8002h,8013h,8025h) (see #03143)\r\n",
      "0604": " DPMI 0.9+ - GET PAGE SIZE\r\nReturn: CF clear if successful\r\n\n\t    BX:CX = page size in bytes\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (see also #03143)\r\n\n\t\t8001h unsupported, 16-bit host\r\n",
      "0700": " DPMI 0.9+ - MARK PAGES AS PAGING CANDIDATES\r\n\tBX:CX = starting linear page number\r\n\n\tSI:DI = number of pages to mark as paging candidates\r\n\nReturn: ???\r\n",
      "0701": " DPMI 0.9+ - DISCARD PAGES\r\n\tBX:CX = starting linear page number\r\n\n\tSI:DI = number of pages to discard\r\n\nReturn: ???\r\n",
      "0702": " DPMI 0.9+ - MARK PAGE AS DEMAND PAGING CANDIDATE\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = number of bytes to mark as paging candidates\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8025h) (see #03143)\r\n",
      "0703": " DPMI 0.9+ - DISCARD PAGE CONTENTS\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = number of bytes to mark as discarded\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8025h) (see #03143)\r\n",
      "0800": " DPMI 0.9+ - PHYSICAL ADDRESS MAPPING\r\n\tBX:CX = physical address (should be above 1 MB)\r\n\n\tSI:DI = size in bytes\r\n\nReturn: CF clear if successful\r\n\n\t    BX:CX = linear address which maps the requested physical memory\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8003h,8021h) (see #03143)\r\n",
      "0801": " DPMI 1.0+ - FREE PHYSICAL ADDRESS MAPPING\r\n\tBX:CX = linear address returned by AX=0800h\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8025h) (see #03143)\r\n",
      "0900": " DPMI 0.9+ - GET AND DISABLE VIRTUAL INTERRUPT STATE\r\nReturn: CF clear\r\n\n\tvirtual interrupts disabled\r\n\n\tAL = previous interrupt state (00h disabled, 01h enabled)\r\n\n\tAH preserved\r\n",
      "0901": " DPMI 0.9+ - GET AND ENABLE VIRTUAL INTERRUPT STATE\r\nReturn: CF clear\r\n\n\tvirtual interrupts enabled\r\n\n\tAL = previous interrupt state (00h disabled, 01h enabled)\r\n\n\tAH preserved\r\n",
      "0902": " DPMI 0.9+ - GET VIRTUAL INTERRUPT STATE\r\nReturn: CF clear\r\n\n\tAL = current interrupt state (00h disabled, 01h enabled)\r\n",
      "0A00": " DPMI 0.9+ - GET VENDOR SPECIFIC API ENTRY POINT\r\n\tDS:(E)SI -> case-sensitive ASCIZ vendor name or identifier\r\n\nReturn: CF clear if successful\r\n\n\t    ES:(E)DI -> FAR extended API entry point\r\n\n\t    DS, FS, GS, EAX, EBX, ECX, EDX, ESI, EBP destroyed\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8001h) (see #03143)\r\n",
      "0B00": " DPMI 0.9+ - SET DEBUG WATCHPOINT\r\n\tBX:CX = linear address\r\n\n\tDL = size (1,2,4 bytes)\r\n\n\tDH = type (00h execute, 01h write, 02h read/write)\r\n\nReturn: CF clear if successful\r\n\n\t    BX = watchpoint handle\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8016h,8021h,8025h) (see #03143)\r\n",
      "0B01": " DPMI 0.9+ - CLEAR DEBUG WATCHPOINT\r\n\tBX = watchpoint handle\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8023h) (see #03143)\r\n",
      "0B02": " DPMI 0.9+ - GET STATE OF DEBUG WATCHPOINT\r\n\tBX = watchpoint handle\r\n\nReturn: CF clear if successful\r\n\n\t    AX = status flags\r\n\n\t\tbit 0: watch point has been executed since AX=0B00h or AX=0B03h\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8023h) (see #03143)\r\n",
      "0B03": " DPMI 0.9+ - RESET DEBUG WATCHPOINT\r\n\tBX = watchpoint handle\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (DPMI 1.0+) (8023h) (see #03143)\r\n",
      "0C00": " DPMI 1.0+ - INSTALL RESIDENT HANDLER INIT CALLBACK\r\n\tES:(E)DI -> resident service provider structure (see #03158)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8015h,8021h,8025h) (see #03143 at AX=0000h)\r\n",
      "0C01": " DPMI 1.0+ - TERMINATE AND STAY RESIDENT\r\n\tBL = return code\r\n\n\tDX = number of paragraphs of DOS memory to reserve (0 or >= 6)\r\n\nReturn: never\r\n",
      "0D00": " DPMI 1.0+ - ALLOCATE SHARED MEMORY\r\n\tES:(E)DI -> shared memory allocation request structure (see #03159)\r\n\nReturn: CF clear if successful\r\n\n\t    request structure updated\r\n\n\tCF set on error\r\n\n\t    AX = error code (8012h,8013h,8014h,8016h,8021h) (see #03143)\r\n",
      "0D01": " DPMI 1.0+ - FREE SHARED MEMORY\r\n\tSI:DI = shared memory block handle\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8023h) (see #03143)\r\n",
      "0D02": " DPMI 1.0+ - SERIALIZE SHARED MEMORY\r\n\tSI:DI = shared memory block handle\r\n\n\tDX = flags\r\n\n\t    bit 0: return immediately rather than suspending if serialization\r\n\n\t\t  unavailable\r\n\n\t    bit 1: shared rather than exclusive serialization\r\n\n\t    bits 2-15 reserved (0)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8004h,8005h,8017h-8019h,8023h) (see #03143)\r\n",
      "0D03": " DPMI 1.0+ - FREE SERIALIZATION ON SHARED MEMORY\r\n\tSI:DI = shared memory block handle\r\n\n\tDX = flags\r\n\n\t    bit 0: release shared serialization rather than exclusive serialztn\r\n\n\t    bit 1: free pending serialization\r\n\n\t    bits 2-15 reserved (0)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8002h,8023h) (see #03143 at AX=0000h)\r\n",
      "0E00": " DPMI 1.0+ - GET COPROCESSOR STATUS\r\nReturn: CF clear\r\n\n\tAX = coprocessor status (see #03160)\r\n",
      "0E01": " DPMI 1.0+ - SET EMULATION\r\n\tBX = coprocessor flag bits (see #03161)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = error code (8026h) (see #03143 at AX=0000h)\r\n",
      "5702": " Netroom3 DPMI.EXE v3.00 - SWITCH TO PROTECTED MODE\r\n\tDX = PSP segment of caller\r\n\n\tSTACK: WORD\t???\r\n\n\t       WORD\tflags (bit 0 set if 32-bit program)\r\n\nReturn: as for DPMI mode-switch entry point (see #02718 at INT 2F/AX=1687h)\r\n",
      "EE00": " DOS32 v3.0+ - GET DOS32 VERSION AND SELECTOR VALUES\r\nReturn: AL = minor version (BCD)\r\n\n\tAH = major version (BCD)\r\n\n\tDL = system type (1=raw DOS, 2=XMS, 4=VCPI, 8=DPMI)\r\n\n\tBX = selector of 4GB data segment with zero base address\r\n",
      "EE02": " DOS32 v3.0+ - GET DOS32 ADDRESS INFORMATION\r\nReturn: AX = real-mode segment of temporary 8K buffer (v3.1+)\r\n\n\tEBX = 32bit linear address of the program segment\r\n\n\tEDX = Total size in bytes of the programs .EXE file after linking.\r\n\n\tESI = offset address of PSP\r\n\n\tEDI = offset address of program environment\r\n\n\tECX = offset address of the program's .EXE ASCIZ file name and path\r\n",
      "EE10": " DOS32 v3.2+ - SET UP A DOS32 LOADABLE LIBRARY\r\n\tEDX -> library ASCIZ path\\filename\r\n\n\tEBX = number of bytes to seek from beginning of file\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = size of memory block required to store library\r\n\n\t    EBX = size of library file\r\n\n\tCF set on error\r\n\n\t    AL = error code.\r\n\n\t\t01h error opening or reading file\r\n\n\t\t02h bad DOS32 library file\r\n",
      "EE11": " DOS32 v3.2+ - LOAD LIBRARY FILE\r\n\tEDX -> near pointer of memory block to store library\r\n\nReturn: CF clear if successful\r\n\n\t    EDX = near pointer to the dynamic library public\r\n\n\tCF set on error\r\n",
      "EE20": " DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH RETF STACK FRAME\r\n\tESI = offset of the real mode call back function\r\n\nReturn: CF clear if successful\r\n\n\t    CX:DX = real mode address to call up to the protected mode\r\n\n\t\t  procedure\r\n\n\tCF set on error\r\n",
      "EE21": " DOS32 v3.0+ - GET REAL MODE CALL BACK ADDRESS WITH IRET STACK FRAME\r\n\tESI = offset of the real mode call back function\r\n\nReturn: CF clear if successful\r\n\n\t    CX:DX = real mode address to call up to the protected mode\r\n\n\t\t  procedure\r\n\n\tCF set on error\r\n",
      "EE30": " DOS32 v3.0+ - TERMINATE AND STAY RESIDENT\r\n",
      "EE40": " DOS32 v3.0+ - UNDO PREVIOUS MEMORY ALLOCATION or DMA BUFFER\r\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "EE41": " DOS32 v3.0+ - ALLOCATE 16KB DMA BLOCK\r\nReturn: CF clear if successful\r\n\n\t    EBX -> 16KB DMA block (physical address)\r\n\n\t    EDX -> 16KB DMA block (offset address)\r\n\n\tCF set on error\r\n",
      "EE42": " DOS32 v3.0+ - ALLOCATE MEMORY BLOCK\r\n\tEDX = size in bytes\r\n\nReturn: CF clear if successful\r\n\n\t    EAX = size in bytes\r\n\n\t    EDX -> memory block\r\n\n\tCF set on error\r\n",
      "FF00": " CauseWay - \"Info\" - GET SYSTEM SELECTORS/FLAGS\r\nReturn: AX = selector for flag address space (base 00000000h, limit 4GB)\r\n\n\tBX = selector for current PSP segment (limit 0100h)\r\n\n\t(E)CX = size of DOS transfer buffer (max 64K)\r\n\n\tDX = real-mode segment address of DOS transfer buffer\r\n\n\tES:(E)SI = protected-mode address of DOS transfer buffer\r\n\n\tEDI = system flags (see #03162)\r\n",
      "FF01": " CauseWay - \"IntXX\" - SIMULATE REAL-MODE INTERRUPT\r\n\tBL = interrupt number\r\n\n\tES:(E)DI -> real-mode register list (see #03148 at AX=0300h)\r\n\nReturn: register list updated\r\n",
      "FF02": " CauseWay - \"FarCallReal\" - SIMULATE REAL-MODE FAR CALL\r\n\tES:(E)DI -> real-mode register list (see #03148 at AX=0300h)\r\n\nReturn: register list updated\r\n",
      "FF03": " CauseWay - \"GetSel\" - ALLOCATE NEW SELECTOR\r\nReturn: CF clear if successful\r\n\n\t    BX = new selector\r\n\n\tCF set on error\r\n",
      "FF04": " CauseWay - \"RelSel\" - RELEASE A SELECTOR\r\n\tBX = selector\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF05": " CauseWay - \"CodeSel\" - CONVERT SELECTOR TO EXECUTABLE CODE SELECTOR\r\n\tBX = selector\r\n\n\tCL = default operation size (00h = 16-bit, 01h = 32-bit)\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF06": " CauseWay - \"AliasSel\" - CREATE READ/WRITE DATA ALIAS SELECTOR\r\n\tBX = original selector\r\n\nReturn: CF clear if successful\r\n\n\t    AX = new data selector aliasing original selector\r\n\n\tCF set on error\r\n",
      "FF07": " CauseWay - \"GetSelDet\" - GET SELECTOR BASE AND LIMIT\r\n\tBX = selector\r\n\nReturn: CF clear if successful\r\n\n\t    CX:DX = base address\r\n\n\t    SI:DI = limit (bytes)\r\n\n\tCF set on error\r\n",
      "FF08": " CauseWay - \"GetSelDet32\" - GET SELECTOR BASE AND LIMIT (32-bit)\r\nReturn: CF clear if successful\r\n\n\t    EDX = base address\r\n\n\t    ECX = limit (bytes)\r\n\n\tCF set on error\r\n",
      "FF09": " CauseWay - \"SetSelDet\" - SET SELECTOR BASE AND LIMIT\r\n\tBX = selector\r\n\n\tCX:DX = new base address\r\n\n\tSI:DI = new byte-granular limit\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF0A": " CauseWay - \"SetSelDet32\" - SET SELECTOR BASE AND LIMIT (32-bit)\r\n\tBX = selector\r\n\n\tEDX = new base address\r\n\n\tECX = new byte-granular limit\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF0B": " CauseWay - \"GetMem\" - ALLOCATE BLOCK OF MEMORY\r\n\tCX:DX = size in bytes (FFFFh:FFFFh to get size of largest available)\r\n\nReturn: CF clear if successful\r\n\n\t    BX = selector for accessing block if requested size not FFFFh:FFFFh\r\n\n\t    CX:DX = size of largest available block if requested FFFFh:FFFFh\r\n\n\tCF set on error\r\n",
      "FF0C": " CauseWay - \"GetMem32\" - ALLOCATE BLOCK OF MEMORY (32-bit)\r\n\tECX = size in bytes (FFFFFFFFh to get size of largest available block)\r\n\nReturn: CF clear if successful\r\n\n\t    BX = selector for accessing block if requested size not FFFFh:FFFFh\r\n\n\t    ECX = size of largest available block if requested FFFFh:FFFFh\r\n\n\tCF set on error\r\n",
      "FF0D": " CauseWay - \"ResMem\" - RESIZE MEMORY BLOCK\r\n\tBX = selector for block to be resized\r\n\n\tCX:DX = new size in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF0E": " CauseWay - \"ResMem32\" - RESIZE MEMORY BLOCK (32-bit)\r\n\tBX = selector for block to be resized\r\n\n\tECX = new size in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF0F": " CauseWay - \"RelMem\" - RELEASE PREVIOUSLY ALLOCATED MEMORY\r\n\tBX = selector for block to be released\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF10": " CauseWay - \"GetMemLinear\" - ALLOCATE MEMORY WITHOUT SELECTOR\r\n\tCX:DX = size of block in bytes\r\n\nReturn: CF clear if successful\r\n\n\t    SI:DI = linear address of allocated block\r\n\n\tCF set on error\r\n",
      "FF11": " CauseWay - \"GetMemLinear32\" - ALLOCATE MEMORY WITHOUT SELECTOR\r\n\tECX = size of block in bytes\r\n\nReturn: CF clear if successful\r\n\n\t    ESI = linear address of allocated block\r\n\n\tCF set on error\r\n",
      "FF12": " CauseWay - \"ResMemLinear\" - RESIZE LINEAR MEMORY BLOCK\r\n\tCX:DX = new size in bytes\r\n\n\tSI:DI = linear address of block to be resized\r\n\nReturn: CF clear if successful\r\n\n\t   SI:DI = new linear address of block\r\n\n\tCF set on error\r\n",
      "FF13": " CauseWay - \"ResMemLinear32\" - RESIZE LINEAR MEMORY BLOCK (32-bit)\r\n\tECX = new size in bytes\r\n\n\tESI = linear address of block to be resized\r\n\nReturn: CF clear if successful\r\n\n\t   ESI = new linear address of block\r\n\n\tCF set on error\r\n",
      "FF14": " CauseWay - \"RelMemLinear\" - RELEASE LINEAR MEMORY BLOCK\r\n\tSI:DI = linear address of block to be released\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF15": " CauseWay - \"RelMemLinear32\" - RELEASE LINEAR MEMORY BLOCK (32-bit)\r\n\tESI = linear address of block to be released\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF16": " CauseWay - \"GetMemNear\" - ALLOCATE APPLICATION-RELATIVE MEMORY\r\n\tEBX = size in bytes of block to allocate\r\n\nReturn: CF clear if successful\r\n\n\t   ESI = application-relative linear address of allocated block\r\n\n\tCF set on error\r\n",
      "FF17": " CauseWay - \"ResMemNear\" - RESIZE APPLICATION-RELATIVE MEMORY BLOCK\r\n\tEBX = size in bytes of block to allocate\r\n\n\tESI = application-relative linear address of block\r\n\nReturn: CF clear if successful\r\n\n\t    ESI = new application-relative linear address of block\r\n\n\tCF set on error\r\n",
      "FF18": " CauseWay - \"RelMemNear\" - RELEASE APPLICATION-RELATIVE MEMORY BLOCK\r\n\tESI = application-relative linear address of block\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF19": " CauseWay - \"Linear2Near\" - CONVERT LINEAR TO APP-RELATIVE ADDRESS\r\n\tESI = linear address\r\n\nReturn: ESI = application-relative linear address\r\n",
      "FF1A": " CauseWay - \"Near2Linear\" - CONVERT APP-RELATIVE TO LINEAR ADDRESS\r\n\tESI = application-relative linear address\r\n\nReturn: ESI = linear address\r\n",
      "FF1B": " CauseWay - \"LockMem\" - LOCK REGION OF MEMORY\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF1C": " CauseWay - \"LockMem32\" - LOCK REGION OF MEMORY (32-bit)\r\n\tESI = starting linear address\r\n\n\tECX = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF1D": " CauseWay - \"UnLockMem\" - UNLOCK REGION OF MEMORY\r\n\tBX:CX = starting linear address\r\n\n\tSI:DI = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF1E": " CauseWay - \"UnLockMem32\" - UNLOCK REGION OF MEMORY (32-bit)\r\n\tESI = starting linear address\r\n\n\tECX = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF1F": " CauseWay - \"LockMemNear\" - LOCK APPLICATION-RELATIVE MEMORY REGION\r\n\tESI = starting application-relative linear address\r\n\n\tEBX = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF20": " CauseWay - \"UnLockMemNear\" - UNLOCK APP-RELATIVE MEMORY REGION\r\n\tESI = starting application-relative linear address\r\n\n\tECX = size of region in bytes\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n",
      "FF21": " CauseWay - \"GetMemDOS\" - ALLOCATE CONVENTIONAL MEMORY\r\n\tBX = number of paragraphs to allocate\r\n\nReturn: CF clear if successful\r\n\n\t    AX = real-mode segment of allocated block\r\n\n\t    DX = initial selector for block\r\n\n\tCF set on error\r\n\n\t    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)\r\n\n\t    BX = size of largest available block\r\n",
      "FF22": " CauseWay - \"ResMemDOS\" - RESIZE CONVENTIONAL MEMORY BLOCK\r\n\tBX = new size in paragraphs\r\n\n\tDX = initial selector for block\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)\r\n\n\t    BX = maximum number of paragraphs available\r\n",
      "FF23": " CauseWay - \"RelMemDOS\" - RELEASE CONVENTIONAL MEMORY BLOCK\r\n\tDX = initial selector for block\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t    AX = DOS error code (see #01680 at INT 21/AH=59h/BX=0000h)\r\n",
      "FF24": " CauseWay - \"ExecOverlay\" - LOAD AND OPTIONALLY EXECUTE APP CODE\r\n\tEBX = flags\r\n\n\t    bit 0: don't execute (overlay only)\r\n\n\t    bit 1: don't preserve relocation information\r\n\n\tES:EDX -> filename (see also #03163)\r\n\n\tFS:ESI -> commandline (ESI = 00000000h if no commandline)\r\n\n\tGS:EDI -> name (CW's /o option)\r\n\nReturn: CF clear if successful\r\n\n\t    ---EBX bit 0 set---\r\n\n\t    CX:EDX = program entry point (CS:EIP)\r\n\n\t    SI = segment of PSP\r\n\n\t    ---EBX bit 1 set---\r\n\n\t    BX:EAX = initial SS:ESP\r\n\n\t    EDI high word = base segment\r\n\n\t    EDI low word = number of segments\r\n\n\t    EBP = start of segment definitions\r\n\n\tCF set on error\r\n\n\t    AX = error code\r\n\n\t\t0001h DOS file access error\r\n\n\t\t0002h not a CuaseWay 3P file\r\n\n\t\t0003h not enough memory\r\n",
      "FF25": " CauseWay - \"GetDOSTrans\" - GET DOS TRANSFER BUFFER\r\nReturn: BX = real-mode segment of transfer buffer\r\n\n\tECX = transfer buffer size\r\n\n\tDX = protected-mode selector for transfer buffer\r\n",
      "FF26": " CauseWay - \"SetDOSTrans\" - SET DOS TRANSFER BUFFER\r\n\tBX = real-mode segment of new transfer buffer\r\n\n\tECX = new transfer buffer size\r\n\n\tDX = protected-mode selector for new transfer buffer\r\n\nReturn: nothing\r\n",
      "FF27": " CauseWay v1.3 - \"GetMCBSize\" - GET CURRENT MCB ALLOCATION BLOCK SIZE\r\nReturn: ECX = current threshold\r\n",
      "FF28": " CauseWay v1.3 - \"SetMCBSize\" - SET MCB MEMORY ALLOCATION BLOCK SIZE\r\n\tECX = new threshold (0000000h to disable MCB memory allocation system)\r\n\nReturn: CF clear if successful\r\n\n\t    threshold unchanged (default 16K)\r\n\n\tCF set on error (threshold > 64K)\r\n",
      "FF29": " CauseWay v1.3 - \"GetSels\" - ALLOCATE MULTIPLE SELECTORS\r\n\tCX = number of selectors to allocate\r\n\nReturn: BX = base selector\r\n",
      "FF2A": " CauseWay v1.3 - \"cwLoad\" - LOAD ANOTHER CAUSEWAY PROGRAM AS OVERLAY\r\n\tDS:EDX -> filename\r\n\nReturn: CF clear if successful\r\n\n\t    CX:EDX = CS:EIP of entry point\r\n\n\t    BX:EAX = initial SS:ESP for program\r\n\n\t    SI = PSP for overlay program\r\n\n\tCF set on error\r\n\n\t    AX = error code (01h file error, 02h not a 3P file, 03h no memory)\r\n",
      "FF2B": " CauseWay v1.3 - \"cwcInfo\" - VALIDATE AND GET SIZE OF CWC FILE\r\n\tBX = file handle for CWC-compressed file\r\n\nReturn: CF clear if successful\r\n\n\t    ECX = expanded file size\r\n\n\tCF set on error (not a CWC-compressed file)\r\n",
      "FF2C": " CauseWay v1.3 - \"GetMemSO\" - ALLOCATE MEMORY AND RETURN SEL:OFFSET\r\n\tCX:DX = block size in bytes\r\n\nReturn: CF clear if successful\r\n\n\t   SI:DI = selector:offset of allocated memory\r\n\n\tCF set on error\r\n",
      "FF2D": " CauseWay v1.3 - \"ResMemSO\" - RESIZE SELECTOR:OFFSET MEMORY BLOCK\r\n\tSI:DI = selector:offset for memory block\r\n\n\tCX:DX = new size of block\r\n\nReturn: CF clear if successful\r\n\n\t   SI:DI = new selector:offset for memory block\r\n\n\tCF set on error\r\n",
      "FF2E": " CauseWay v1.3 - \"RelMemSO\" - RELEASE SELECTOR:OFFSET MEMORY BLOCK\r\n\tSI:DI = selector:offset for memory block\r\n",
      "FFFB": " Causeway v1.3 - \"cwcLoad\" - LOAD/EXPAND CWC-COMPRESSED FILE\r\n\tBX = source file handle\r\n\n\tES:EDI -> memory buffer into which to expand file\r\n\nReturn: CF clear if successful\r\n\n\t    ECX = expanded data length\r\n\n\tCF set on error\r\n\n\t    EAX = error code (01h file error, 02h bad data, 03h not CWC file)\r\n"
    },
    "AH": {
      "57": " Netroom3 DPMI.EXE v3.00 - ???\r\n\tAL = subfunction (at least 02h,03h,04h,05h,07h,08h,09h,0Ah)\r\n\n\t???\r\n\nReturn: ???\r\n"
    }
  },
  "33": {
    "AX": {
      "0000": " MS MOUSE - RESET DRIVER AND READ STATUS\r\nReturn: AX = status\r\n\n\t    0000h hardware/driver not installed\r\n\n\t    FFFFh hardware/driver installed\r\n\n\tBX = number of buttons\r\n\n\t    0000h other than two\r\n\n\t    0002h two buttons (many drivers)\r\n\n\t    0003h Mouse Systems/Logitech three-button mouse\r\n\n\t    FFFFh two buttons\r\n",
      "0001": " MS MOUSE v1.0+ - SHOW MOUSE CURSOR\r\n",
      "0002": " MS MOUSE v1.0+ - HIDE MOUSE CURSOR\r\n",
      "0003": " MS MOUSE v1.0+ - RETURN POSITION AND BUTTON STATUS\r\nReturn: BX = button status (see #03168)\r\n\n\tCX = column\r\n\n\tDX = row\r\n",
      "0004": " MS MOUSE v1.0+ - POSITION MOUSE CURSOR\r\n\tCX = column\r\n\n\tDX = row\r\n",
      "0005": " MS MOUSE v1.0+ - RETURN BUTTON PRESS DATA\r\n\tBX = button number (see #03169)\r\n\nReturn: AX = button states (see #03168)\r\n\n\tBX = number of times specified button has been pressed since last call\r\n\n\tCX = column at time specified button was last pressed\r\n\n\tDX = row at time specified button was last pressed\r\n",
      "0006": " MS MOUSE v1.0+ - RETURN BUTTON RELEASE DATA\r\n\tBX = button number (see #03169)\r\n\nReturn: AX = button states (see #03168)\r\n\n\tBX = number of times specified button has been released since last call\r\n\n\tCX = column at time specified button was last released\r\n\n\tDX = row at time specified button was last released\r\n",
      "0007": " MS MOUSE v1.0+ - DEFINE HORIZONTAL CURSOR RANGE\r\n\tCX = minimum column\r\n\n\tDX = maximum column\r\n",
      "0008": " MS MOUSE v1.0+ - DEFINE VERTICAL CURSOR RANGE\r\n\tCX = minimum row\r\n\n\tDX = maximum row\r\n",
      "0009": " MS MOUSE v3.0+ - DEFINE GRAPHICS CURSOR\r\n\tBX = column of cursor hot spot in bitmap (-16 to 16)\r\n\n\tCX = row of cursor hot spot (-16 to 16)\r\n\n\tES:DX -> mask bitmap (see #03170)\r\n",
      "000A": " MS MOUSE v3.0+ - DEFINE TEXT CURSOR\r\n\tBX = hardware/software text cursor\r\n\n\t    0000h software\r\n\n\t\tCX = screen mask\r\n\n\t\tDX = cursor mask\r\n\n\t    0001h hardware\r\n\n\t\tCX = start scan line\r\n\n\t\tDX = end scan line\r\n",
      "000B": " MS MOUSE v1.0+ - READ MOTION COUNTERS\r\nReturn: CX = number of mickeys mouse moved horizontally since last call\r\n\n\tDX = number of mickeys mouse moved vertically\r\n",
      "000C": " MS MOUSE v1.0+ - DEFINE INTERRUPT SUBROUTINE PARAMETERS\r\n\tCX = call mask (see #03171)\r\n\n\tES:DX -> FAR routine (see #03172)\r\n",
      "000D": " MS MOUSE v1.0+ - LIGHT PEN EMULATION ON\r\n",
      "000E": " MS MOUSE v1.0+ - LIGHT PEN EMULATION OFF\r\n",
      "000F": " MS MOUSE v1.0+ - DEFINE MICKEY/PIXEL RATIO\r\n\tCX = number of mickeys per 8 pixels horizontally (default 8)\r\n\n\tDX = number of mickeys per 8 pixels vertically (default 16)\r\n",
      "0010": " Genius MOUSE - DEFINE SCREEN REGION FOR UPDATING\r\n\tES:DX -> update region list (see #03173)\r\n",
      "0011": " Genius Mouse 9.06 - GET NUMBER OF BUTTONS\r\nReturn: AX = FFFFh\r\n\n\tBX = number of buttons\r\n",
      "0012": " MS MOUSE - SET LARGE GRAPHICS CURSOR BLOCK\r\n\tBH = cursor width in words\r\n\n\tCH = rows in cursor\r\n\n\tBL = horizontal hot spot (-16 to 16)\r\n\n\tCL = vertical hot spot (-16 to 16)\r\n\n\tES:DX -> bit map of screen and cursor maps\r\n\nReturn: AX = FFFFh if successful\r\n",
      "0013": " MS MOUSE v5.0+ - DEFINE DOUBLE-SPEED THRESHOLD\r\n\tDX = threshold speed in mickeys/second, 0000h = default of 64/second\r\n",
      "0014": " MS MOUSE v3.0+ - EXCHANGE INTERRUPT SUBROUTINES\r\n\tCX = call mask (see #03171)\r\n\n\tES:DX -> FAR routine\r\n\nReturn: CX = call mask of previous interrupt routine\r\n\n\tES:DX = FAR address of previous interrupt routine\r\n",
      "0015": " MS MOUSE v6.0+ - RETURN DRIVER STORAGE REQUIREMENTS\r\nReturn: BX = size of buffer needed to store driver state\r\n",
      "0016": " MS MOUSE v6.0+ - SAVE DRIVER STATE\r\n\tBX = size of buffer (see AX=0015h)\r\n\n\tES:DX -> buffer for driver state\r\n",
      "0017": " MS MOUSE v6.0+ - RESTORE DRIVER STATE\r\n\tBX = size of buffer (see AX=0015h)\r\n\n\tES:DX -> buffer containing saved state\r\n",
      "0018": " MS MOUSE v6.0+ - SET ALTERNATE MOUSE USER HANDLER\r\n\tCX = call mask (see #03174)\r\n\n\tES:DX -> FAR routine to be invoked on mouse events (see #03175)\r\n\nReturn: AX = status\r\n\n\t    0018h if successful\r\n\n\t    FFFFh on error\r\n",
      "0019": " MS MOUSE v6.0+ - RETURN USER ALTERNATE INTERRUPT VECTOR\r\n\tCX = call mask (see #03174)\r\n\nReturn: BX:DX = user interrupt vector\r\n\n\tCX = call mask (0000h if not found)\r\n",
      "001A": " MS MOUSE v6.0+ - SET MOUSE SENSITIVITY\r\n\tBX = horizontal speed \\\r\n\n\tCX = vertical speed   / (see AX=000Fh)\r\n\n\tDX = double speed threshold (see AX=0013h)\r\n",
      "001B": " MS MOUSE v6.0+ - RETURN MOUSE SENSITIVITY\r\nReturn: BX = horizontal speed\r\n\n\tCX = vertical speed\r\n\n\tDX = double speed threshold\r\n",
      "001C": " MS MOUSE v6.0+ - SET INTERRUPT RATE\r\n\tBX = rate (see #03176)\r\n",
      "001D": " MS MOUSE v6.0+ - DEFINE DISPLAY PAGE NUMBER\r\n\tBX = display page number\r\n",
      "001E": " MS MOUSE v6.0+ - RETURN DISPLAY PAGE NUMBER\r\nReturn: BX = display page number\r\n",
      "001F": " MS MOUSE v6.0+ - DISABLE MOUSE DRIVER\r\nReturn: AX = status\r\n\n\t    001Fh successful\r\n\n\t\tES:BX = INT 33 vector before mouse driver was first installed\r\n\n\t    FFFFh unsuccessful\r\n",
      "0020": " MS MOUSE v6.0+ - ENABLE MOUSE DRIVER\r\nReturn: AX = status\r\n\n\t    0020h successful\r\n\n\t    FFFFh unsuccessful\r\n",
      "0021": " MS MOUSE v6.0+ - SOFTWARE RESET\r\nReturn: AX = status\r\n\n\t    FFFFh if mouse driver installed\r\n\n\t\tBX = number of buttons (FFFFh = two buttons)\r\n\n\t    0021h if mouse driver not installed\r\n",
      "0022": " MS MOUSE v6.0+ - SET LANGUAGE FOR MESSAGES\r\n\tBX = language (see #03177)\r\n",
      "0023": " MS MOUSE v6.0+ - GET LANGUAGE FOR MESSAGES\r\nReturn: BX = language (see #03177)\r\n",
      "0024": " MS MOUSE v6.26+ - GET SOFTWARE VERSION, MOUSE TYPE, AND IRQ NUMBER\r\n\tBX = 0000h to check for function's existence\r\n\nReturn: AX = FFFFh on error\r\n\n\totherwise,\r\n\n\t    BH = major version\r\n\n\t    BL = minor version\r\n\n\t    CH = type (1=bus, 2=serial, 3=InPort, 4=PS/2, 5=HP)\r\n\n\t    CL = interrupt (0=PS/2, 2=IRQ2, 3=IRQ3,...,7=IRQ7,...,0Fh=IRQ15)\r\n",
      "0025": " MS MOUSE v6.26+ - GET GENERAL DRIVER INFORMATION\r\nReturn: AX = general information (see #03178)\r\n\n\tBX = cursor lock flag for OS/2 to prevent reentrancy problems\r\n\n\tCX = mouse code active flag (for OS/2)\r\n\n\tDX = mouse driver busy flag (for OS/2)\r\n",
      "0026": " Genius Mouse 9.06 - ???\r\nReturn: CX = 0204h if CX was 0105h on entry, else unchanged\r\n",
      "0027": " MS MOUSE v7.01+ - GET SCREEN/CURSOR MASKS AND MICKEY COUNTS\r\nReturn: AX = screen-mask value (or hardware cursor scan-line start for v7.02+)\r\n\n\tBX = cursor-mask value (or hardware cursor scan-line stop for v7.02+)\r\n\n\tCX = horizontal mickeys moved since last call\r\n\n\tDX = vertical mickeys moved since last call\r\n",
      "0028": " MS MOUSE v7.0+ - SET VIDEO MODE\r\n\tCX = new video mode (call is NOP if 0000h)\r\n\n\tDH = Y font size (00h = default)\r\n\n\tDL = X font size (00h = default)\r\n\nReturn: CL = status (00h = successful)\r\n",
      "0029": " MS MOUSE v7.0+ - ENUMERATE VIDEO MODES\r\n\tCX = previous video mode\r\n\n\t    0000h get first supported video mode\r\n\n\t    other get next supported mode after mode CX\r\n\nReturn: CX = first/next video mode (0000h = no more video modes)\r\n\n\tDS:DX -> description of video mode or 0000h:0000h if none\r\n",
      "002A": " MS MOUSE v7.02+ - GET CURSOR HOT SPOT\r\nReturn: AX = internal counter controlling cursor visibility\r\n\n\tBX = cursor hot spot column\r\n\n\tCX = cursor hot spot row\r\n\n\tDX = mouse type (see #03179)\r\n",
      "002B": " MS MOUSE v7.0+ - LOAD ACCELERATION PROFILES\r\n\tBX = active acceleration profile\r\n\n\t    0001h-0004h or FFFFh to restore default curves\r\n\n\tES:SI -> buffer containing acceleration profile data (see #03180)\r\n\nReturn: AX = success flag\r\n",
      "002C": " MS MOUSE v7.0+ - GET ACCELERATION PROFILES\r\nReturn: AX = status (0000h success)\r\n\n\tBX = currently-active acceleration profile\r\n\n\tES:SI -> acceleration profile data (see #03180)\r\n",
      "002D": " MS MOUSE v7.0+ - SELECT ACCELERATION PROFILE\r\n\tBX = acceleration level\r\n\n\t    0001h-0004h to set profile, or FFFFh to get current profile\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t\tES:SI -> 16-byte blank-padded name of acceleration profile\r\n\n\t    FFFEh invalid acceleration curve number\r\n\n\t\tES:SI destroyed\r\n\n\tBX = active acceleration curve number\r\n",
      "002E": " MS MOUSE v8.10+ - SET ACCELERATION PROFILE NAMES\r\n\tBL = flag (if nonzero, fill ES:SI buffer with default names on return)\r\n\n\tES:SI -> 64-byte buffer containing profile names (16 bytes per name)\r\n\nReturn: AX = status (0000h success)\r\n\n\t    FFFEh error for ATI Mouse driver\r\n\n\tES:SI buffer filled with default names if BL nonzero on entry\r\n",
      "002F": " MS MOUSE v7.02+ - MOUSE HARDWARE RESET\r\nReturn: AX = status\r\n",
      "0030": " MS MOUSE v7.04+ - GET/SET BallPoint INFORMATION\r\n\tCX = command\r\n\n\t    0000h get status of BallPoint device\r\n\n\t    other set rotation angle and masks\r\n\n\t\tBX = rotation angle (-32768 to 32767 degrees)\r\n\n\t\tCH = primary button mask\r\n\n\t\tCL = secondary button mask\r\n\nReturn: AX = button status (FFFFh if no BallPoint) (see #03181)\r\n\n\tBX = rotation angle (0-360 degrees)\r\n\n\tCH = primary button mask\r\n\n\tCL = secondary button mask\r\n",
      "0031": " MS MOUSE v7.05+ - GET CURRENT MINIMUM/MAXIMUM VIRTUAL COORDINATES\r\nReturn: AX = virtual X minimum\r\n\n\tBX = virtual Y minimum\r\n\n\tCX = virtual X maximum\r\n\n\tDX = virtual Y maximum\r\n",
      "0032": " MS MOUSE v7.05+ - GET ACTIVE ADVANCED FUNCTIONS\r\nReturn: AX = active function flags (FFFFh for v8.10)\r\n\n\t    bit 15: function 0025h supported\r\n\n\t    bit 14: function 0026h supported\r\n\n\t    ...\r\n\n\t    bit 0:  function 0034h supported\r\n\n\tBX = ??? (0000h) officially unused\r\n\n\tCX = ??? (E000h) officially unused\r\n\n\tDX = ??? (0000h) officially unused\r\n",
      "0033": " MS MOUSE v7.05+ - GET SWITCH SETTINGS AND ACCELERATION PROFILE DATA\r\n\tCX = size of buffer\r\n\n\t    0000h get required buffer size\r\n\n\t\tReturn: AX = 0000h\r\n\n\t\t\tCX = required size (0154h for Logitech v6.10, 0159h\r\n\n\t\t\t\tfor MS v8.10-8.20)\r\n\n\t    other\r\n\n\t\tES:DX -> buffer of CX bytes for mouse settings\r\n\n\t\tReturn: AX = 0000h\r\n\n\t\t\tCX = number of bytes returned\r\n\n\t\t\tES:DX buffer filled (see #03182)\r\n",
      "0034": " MS MOUSE v8.0+ - GET INITIALIZATION FILE\r\nReturn: AX = status (0000h successful)\r\n\n\tES:DX -> ASCIZ initialization (.INI) file name\r\n",
      "0035": " MS MOUSE v8.10+ - LCD SCREEN LARGE POINTER SUPPORT\r\n\tBX = function\r\n\n\t    FFFFh get current settings\r\n\n\t\tReturn: AX = 0000h\r\n\n\t\t\tBH = style (see #03183)\r\n\n\t\t\tBL = size (see #03184)\r\n\n\t\t\tCH = threshold (00h-64h)\r\n\n\t\t\tCL = active flag (00h disabled, 01h enabled)\r\n\n\t\t\tDX = delay\r\n\n\t    other\r\n\n\t\tBH = pointer style (see #03183)\r\n\n\t\tBL = size (see #03184)\r\n\n\t\tCH = threshold (00h-64h)\r\n\n\t\tCL = active flag (00h disable size change, 01h enable)\r\n\n\t\tDX = delay (0000h-0064h)\r\n\n\t\tReturn: AX = 0000h\r\n",
      "0042": " PCMOUSE - GET MSMOUSE STORAGE REQUIREMENTS\r\nReturn: AX = status\r\n\n\t    0000h MSMOUSE not installed\r\n\n\t    0042h functions 42h, 50h, and 52h not supported\r\n\n\t    FFFFh successful\r\n\n\t\tBX = buffer size in bytes for functions 50h and 52h\r\n",
      "0043": " Mouse Systems MOUSE DRIVER v7.01+ - CONFIGURE MOUSE???\r\n\tCX:BX -> configuration buffer (see #03185)\r\n\n\tDL = ???\r\n\nReturn: ???\r\n",
      "0044": " Mouse Systems MOUSE DRIVER v7.01+ - TOGGLE IGNORE ACCELERATION CMDS\r\n\tCX = CDEFh\r\n\nReturn: AX = new state of \"Ignore Application Acceleration Commands\" flag\r\n",
      "0045": " Mouse Systems MOUSE DRIVER v7.01+ - TOGGLE RESOLUTION DOUBLING\r\n\tCX = CDEFh\r\n\nReturn: AX = new state of resolution doubling flag\r\n",
      "0047": " Mouse Systems MOUSE DRIVER v7.01+ - SET BUTTON ASSIGNMENTS\r\n\tES:BX -> button assignments (3 bytes, combinations of \"L\", \"M\", \"R\")\r\n\nReturn: ???\r\n",
      "0048": " Mouse Systems MOUSE DRIVER v7.01+ - GET ???\r\n\tBX = CDEFh\r\n\nReturn: CX = ???\r\n\n\tBH = ???\r\n\n\tBL = ??? (if 50h, driver is using PS/2 pointing device BIOS interface)\r\n",
      "004B": " LCS/Telegraphics MOUSE DRIVERS - INSTALLATION CHECK / GET VERSION\r\nReturn: ES:DI -> ASCIZ signature/description string if installed (see #03186)\r\n",
      "004C": " Mouse Systems MOUSE DRIVER v7.01+ - SET ??? FLAG\r\n\tBX = CDEFh\r\n",
      "004D": " MS MOUSE - RETURN POINTER TO COPYRIGHT STRING\r\nReturn: ES:DI -> copyright message \"*** This is Copyright 1983 Microsoft\" or\r\n\n\t\t\"Copyright 19XX....\"\r\n",
      "004F": " Mouse Systems MOUSE DRIVER v7.01+ - ENABLE MOUSE\r\nReturn: nothing\r\n",
      "0050": " PCMOUSE - SAVE MSMOUSE STATE\r\n\tBX = buffer size (ignored by some driver versions)\r\n\n\tES:DX -> buffer\r\n\nReturn: AX = FFFFh if successful\r\n",
      "0052": " PCMOUSE - RESTORE MSMOUSE STATE\r\n\tBX = buffer size (ignored by some driver versions)\r\n\n\tES:DX -> buffer\r\n\nReturn: AX = FFFFh if successful\r\n",
      "0053": " Mouse Systems MOUSE DRIVER v7.01+ - DISABLE MOUSE\r\nReturn: nothing\r\n",
      "0054": " Mouse Systems MOUSE DRIVER v7.01+ - SELECT ULTRARES ACCELERATION LEVEL\r\n\tCX = CDEFh\r\n\n\tBX = new acceleration level (0-9)\r\n\nReturn: ???\r\n",
      "0055": " Kraft Mouse - GET ???\r\nReturn: CX = ???\r\n\n\tDX = ???\r\n\n\tES = ???\r\n",
      "0058": " Mouse Systems MOUSE DRIVER v7.01+ - ???\r\nReturn: AX = CS of driver\r\n\n\tCX:BX = original INT 33 vector\r\n\n\tDX = ???\r\n",
      "005A": " Mouse Systems MOUSE DRIVER v7.01+ - SET ULTRARES ACCELERATIONS\r\n\tCX = number of WORDs to copy (max 0014h, but not range-checked)\r\n\n\tDX:SI -> buffer containing thresholds??? (CX words)\r\n\n\tDX:BX -> buffer containing acceleration values???\r\n\n\t\t(9*14h words, only first CX of each 14h used)\r\n\n\t???\r\n\nReturn: CF clear\r\n\n\t???\r\n",
      "0061": " Mouse Systems MOUSE DRIVER v7.01+ - ???\r\n\tBX = CDEFh\r\n\nReturn: CX = ???\r\n",
      "0067": " Mouse Systems MOUSE DRIVER v7.01+ - GET MOUSE BUTTONS???\r\nReturn: BL = number of buttons???\r\n",
      "006A": " ATI Mouse - INSTALLATION CHECK\r\nReturn: AL = AAh\r\n\n\tAH = ???\r\n\n\tBH = ???\r\n\n\tBL = ???\r\n\n\tCL = ???\r\n\n\tCH = ???\r\n",
      "006C": " Mouse Systems MOUSE DRIVER v7.01+ - CLEAR ??? FLAG\r\n\tBX = CDEFh\r\n",
      "0070": " Mouse Systems MOUSE DRIVER - POPUP.COM - INSTALLATION CHECK\r\n\tBX = ABCDh\r\n\nReturn: AX = ABCDh if installed\r\n\n\t    BX:CX -> data structure (see #03188)\r\n",
      "0072": " Mouse Systems MOUSE DRIVER v7.01+ - ???\r\n\tBX = ABCDh\r\n\nReturn: ???\r\n",
      "0073": " Mouse Systems MOUSE DRIVER v7.01+ - GET BUTTON ASSIGNMENTS\r\n\tBX = CDEFh\r\n\n\tES:DX -> 3-byte buffer for button assignments\r\n\nReturn: CX = number of buttons???\r\n\n\tES:DX buffer filled (default is \"LMR\")\r\n",
      "00A0": " TRUEDOX Mouse driver - SET HARDWARE PC MODE (3 button)\r\nReturn: nothing\r\n",
      "00A1": " TRUEDOX Mouse driver - SET HARDWARE MS MODE (2 button)\r\nReturn: nothing\r\n",
      "00A6": " TRUEDOX Mouse driver - SET RESOLUTION\r\n\tBX = new software resolution\r\n\n\t    0001h 50-200 dpi\r\n\n\t    0002h 200-400 dpi\r\n\n\t    0003h 400-800 dpi\r\n",
      "00B0": " LCS/Telegraphics MOUSE DRIVERS - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "00D6": " Twiddler TWMOUSE - GET BUTTON/TILT STATE\r\nReturn: AX = current button bitmap\r\n\n\tBX = current X tilt (approximately -200..+200 = -90degrees..+90deg.)\r\n\n\tCX = current Y tilt\r\n",
      "00F0": " LCS/Telegraphics MOUSE DRIVERS - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "00F1": " LCS/Telegraphics MOUSE DRIVERS - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "00F2": " LCS/Telegraphics MOUSE DRIVERS - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "00F3": " LCS/Telegraphics MOUSE DRIVERS - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "0100": " GRTMOUSE v1.00+ - INSTALLATION CHECK\r\n\tCX = 4752h ('GR')\r\n\n\tDX = 544Dh ('TM')\r\n\nReturn: AX = 474Dh ('GM') if installed\r\n\n\t    CX = version number (CH = major, CL = minor)\r\n",
      "0101": " GRTMOUSE v1.00+ - SET MOUSE CURSOR SHAPE\r\n\tDS:SI -> 16-byte cursor pattern\r\n\nReturn: CF clear if successful\r\n",
      "0102": " GRTMOUSE v1.00+ - GET MOUSE CURSOR SHAPE\r\n\tES:DI -> 16-byte buffer for cursor pattern\r\n",
      "0103": " GRTMOUSE v1.00+ - SET ACTIVE CHARACTERS\r\n\tCH,CL,DH,DL = ASCII codes to be remapped to display mouse pointer\r\n",
      "0104": " GRTMOUSE v1.00+ - GET ACTIVE CHARACTERS\r\nReturn: CH,CL,DH,DL = ASCII codes for the active characters\r\n",
      "012E": " MS MOUSE v8.10+ - ???\r\n\tBL = ???\r\n\nReturn: AX = 0000h (MS)\r\n\n\tAX = FFFFh (ATI Mouse v7.04)\r\n",
      "022E": " MS MOUSE v8.10+ - ???\r\n\tBL = ???\r\n\nReturn: AX = 0000h (MS)\r\n\n\tAX = FFFFh (ATI Mouse v7.04)\r\n",
      "0666": " TRUEDOX Mouse driver v4.01 - GET COPYRIGHT STRING\r\nReturn: DX:AX -> ASCII \"Copyright 1987-1992 TRUEDOX Technology Corporation\"\r\n",
      "136C": " LOGITECH MOUSE v6.10+ - ???\r\n\tBX = ???\r\n\nReturn: AX = ???\r\n\n\tBX = ???\r\n",
      "146C": " LOGITECH MOUSE v6.10+ - GET/SET ???\r\n\tBL = function\r\n\n\t    00h set ???\r\n\n\t\tBH = new value (zero/nonzero to clear/set)\r\n\n\t    else get ???\r\n\n\t\tReturn: ???\r\n",
      "156C": " LOGITECH MOUSE v6.10+ - GET SIGNATURE AND VERSION STRINGS\r\nReturn: ES:DI -> signature \"LOGITECH MOUSE DRIVER\"\r\n\n\tES:SI -> version string, terminated with CRLF\r\n",
      "166C": " LOGITECH MOUSE v6.10+ - ???\r\n\tBL = ???\r\n\n\t    00h ???\r\n\n\t    01h ???\r\n\n\t    other ???\r\n\n\t\tBH = new value of ???\r\n\n\t\tReturn: AX = FFFFh\r\n",
      "176C": " LOGITECH MOUSE v6.10+ - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "186C": " LOGITECH MOUSE v6.10+ - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "196C": " LOGITECH MOUSE v6.10+ - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "1A6C": " LOGITECH MOUSE v6.10+ - GET ???\r\nReturn: AX = FFFFh\r\n\n\tBX = ???\r\n\n\tCX = ???\r\n",
      "1B6C": " LOGITECH MOUSE v6.10+ - SET ???\r\n\tBX = new value for ??? (0000h-0003h)\r\n\nReturn: AX = FFFFh\r\n",
      "1C6C": " LOGITECH MOUSE v6.10+ - ???\r\n\tBX = ???\r\n\n\t    <42h ???\r\n\n\t    =42h ???\r\n\n\t    >42h ???\r\n\n\t\tES:DI -> ???\r\n\n\t\tReturn: AX = ???\r\n",
      "1D6C": " LOGITECH MOUSE - GET COMPASS PARAMETER\r\nReturn: BX = direction (0=north, 1=south, 2=east, 3=west)\r\n",
      "1E6C": " LOGITECH MOUSE - SET COMPASS PARAMETER\r\n\tBX = direction (0=north, 1=south, 2=east, 3=west)\r\n",
      "1F6C": " LOGITECH MOUSE - GET BALLISTICS INFORMATION\r\nReturn: BX = 0=off, 1=on\r\n\n\tCX = 1=low, 2=high\r\n",
      "206C": " LOGITECH MOUSE - SET LEFT OR RIGHT PARAMETER\r\n\tBX = parameter (00h = right, FFh = left)\r\n",
      "216C": " LOGITECH MOUSE - GET LEFT OR RIGHT PARAMETER\r\nReturn: BX = parameter (00h = right, FFh = left)\r\n",
      "226C": " LOGITECH MOUSE - REMOVE DRIVER FROM MEMORY\r\n",
      "236C": " LOGITECH MOUSE - SET BALLISTICS INFORMATION\r\n\tBX = 0=off, 1=on\r\n\n\tCX = 1=low, 2=high\r\n",
      "246C": " LOGITECH MOUSE - GET PARAMETERS AND RESET SERIAL MOUSE\r\n\tES:DX -> parameter table buffer (see #03190)\r\n\nReturn: AX = FFFFh if driver installed for serial mouse\r\n",
      "256C": " LOGITECH MOUSE - SET PARAMETERS - SET MOUSE LOGICAL BUTTONS\r\n\tBX = 0004h\r\n\n\tCX = buttons (2, 3)\r\n\nReturn: AX = FFFFh if driver installed for serial mouse\r\n",
      "266C": " LOGITECH MOUSE - GET VERSION???\r\nReturn: BX = 'SS'\r\n\n\tCH = '4'  major version number\r\n\n\tCL = '1'  minor version number\r\n",
      "276C": " LOGITECH MOUSE - ??? Tries MMSeries, Baud 2400\r\n",
      "3000": " Smooth Mouse Driver, PrecisePoint - INSTALLATION CHECK\r\nReturn: AX = FFFFh if installed\r\n\n\t    BX = version number (BH = major, BL = minor)\r\n",
      "3001": " Smooth Mouse Driver, PrecisePoint - ENABLE SMOOTH MOUSE\r\nReturn: AX = status (0000h = disabled, 0001h = enabled)\r\n",
      "3002": " Smooth Mouse Driver, PrecisePoint - DISABLE SMOOTH MOUSE\r\nReturn: AX = status (0000h = disabled, 0001h = enabled)\r\n",
      "3003": " Smooth Mouse Driver, PrecisePoint - GET INFORMATION\r\n\tBL = data structure selector\r\n\n\t    00h Primary Bitmap (used for 25 line mode) (see #03192)\r\n\n\t    01h Secondary Bitmap (used for 43/50 line modes) (see #03192)\r\n\n\t    02h Sacrifice Character Map (see #03193)\r\n\n\t    03h Program Information (see #03194)\r\n\nReturn: ES:DX -> selected data structure\r\n",
      "3004": " Smooth Mouse Driver, PrecisePoint - RESERVED FUTURE EXPANSION\r\n",
      "3005": " Smooth Mouse Driver, PrecisePoint - RESERVED FUTURE EXPANSION\r\n",
      "4F00": " LOGITECH MOUSE v6.10+ - GET ???\r\nReturn: AX = 004Fh if supported\r\n\n\tBX = ???\r\n\n\tES:DI -> ???\r\n",
      "4F01": " LOGITECH MOUSE v6.10+ - ???\r\n\tES = ???\r\n\nReturn: AX = 004Fh if supported\r\n\n\tES:DI -> ???\r\n",
      "6F00": " Hewlett Packard - HP MOUSE DRIVER INSTALLATION CHECK\r\n\tBX <> 4850h\r\n\nReturn: BX = 4850h ('HP') if mouse driver written by Hewlett Packard\r\n",
      "8800": " InfoTrack IMOUSE.COM - GET ACTIVE IRQ\r\n\tBX = FFFFh\r\n\nReturn: BL = number of IRQ being used by the mouse\r\n",
      "FFE6": " Switch-It v3.23 - GET ??? PROGRAM\r\n\tCX = length of buffer\r\n\n\tES:DI -> buffer for program name\r\n\nReturn: ES:DI buffer filled\r\n",
      "FFE7": " Switch-It v3.23 - GET ???\r\nReturn: AX = ???\r\n",
      "FFE8": " Switch-It v3.23 - ???\r\n\tCX = length of name including terminating NUL\r\n\n\tDS:SI -> ASCIZ program pathname\r\n",
      "FFE9": " Switch-It v3.23 - SET ???\r\n\tBX = ???\r\n",
      "FFEA": " Switch-It v3.23 - SET ???\r\n\tBL = ???\r\n",
      "FFEB": " Switch-It v3.23 - SET ??? FLAG\r\n",
      "FFEC": " Switch-It v3.23 - SET ???\r\n\tBL = ???\r\n",
      "FFED": " Switch-It v3.23 - GET ???\r\nReturn: AX = ??? (0001h)\r\n\n\tBX = ???\r\n",
      "FFEE": " Switch-It v3.23 - GET ???\r\nReturn: AX = ???\r\n",
      "FFEF": " Switch-It v3.23 - GET ???\r\nReturn: BX:AX -> ???\r\n",
      "FFF0": " Switch-It v3.23 - SET ???\r\n\tBL = ???\r\n",
      "FFF1": " Switch-It v3.23 - GET CONFIGURATION FILE\r\nReturn: BX:AX -> ASCIZ pathname of configuration file\r\n",
      "FFF2": " Switch-It v3.23 - SET ??? FLAG\r\nReturn: AL = 01h\r\n",
      "FFF3": " Switch-It v3.23 - GET ???\r\nReturn: AX = ???\r\n",
      "FFF4": " Switch-It v3.23 - SET ???\r\n\tBX = ???\r\n\n\tCX = ???\r\n",
      "FFF5": " Switch-It v3.23 - GET ???\r\nReturn: AX = ???\r\n",
      "FFF6": " Switch-It v3.23 - GET ???\r\nReturn: AX = ???\r\n",
      "FFF7": " Switch-It v3.23 - GET ???\r\n\tBX = index of ???\r\n\nReturn: AX = ???\r\n",
      "FFF8": " Switch-It v3.23 - ???\r\n\tBX = ???\r\n\n\tCX = length of program name, including terminating NUL\r\n\n\tDS:SI -> ASCIZ program pathname\r\n\nReturn: ???\r\n",
      "FFF9": " Switch-It v3.23 - NOP\r\n",
      "FFFA": " Switch-It v3.23 - SET ???\r\n\tBX = index of program\r\n",
      "FFFB": " Switch-It v3.23 - GET ???\r\n\tBX = index of program\r\n\nReturn: AX = ??? (0000h or 0001h)\r\n",
      "FFFC": " Switch-It v3.23 - CLEAR ???\r\n\tBX = index of program\r\n",
      "FFFD": " Switch-It v3.23 - GET MEMORY ADDRESSES???\r\nReturn: AX = first available segment???\r\n\n\tBX = paragraph of top of conventional memory\r\n\n\tDX = PSP segment of SI.EXE\r\n",
      "FFFE": " Switch-It v3.23 - INSTALLATION CHECK\r\nReturn: BX = ???\r\n\n\tDX = 5349h (\"SI\")\r\n",
      "FFFF": " Switch-It v3.23 - ???\r\n\tBX = ???\r\n"
    }
  },
  "40": " DISKETTE - ROM BIOS DISKETTE HANDLER RELOCATED BY HARD DISK BIOS\r\n",
  "41": " SYSTEM DATA - HARD DISK 0 PARAMETER TABLE ADDRESS [NOT A VECTOR!]\r\n",
  "42": {
    "AX": {
      "5F33": " Chips & Technologies '65530' BIOS - MODE SET HOOK\r\n\tBL = current width in characters\r\n\n\tBH = curent video mode\r\n\n\tCH = active display page\r\n\nReturn:\tnothing\r\n",
      "7500": " Toshiba laptops - ???\r\n\tBL = ??? (00h or 01h)\r\n\nReturn: ???\r\n",
      "7501": " Toshiba laptop - GET ??? DATA\r\n\tDS:DI -> data area to be filled ???\r\n\nReturn: area filled with data ???\r\n",
      "7502": " Toshiba laptops - SET ??? DATA\r\n\tDS:DI -> data area ???\r\n\nReturn: ???\r\n",
      "7503": " Toshiba laptops - GET DISPLAY STATUS\r\nReturn: AX = 7575h if supported\r\n\n\tCX = 0001h if supported\r\n\n\tBH = display type (00h color, 03h monochrome)\r\n\n\tBL = display state\r\n\n\t    01h internal LCD display is active\r\n\n\t    02h external VGA display is active\r\n\n\t    03h both displays active / DeskStation display mode enabled\r\n\n\t\t(not possible on all machines)\r\n",
      "7504": " Toshiba laptops - ???\r\n\tBL = ???\r\n\nReturn: BH = ???\r\n"
    }
  },
  "43": " VIDEO DATA - CHARACTER TABLE (EGA,MCGA,VGA)\r\n",
  "44": " VIDEO DATA - ROM BIOS CHARACTER FONT, CHARACTERS 00h-7Fh (PCjr)\r\n",
  "46": " SYSTEM DATA - HARD DISK 1 DRIVE PARAMETER TABLE ADDRESS [NOT A VECTOR!]\r\n",
  "48": {
    "AX": {
      "1A70": " Compaq UILIB.EXE - INSTALLATION CHECK\r\n\tBX = call type (see #03207)\r\n\nReturn: CX = 5649h ('VI') if installed\r\n\n\tDX = 4557h ('EW') if installed\r\n\n\t    AX = version??? (0106h)\r\n"
    }
  },
  "49": {
    "AH": {
      "01": " TI Professional PC - CRT - SET CURSOR SIZE AND TYPE\r\n\tCH = cursor start line (bits 3-0) and status (bits 6-5)\r\n\n\t    status bits:\r\n\n\t\t00 non-blinking cursor\r\n\n\t\t01 no cursor\r\n\n\t\t10 fast-blinking cursor\r\n\n\t\t11 slow-blinking cursor\r\n\n\tCL = cursor end line\r\n\nReturn: nothing\r\n",
      "02": " TI Professional PC - CRT - SET CURSOR POSITION\r\n\tDH = column\r\n\n\tDL = row\r\n\nReturn: DX destroyed\r\n",
      "03": " TI Professional PC - CRT - GET CURSOR POSTION AND TYPE\r\nReturn: CH = cursor start and status (see AH=01h)\r\n\n\tCL = cursor end line\r\n\n\tDH = cursor column\r\n\n\tDL = cursor row\r\n",
      "06": " TI Professional PC - CRT - SCROLL UP/COPY WINDOW\r\n\tAL = source blanking\r\n\n\t    00h blank source region (move/scroll)\r\n\n\t    nonzero do not blank source region (copy)\r\n\n\tDH,DL = source start column,row\r\n\n\tBH,BL = destination start column,row\r\n\n\tCH = width of region to move/copy\r\n\n\tCL = height of region to move/copy\r\n\nReturn: nothing\r\n",
      "07": " TI Professional PC - CRT - SCROLL DOWN/COPY WINDOW\r\n\tAL = source blanking\r\n\n\t    00h blank source region (move/scroll)\r\n\n\t    nonzero do not blank source region (copy)\r\n\n\tDH,DL = source start column,row\r\n\n\tBH,BL = destination start column,row\r\n\n\tCH = width of region to move/copy\r\n\n\tCL = height of region to move/copy\r\n\nReturn: nothing\r\n",
      "08": " TI Professional PC - CRT - GET CHARACTER AND ATTRIBUTE AT POSITION\r\nReturn: AL = character at current cursor position\r\n\n\tAH = attribute\r\n",
      "09": " TI Professional PC - CRT - WRITE CHARACTER(S) WITH ATTRIBUTE\r\n\tAL = character to write\r\n\n\tBL = attribute to use (becomes new current attribute)\r\n\n\tCX = number of times to write character\r\n\nReturn: nothing\r\n",
      "0A": " TI Professional PC - CRT - WRITE CHARACTER(S) WITH CURRENT ATTRIBUTE\r\n\tAL = character to write\r\n\n\tCX = number of times to write character\r\n\nReturn: nothing\r\n",
      "0E": " TI Professional PC - CRT - TTY OUTPUT\r\n\tAL = character to write\r\n\nReturn: nothing\r\n",
      "10": " TI Professional PC - CRT - WRITE BLOCK OF CHARACTERS WITH ATTRIBUTE\r\n\tAL = attribute (becomes new current attribute)\r\n\n\tDX:BX -> string of characters to write\r\n\n\tCX = length of string\r\n\nReturn: nothing\r\n",
      "11": " TI Professional PC - CRT - WRITE BLOCK OF CHARACTERS WITH CURR ATTRIB\r\n\tDX:BX -> string of characters to write\r\n\n\tCX = length of string\r\n\nReturn: nothing\r\n",
      "12": " TI Professional PC - CRT - FILL ENTIRE SCREEN WITH ATTRIBUTE\r\n\tAL = attribute (see #03210)\r\n\nReturn: nothing\r\n",
      "13": " TI Professional PC - CRT - CLEAR ENTIRE TEXT SCREEN AND HOME CURSOR\r\nReturn: nothing\r\n",
      "14": " TI Professional PC - CRT - CLEAR ENTIRE GRAPHICS SCREEN\r\nReturn: nothing\r\n",
      "15": " TI Professional PC - CRT - SET PROTECTED STATUS AREA\r\n\tCL = row at which to start status area, or 00h to cancel\r\n\n\tCH = 00h\r\n\nReturn: nothing\r\n",
      "16": " TI Professional PC - CRT - SET ATTRIBUTE LATCH\r\n\tBL = new attribute (see #03210)\r\n\nReturn: nothing\r\n",
      "17": " TI Professional PC - CRT - GET START-OF-DISPLAY POINTER\r\nReturn: DX = current offset at which display starts\r\n",
      "18": " TI Professional PC - CRT - PRINT TTY STRING\r\n\tCS:BX -> counted string (count byte with length followed by string)\r\n\nReturn: nothing\r\n"
    }
  },
  "4A": " SYSTEM - USER ALARM HANDLER\r\n",
  "4D": {
    "AH": {
      "00": " TI Professional PC - DISK - RESET DISK SYSTEM\r\n\tDL = drive (if bit 7 is set both hard disks and floppy disks reset)\r\n\nReturn: AH = status (see #00234 at INT 13/AH=01h)\r\n\n\tCF clear if successful (returned AH=00h)\r\n\n\tCF set on error\r\n",
      "01": " TI Professional PC - DISK - GET STATUS OF LAST OPERATION\r\n\tDL = drive (bit 7 set for hard disk)\r\n\nReturn: CF clear if status unchanged\r\n\n\tCF set if status changed since last call\r\n\n\tAH = 00h\r\n\n\tAL = status of previous operation (see #00234 at INT 13/AH=01h)\r\n",
      "02": " TI Professional PC - DISK - READ SECTOR(S) INTO MEMORY\r\n\tAL = number of sectors to read (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF set on error\r\n\n\t    if AH = 11h (corrected ECC error), AL = burst length\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at INT 13/AH=01h)\r\n\n\tAL = number of sectors transferred\r\n\n\tES:BX -> buffer for last sector processed (including one with errors)\r\n",
      "03": " TI Professional PC - DISK - WRITE SECTOR(S) FROM MEMORY\r\n\tAL = number of sectors to write (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> buffer containing data\r\n\nReturn: CF set on error\r\n\n\t    if AH = 11h (corrected ECC error), AL = burst length\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at INT 13/AH=01h)\r\n\n\tAL = number of sectors transferred\r\n\n\tES:BX -> buffer for last sector processed (including one with errors)\r\n",
      "04": " TI Professional PC - DISK - VERIFY DISK SECTOR CRC(S)\r\n\tAL = number of sectors to verify (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF set on error\r\n\n\t    if AH = 11h (corrected ECC error), AL = burst length\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at INT 13/AH=01h)\r\n\n\tAL = number of sectors transferred\r\n\n\tES:BX -> buffer for last sector processed (including one with errors)\r\n",
      "05": " TI Professional PC - DISK - NOP\r\n",
      "06": " TI Professional PC - DISK - VERIFY DISK SECTOR(S)\r\n\tAL = number of sectors to verify (must be nonzero)\r\n\n\tCH = low eight bits of cylinder number\r\n\n\tCL = sector number 1-63 (bits 0-5)\r\n\n\t     high two bits of cylinder (bits 6-7, hard disk only)\r\n\n\tDH = head number\r\n\n\tDL = drive number (bit 7 set for hard disk)\r\n\n\tES:BX -> data buffer\r\n\nReturn: CF set on error\r\n\n\t    if AH = 11h (corrected ECC error), AL = burst length\r\n\n\tCF clear if successful\r\n\n\tAH = status (see #00234 at INT 13/AH=01h)\r\n\n\tAL = number of sectors transferred\r\n\n\tES:BX -> buffer for last sector processed (including one with errors)\r\n",
      "07": " TI Professional PC - DISK - GET RETRY STATUS OF LAST OPERATION\r\n\tDL = drive (bit 7 set for hard disk)\r\n\nReturn: CF clear if status unchanged\r\n\n\tCF set if status changed since last call\r\n\n\tAH = 00h\r\n\n\tAL = status of previous operation (see #00234 at INT 13/AH=01h)\r\n",
      "08": " TI Professional PC - DISK - SET STANDARD DEVICE INTERFACE TABLE\r\n\tDL = drive number (00h-03h)\r\n\n\tAL = drive type\r\n\n\t    00h single-sided 48 tpi (40-track, 8 sectors, 512 bytes/sector)\r\n\n\t    01h double-sided 48 tpi (40-track, 8 sectors, 512 bytes/sector)\r\n\n\t    02h single-sided 96 tpi (80-track, 8 sectors, 512 bytes/sector)\r\n\n\t    03h double-sided 96 tpi (80-track, 8 sectors, 512 bytes/sector)\r\n\nReturn: nothing???\r\n",
      "09": " TI Professional PC - DISK - SET DEVICE INTERFACE TABLE ADDRESS\r\n\tDL = drive number (00h-07h)\r\n\n\tES:BX -> Device Interface Table (see #03226)\r\n\nReturn: nothing???\r\n",
      "0A": " TI Professional PC - DISK - GET DEVICE INTERFACE TABLE ADDRESS\r\n\tDL = drive number (00h-07h)\r\n\nReturn: AH = status\r\n\n\tES:BX -> Device Interface Table (see #03226)\r\n",
      "0B": " TI Professional PC - DISK - TURN OFF ALL DRIVES\r\nReturn: AH = 00h\r\n"
    }
  },
  "50": {
    "AX": {
      "0000": " Vanderaart TEXT WINDOWS, PC Thuis Shell - OPEN TEXT WINDOW\r\n\tES:BX -> name string or ES:0000h if none\r\n\n\tCH,CL = row,column of upper left corner\r\n\n\tDH,DL = row,column of lower right corner\r\n\nReturn: AX = window handle or\r\n\n\t    0000h if not installed\r\n\n\t    FFFFh on error\r\n",
      "0001": " Vanderaart TEXT WINDOWS, PC Thuis Shell - CLOSE TEXT WINDOW\r\n\tDI = window handle\r\n",
      "0002": " Vanderaart TEXT WINDOWS - PUT CHARACTER IN WINDOW\r\n\tBL = character\r\n\n\tBH = attribute\r\n\n\tDL = column\r\n\n\tDH = row\r\n\n\tDI = window handle\r\n\nReturn: AX = status\r\n\n\t    0000h if successful\r\n\n\t    FFFFh if outside window\r\n",
      "0003": " Vanderaart TEXT WINDOWS - OUTPUT LINE TO WINDOW\r\n\tES:BX -> text string\r\n\n\tCX = string length (0000h if ASCIZ string)\r\n\n\tDL = position (FFh centered, else flush left)\r\n\n\tDH = starting row\r\n\n\tDI = window handle\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh did not fit in window\r\n",
      "0004": " Vanderaart TEXT WINDOWS - GET KEY\r\n\tCH = type\r\n\n\t    00h any key\r\n\n\t    01h 'J' or 'N' (Dutch for yes/no)\r\n\nReturn: AX = key\r\n",
      "0005": " Vanderaart TEXT WINDOWS - CHANGE ATTRIBUTE\r\n\tBL = new attribute\r\n\n\tCH,CL = row,column of upper left corner\r\n\n\tDH,DL = row,column of lower right corner\r\n\n\tDI = window handle\r\n",
      "0006": " Vanderaart TEXT WINDOWS - EDIT LINE IN WINDOW\r\n\tES:BX -> text string\r\n\n\tCH = type of input (see #03242)\r\n\n\tDH,DL = row,column of upper left corner\r\n\n\tDI = window handle\r\n\nReturn: AX = key which terminated entry\r\n\n\t    0000h Enter\r\n\n\t    0001h Esc\r\n\n\t    0002h Down arrow\r\n\n\t    0003h Up arrow\r\n\n\t    0004h F10\r\n"
    }
  },
  "51": " IRQ1 relocated by DESQview\r\n",
  "52": " IRQ2 relocated by DESQview\r\n",
  "53": " IRQ3 relocated by DESQview\r\n",
  "54": " IRQ4 relocated by DESQview\r\n",
  "55": " IRQ5 relocated by DESQview\r\n",
  "56": " IRQ6 relocated by DESQview\r\n",
  "57": " IRQ7 relocated by DESQview\r\n",
  "58": " IRQ8 relocated by DESQview 2.26+\r\n",
  "59": " IRQ9 relocated by DESQview 2.26+\r\n",
  "5A": " IRQ10 relocated by DESQview 2.26+\r\n",
  "5B": " IRQ11 relocated by DESQview 2.26+\r\n",
  "5C": " IRQ12 relocated by DESQview 2.26+\r\n",
  "5D": " IRQ13 relocated by DESQview 2.26+\r\n",
  "5E": " IRQ14 relocated by DESQview 2.26+\r\n",
  "5F": " IRQ15 relocated by DESQview 2.26+\r\n",
  "60": " Nabbit v2.0 - (NOT A VECTOR!) - INSTALLATION CHECK\r\n",
  "61": {
    "AX": {
      "0000": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - ZOOM DISPLAY\r\n\tBX = zoom factor (0-7)\r\n",
      "0001": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - CENTER ZOOM WINDOW\r\n\tBX = X coordinate to center\r\n\n\tCX = Y coordinate to center\r\n",
      "0002": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - END ZOOM\r\n",
      "0003": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - REPORT ZOOM FACTOR\r\nReturn: AX = zoom factor\r\n",
      "0004": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - ENTER SPECIFY MODE\r\n",
      "0005": " OPTIMA 1024 VGA-Sync - QUERY ZOOM WINDOW\r\n\tBX:CX -> buffer for window parameters (see #03429)\r\n",
      "0006": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - SET ZOOM WINDOW\r\n\tBX:CX -> zoom window description (see #03430)\r\n",
      "0007": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - QUERY APPLICATION KEY\r\nReturn: AX = current state (0000h/0001h)\r\n",
      "0008": " OPTIMA 1024 VGA-Sync,ET-3000 chipset - SET ZOOM OFFSET\r\n\tBX = X start of zoom offset\r\n\n\tCX = Y start of zoom offset\r\n"
    }
  },
  "62": {
    "AX": {
      "0000": " FGDRIVER v3.03+ - \"FG_ALLOCATE\" - CREATE VIRTUAL VIDEO PAGE\r\n\tBX = page number (0000h-003Fh)\r\n\nReturn: AX = status (0000h,0001h,0007h,0008h) (see #03473)\r\n",
      "0001": " FGDRIVER v3.03+ - \"FG_ALLOCCMS\" - CREATE LOGICAL VIDEO PAGE (CONV)\r\n\tBX = page number (0001h-003Fh)\r\n\nReturn: AX = status (0000h,FFFCh,FFFDh,FFFEh) (see #03473)\r\n",
      "0002": " FGDRIVER v3.03+ - \"FG_ALLOCEMS\" - CREATE LOGICAL VIDEO PAGE (EMS)\r\n\tBX = page number (0001h-003Fh)\r\n\nReturn: AX = status (0000h,FFFCh,FFFDh,FFFEh) (see #03473)\r\n",
      "0003": " FGDRIVER v3.03+ - \"FG_ALLOCXMS\" - CREATE LOGICAL VIDEO PAGE (XMS)\r\n\tBX = page number (0001h-003Fh)\r\n\nReturn: AX = status (0000h,FFFCh,FFFDh,FFFEh) (see #03473)\r\n",
      "0004": " FGDRIVER 1.10,3.03+ - \"FG_AUTOMODE\" - GET VIDEO MODE W/MOST FEATURES\r\nReturn: AX = proposed video mode number (see #03500 at AX=00B0h)\r\n",
      "0005": " FGDRIVER v3.03+ - \"FG_BESTMODE\" - GET BEST VIDEO MODE GIVEN RESOLUTN\r\n\tBX = horizontal resolution\r\n\n\tCX = vertical resolution\r\n\n\tDX = number of video pages required (both physical and virtual)\r\n\nReturn: AX = proposed video mode number or FFFFh if no matching video mode\r\n",
      "0006": " FGDRIVER v3.03+ - \"FG_BOX\" - DRAW UNFILLED RECTANGLE\r\n\tBX = left column\r\n\n\tCX = right column\r\n\n\tDX = top row\r\n\n\tSI = bottom row\r\n",
      "0007": " FGDRIVER v3.03+ - \"FG_BOXDEPTH\" - SET RECTANGLE BORDER WIDTH\r\n\tBX = width of left and right edges in pixels (> 0)\r\n\n\tCX = width of top and bottom edges in pixels (> 0)\r\n",
      "0008": " FGDRIVER v3.03+ - \"FG_BOXX\" - XOR HOLLOW RECTANGLE\r\n\tBX = left column\r\n\n\tCX = right column\r\n\n\tDX = top row\r\n\n\tSI = bottom row\r\n",
      "0009": " FGDRIVER v3.03+ - \"FG_BUTTON\" - GET JOYSTICK BUTTON STATE\r\n\tBX = joystick number (0001h or 0002h)\r\n\nReturn: AX = button states\r\n\n\t    bit 0: top button pressed\r\n\n\t    bit 1: bottom button pressed\r\n",
      "000A": " FGDRIVER v3.03+ - \"FG_CAPSLOCK\" - GET STATE OF CAPSLOCK KEY\r\nReturn: AX = CapsLock state (0000h off, 0001h on)\r\n",
      "000B": " FGDRIVER v3.03+ - \"FG_CHGATTR\" - APPLY CURRENT TEXT ATTRIB TO CHARS\r\n\tBX = number of characters to recolor\r\n",
      "000C": " FGDRIVER v3.03+ - \"FG_CHGTEXT\" - DISPLAY STRING AT CURSOR POSITION\r\n\tCX = length of string\r\n\n\tES:BX -> string to be displayed\r\n\nReturn: text cursor updated\r\n",
      "000D": " FGDRIVER v3.03+ - \"FG_CIRCLE\" - DRAW UNFILLED CIRCLE\r\n\tBX = radius in horizontal screen space units (> 0)\r\n",
      "000E": " FGDRIVER v3.03+ - \"FG_CIRCLEF\" - DRAW FILLED CIRCLE\r\n\tBX = radius in horizontal screen space units (> 0)\r\n",
      "000F": " FGDRIVER v4.02 - \"FG_CLIPMAP\" - DISPLAY CLIPPED IMAGE (MODE-INDEP)\r\n\tES:BX -> bitmap\r\n\n\tCX = width\r\n\n\tDX = height\r\n",
      "0010": " FGDRIVER v4.02 - \"FG_CLIPMASK\" - DISPLAY CLIPPED IMAGE (MASKING MAP)\r\n\tES:BX -> array containing image stored as a masking map (see #03475)\r\n\n\tCX = number of pixel runs in masking map\r\n\n\tDX = width of masking map in pixels\r\n",
      "0011": " FGDRIVER v4.02 - \"FG_CLPIMAGE\" - DISPLAY CLIPPED IMAGE (BITMAP)\r\n\tES:BX -> mode-specific bitmap\r\n\n\tCX = width of bit map in bytes\r\n\n\tDX = height of bit map in pixel rows\r\n",
      "0012": " FGDRIVER v4.02 - \"FG_CLPRECT\" - DRAW FILLED RECTANGLE IN SCREEN SPCE\r\n\tBX = screen space column of left edge\r\n\n\tCX = screen space column of right edge\r\n\n\tDX = screen space row of top edge\r\n\n\tSI = screen space row of bottom edge\r\n",
      "0013": " FGDRIVER v4.02 - \"FG_COLORS\" - GET SIMULTANEOUSLY-AVAILABLE COLORS\r\nReturn: AX = number of colors available at one time\r\n",
      "0014": " FGDRIVER v4.02 - \"FG_COPYPAGE\" - TRANSFER VIDEO PAGE CONTENTS\r\n\tBX = source page number (0000h-003Fh)\r\n\n\tCX = destination page number (0000h-003Fh)\r\n",
      "0015": " FGDRIVER v4.02 - \"FG_CURSOR\" - SPECIFY WHETHER TEXT CURSR IS VISIBLE\r\n\tBX = new state (0000h invisible, 0001h visible)\r\n",
      "0016": " FGDRIVER v4.02 - \"FG_DASH\" - DRAW DASHED LINE TO ABSOLUTE POSITION\r\n\tBX = endpoint column\r\n\n\tCX = endpoint row\r\n\n\tDX = dash pattern (set bits cause drawn pixels)\r\n",
      "0017": " FGDRIVER v4.02 - \"FG_DASHREL\" - DRAW DASHED LINE TO RELATVE POSITION\r\n\tBX = endpoint column offset\r\n\n\tCX = endpoint row offset\r\n\n\tDX = dash pattern (set bits cause drawn pixels)\r\n",
      "0018": " FGDRIVER v4.02 - \"FG_DEFCOLOR\" - ASSIGN COLOR VALUE TO COLOR INDEX\r\n\tBX = color index (0000h-00FFh)\r\n\n\tCX = new color value (0 to maximum color value for current video mode)\r\n",
      "0019": " FGDRIVER v4.02 - \"FG_DEFPAGES\" - DEF SRC/DEST PAGES FOR BLOCK XFERS\r\n\tBX = source page\r\n\n\tCX = destination page\r\n",
      "001A": " FGDRIVER v4.02 - \"FG_DISPFILE\" - DISPLAY STORED IMAGE\r\n\tES:BX -> ASCIZ filename\r\n\n\tCX = image width in pixels (> 0)\r\n\n\tDX = image format\r\n\n\t    0000h Fastgraph standard pixel run format\r\n\n\t    0001h packed pixel run format\r\n",
      "001B": " FGDRIVER v4.02 - \"FG_DISPLAY\" - DISPLAY IMAGE (STD PIXEL RUN FORMAT)\r\n\tES:BX -> pixel run map (pairs of bytes: color index, count)\r\n\n\tCX = number of pixel runs to display\r\n\n\tDX = width of image in pixels (> 0)\r\n",
      "001C": " FGDRIVER v4.02 - \"FG_DISPLAYP\" - DISPLAY IMAGE (PACKED PIXEL RUNS)\r\n\tES:BX -> pixel run map (trios of bytes: colors, count1, count2; colors\r\n\n\t\t  contains the color for the first run in its high nybble and\r\n\n\t\t  the color for the second run in its low nybble)\r\n\n\tCX = number of pixel runs to display\r\n\n\tDX = width of image in pixels (> 0)\r\n",
      "001D": " FGDRIVER v4.02 - \"FG_DRAW\" - DRAW SOLID LINE TO ABSOLUTE POSITION\r\n\tBX = endpoint column\r\n\n\tCX = endpoint row\r\n",
      "001E": " FGDRIVER v4.02 - \"FG_DRAWMAP\" - DISPLAY MODE-INDEPENDENT BIT MAP\r\n\tES:BX -> bitmap (each set bit is pixel drawn in current color)\r\n\n\tCX = width of bitmap in bytes\r\n\n\tDX = height of bitmap in pixel rows\r\n",
      "001F": " FGDRIVER v4.02 - \"FG_DRAWMASK\" - DISPLAY IMAGE (MASKING MAP)\r\n\tES:BX -> array containing image stored as a masking map (see #03475)\r\n\n\tCX = number of pixel runs in masking map\r\n\n\tDX = width of masking map in pixels\r\n",
      "0020": " FGDRIVER v4.02 - \"FG_DRAWREL\" - DRAW SOLID LINE TO RELATIVE POSITION\r\n\tBX = endpoint column offset\r\n\n\tCX = endpoint row offset\r\n",
      "0021": " FGDRIVER v4.02 - \"FG_DRAWRELX\" - XOR SOLID LINE TO RELATIVE POSITION\r\n\tBX = endpoint column offset\r\n\n\tCX = endpoint row offset\r\n",
      "0022": " FGDRIVER v4.02 - \"FG_DRAWX\" - XOR SOLID LINE TO ABSOLUTE POSITION\r\n\tBX = endpoint column\r\n\n\tCX = endpoint row\r\n",
      "0023": " FGDRIVER v4.02 - \"FG_DRECT\" - DRAW DITHERED RECTANGLE IN SCRN SPACE\r\n\tBX = screen space column of left edge\r\n\n\tCX = screen space column of right edge\r\n\n\tDX = screen space row of top edge\r\n\n\tSI = screen space row of bottom edge\r\n\n\tES:DI -> dithering matrix (video-mode dependent)\r\n",
      "0024": " FGDRIVER v4.02 - \"FG_DRWIMAGE\" - DISPLAY BITMAPPED IMAGE\r\n\tES:BX -> video mode-specific bitmap\r\n\n\tCX = width of bitmap in bytes\r\n\n\tDX = height of bitmap in pixel rows\r\n",
      "0025": " FGDRIVER v4.02 - \"FG_EGACHECK\" - GET INFO ABOUT ACTIVE EGA DISPLAY\r\nReturn: AX = number of 64K banks of video memory, or 0000h if no EGA or EGA\r\n\n\t      without an Enhanced Color Display\r\n",
      "0026": " FGDRIVER v4.02 - \"FG_ELLIPSE\" - DRAW UNFILLED ELLIPSE IN SCRN SPACE\r\n\tBX = horizontal semi-axis length in screen space units\r\n\n\tCX = vertical semi-axis length in screen space units\r\n",
      "0027": " FGDRIVER v4.02 - \"FG_ELLIPSEF\" - DRAW FILLED ELLIPSE IN SCREEN SPACE\r\n\tBX = horizontal semi-axis length in screen space units\r\n\n\tCX = vertical semi-axis length in screen space units\r\n",
      "0028": " FGDRIVER v4.02 - \"FG_ERASE\" - CLEAR THE ACTIVE VIDEO PAGE\r\n",
      "0029": " FGDRIVER v4.02 - \"FG_FADEIN\" - FADE IN HIDDEN PAGE\r\n\tBX = delay (0000h = fastest possible fade-in)\r\n",
      "002A": " FGDRIVER v4.02 - \"FG_FADEOUT\" - FADE OUT TO CURRENT COLOR\r\n\tBX = delay (0000h = fastest possible fade-out)\r\n",
      "002B": " FGDRIVER v4.02 - \"FG_FILLPAGE\" - FILL THE ACTIVE VIDEO PAGE\r\n",
      "002C": " FGDRIVER v4.02 - \"FG_FINDPAGE\" - FIND AVAILABLE VIRTUAL/LOGICAL PAGE\r\nReturn: AX = first available page number (virtual or logical page)\r\n",
      "002D": " FGDRIVER v4.02 - \"FG_FLICDONE\" - CLOSE FLIC FILE\r\n\tES:BX -> context descriptor (see AX=0030h)\r\n\nReturn: nothing\r\n",
      "002E": " FGDRIVER v4.02 - \"FG_FLICHEAD\" - READ FLI/FLC FILE HEADER\r\n\tES:BX -> FLICHEAD variable pointer record (see #03477)\r\n\nReturn: AX = status (see #03476)\r\n",
      "002F": " FGDRIVER v4.02 - \"FG_FLICMODE\" - GET OPTIMAL VIDEO MODE FOR FLI/FLC\r\n\tES:BX -> 128-byte buffer containing FLI/FLC file header (see AX=002Eh)\r\n\nReturn: AX = optimal 256-color graphics mode number\r\n\n\t    FFFFh if invalid file header\r\n",
      "0030": " FGDRIVER v4.02 - \"FG_FLICOPEN\" - OPEN FLI/FLC FILE\r\n\tES:BX -> FLICOPEN variable pointer record (see #03478)\r\n\nReturn: AX = status (see #03476)\r\n",
      "0031": " FGDRIVER v4.02 - \"FG_FLICPLAY\" - DISPLAY NEXT FRAME(S) IN FLI/FLC\r\n\tES:BX -> context descriptor (see AX=0030h)\r\n\n\tCX = number of frames to display starting at current frame\r\n\n\tDX = control flags (see #03479)\r\n\nReturn: AX = number of frames displayed\r\n",
      "0032": " FGDRIVER v4.02 - \"FG_FLICSIZE\" - GET IMAGE SIZE\r\n\tES:BX -> FLICSIZE variable pointer record (see #03480)\r\n\nReturn: image height/width buffers updated; height is set to FFFFh on error\r\n",
      "0033": " FGDRIVER v4.02 - \"FG_FLICSKIP\" - SKIP FRAME(S) IN FLI/FLC FILE\r\n\tES:BX -> context descriptor (see AX=0030h)\r\n\n\tCX = number of frames to skip\r\n\n\t    reset to first frame if skip count is negative\r\n\nReturn: AX = number of frames skipped (may be less than requested if EOF)\r\n\n\t    0000h if resetting to first frame\r\n",
      "0034": " FGDRIVER v4.02 - \"FG_FLIPMASK\" - DISPLAY INV CLIPPED IMAGE (MASKMAP)\r\n\tES:BX -> array containing image stored as a masking map (see #03475)\r\n\n\tCX = number of pixel runs in masking map\r\n\n\tDX = width of masking map in pixels\r\n",
      "0035": " FGDRIVER v4.02 - \"FG_FLOOD\" - FLOOD FILL ARBITRARY CLOSED REGION\r\n\tBX = starting column\r\n\n\tCX = starting row\r\n",
      "0036": " FGDRIVER v4.02 - \"FG_FLPIMAGE\" - DISPLAY INV CLIPPED IMAGE (BITMAP)\r\n\tES:BX -> mode-specific bitmap\r\n\n\tCX = width of bit map in bytes\r\n\n\tDX = height of bit map in pixel rows\r\n",
      "0037": " FGDRIVER v4.02 - \"FG_FONTSIZE\" - SPECIFY FONT SIZE FOR TEXT OUTPUT\r\n\tBX = desired character height in scan lines (8, 14, 16)\r\n",
      "0038": " FGDRIVER v4.02 - \"FG_FREEPAGE\" - FREE VIRTUAL OR LOGICAL VIDEO PAGE\r\n\tBX = page number (0000h-003Fh)\r\n\nReturn: AX = status (0000h,0001h,0007h,0009h) (see #03473)\r\n",
      "0039": " FGDRIVER v4.02 - \"FG_GETADDR\" - GET SEGMENT OF ACTIVE VIDEO PAGE\r\nReturn: AX = segment of active video page\r\n",
      "003A": " FGDRIVER v4.02 - \"FG_GETATTR\" - GET CHARACTER ATTRIB FOR POSITION\r\n\tBX = row\r\n\n\tCX = column\r\n\nReturn: AX = character attribute at specified location on active video page\r\n",
      "003B": " FGDRIVER v4.02 - \"FG_GETBANKS\" - GET SVGA READ AND WRITE BANKS\r\n\tES:BX -> GETBANKS variable pointer record (see #03481)\r\n\nReturn: nothing\r\n",
      "003C": " FGDRIVER v4.02 - \"FG_GETBLOCK\" - GRAB RECTANGLE OF DISPLAY\r\n\tES:BX -> buffer for screen contents\r\n\n\tCX = leftmost column\r\n\n\tDX = rightmost column\r\n\n\tSI = top row\r\n\n\tDI = bottom row\r\n",
      "003D": " FGDRIVER v4.02 - \"FG_GETCHAR\" - GET CHARACTER FOR SCREEN POSITION\r\n\tBX = row\r\n\n\tCX = column\r\n\nReturn: AX = character at specified location on active video page\r\n",
      "003E": " FGDRIVER v4.02 - \"FG_GETCLIP\" - GET CLIPPING REGION IN SCREEN SPACE\r\n\tES:BX -> GETCLIP variable pointer record (see #03482)\r\n\nReturn: variables specifed by GETCLIP structure updated\r\n",
      "003F": " FGDRIVER v4.02 - \"FG_GETCLOCK\" - GET CLOCK TICKS SINCE MIDNIGHT\r\nReturn: DX:AX = number of clock ticks since midnight\r\n",
      "0040": " FGDRIVER v4.02 - \"FG_GETCOLOR\" - GET CURRENT TEXT ATTRIBUTE\r\nReturn: AX = current text attribute or color index (graphics modes)\r\n",
      "0041": " FGDRIVER v4.02 - \"FG_GETDACS\" - GET VIDEO DAC CONTENTS\r\n\tCX = number of DAC registers to return (0001h to 0100h)\r\n\n\tDX = starting DAC register number (0000h to 00FFh)\r\n\n\tES:BX -> buffer for DAC red/green/blue triples\r\n",
      "0042": " FGDRIVER v4.02 - \"FG_GETENTRY\" - GET PAGE TYPE AND ADDRESS\r\n\tES:BX -> variable pointer record (see #03483)\r\n\n\tCX = page number (00h-3Fh)\r\n",
      "0043": " FGDRIVER v4.02 - \"FG_GETHPAGE\" - GET CURRENT HIDDEN VIDEO PAGE NUM\r\nReturn: AX = current hidden video page number (0000h-003Fh)\r\n",
      "0044": " FGDRIVER v4.02 - \"FG_GETIMAGE\" - STORE IMAGE AS BITMAP\r\n\tES:BX -> buffer for video mode-specific bitmap\r\n\n\tCX = width of bitmap in bytes\r\n\n\tDX = height of bitmap in pixel rows\r\n",
      "0045": " FGDRIVER v4.02 - \"FG_GETINDEX\" - GET COLOR VALUE FOR COLOR INDEX\r\n\tBX = color index (0000h to 00FFh)\r\n\nReturn: AX = color value for specified color index\r\n",
      "0046": " FGDRIVER v4.02 - \"FG_GETKEY\" - GET NEXT KEYSTROKE\r\n\tES:BX -> variable pointer record (see #03485)\r\n\nReturn: (after next keystroke if no typeahead) variables updated\r\n",
      "0047": " FGDRIVER v4.02 - \"FG_GETLINES\" - GET TEXT ROWS FOR CURR VIDEO MODE\r\nReturn: AX = number of text rows on screen in current video mode\r\n",
      "0048": " FGDRIVER v4.02 - \"FG_GETMAP\" - STORE IMAGE AS MODE-INDEPENDNT BITMAP\r\n\tES:BX -> buffer for video mode-independent bitmap\r\n\n\tCX = width of bitmap in bytes\r\n\n\tDX = height of bitmap in pixel rows\r\n\nReturn: each bit in bitmap is set if corresponding pixel is of the current\r\n\n\t  color, cleared otherwise\r\n",
      "0049": " FGDRIVER v4.02 - \"FG_GETMAXX\" - GET MAXIMUM COLUMN IN SCREEN SPACE\r\nReturn: AX = maximum X coordinate in screen space\r\n\n\t    (or character space if in text mode)\r\n",
      "004A": " FGDRIVER v4.02 - \"FG_GETMAXY\" - GET MAXIMUM ROW IN SCREEN SPACE\r\nReturn: AX = maximum Y coordinate in screen space\r\n\n\t\t(or character space if in text mode)\r\n",
      "004B": " FGDRIVER v4.02 - \"FG_GETMODE\" - GET CURRENT VIDEO MODE NUMBER\r\n\tES:BX -> WORD ???\r\n\nReturn: AX = current video mode number\r\n",
      "004C": " FGDRIVER v4.02 - \"FG_GETPAGE\" - GET ACTIVE VIDEO PAGE NUMBER\r\nReturn: AX = active video page (0000h-003Fh)\r\n",
      "004D": " FGDRIVER v4.02 - \"FG_GETPIXEL\" - GET COLOR OF SPECIFIED PIXEL\r\n\tBX = column in screen space\r\n\n\tCX = row in screen space\r\n\nReturn: AX = color value of pixel (0 to num_colors-1)\r\n\n\t    0000h in text modes\r\n",
      "004E": " FGDRIVER v4.02 - \"FG_GETRGB\" - GET VIDEO DAC REGISTER CONTENTS\r\n\tES:BX -> variable pointer record (see #03486)\r\n\n\tCX = DAC register number\r\n\nReturn: variables updated\r\n",
      "004F": " FGDRIVER v4.02 - \"FG_GETVIEW\" - GET VIEWPORT EXTREME LIMITS\r\n\tES:BX -> variable pointer record (see #03487)\r\n\nReturn: indicated variables updated\r\n",
      "0050": " FGDRIVER v4.02 - \"FG_GETVPAGE\" - GET VISIBLE VIDEO PAGE NUMBER\r\nReturn: AX = visible video page (0000h-003Fh)\r\n",
      "0051": " FGDRIVER v4.02 - \"FG_GETXBOX\" - GET WIDTH OF VERTICAL BOX LINES\r\nReturn: AX = width (in pixels) of left and right edges of rectangles\r\n",
      "0052": " FGDRIVER v4.02 - \"FG_GETXJOY\" - GET HORIZONTAL POSITION OF JOYSTICK\r\n\tBX = joystick number (0001h or 0002h)\r\n\nReturn: AX = horizontal position of joystick\r\n\n\t    FFFFh if joystick uninitialized or not present\r\n",
      "0053": " FGDRIVER v4.02 - \"FG_GETXJUST\" - GET HORIZONTAL JUSTIFICATION\r\nReturn: AX = string justification\r\n\n\t    0000h strings are centered around current graphics X position\r\n\n\t    0001h strings are right-justified at current graphics X position\r\n\n\t    FFFFh strings are left-justified at current graphics X position\r\n",
      "0054": " FGDRIVER v4.02 - \"FG_GETXPOS\" - GET GRAPHICS CURSOR COLUMN\r\nReturn: AX = screen space X coordinate of graphics cursor position\r\n",
      "0055": " FGDRIVER v4.02 - \"FG_GETYBOX\" - GET WIDTH OF HORIZONTAL BOX LINES\r\nReturn: AX = width (in pixels) of top and bottom edges of rectangles\r\n",
      "0056": " FGDRIVER v4.02 - \"FG_GETYJOY\" - GET VERTICAL POSITION OF JOYSTICK\r\n\tBX = joystick number (0001h or 0002h)\r\n\nReturn: AX = vertical position of joystick\r\n\n\t    FFFFh if joystick uninitialized or not present\r\n",
      "0057": " FGDRIVER v4.02 - \"FG_GETYJUST\" - GET VERTICAL JUSTIFICATION\r\nReturn: AX = string justification\r\n\n\t    0000h strings are centered around current graphics Y position\r\n\n\t    0001h strings have top edge at current graphics Y position\r\n\n\t    FFFFh strings have bottom edge at current graphics Y position\r\n",
      "0058": " FGDRIVER v4.02 - \"FG_GETYPOS\" - GET GRAPHICS CURSOR ROW\r\nReturn: AX = screen space Y coordinate of graphics cursor position\r\n",
      "0059": " FGDRIVER v4.02 - \"FG_HUSH\" - STOP ASYNCHRONOUS SOUND IMMEDIATELY\r\n",
      "005A": " FGDRIVER v4.02 - \"FG_HUSHNEXT\" - STOP ASYNCHRONOUS SOUND\r\n",
      "005B": " FGDRIVER v4.02 - \"FG_IMAGEBUF\" - SPECIFY TEMPORARY IMAGE BUFFER\r\n\tES:BX -> buffer to be used when creating or displaying GIF/PCX/PPR/SPR\r\n\n\t\t  images\r\n\n\tCX = size of buffer in bytes or 0000h to use internal buffer\r\n",
      "005C": " FGDRIVER v4.02 - \"FG_IMAGESIZ\" - DETERMINE IMAGE STORAGE REQUIREMENT\r\n\tBX = image width in pixels\r\n\n\tCX = image height in pixels\r\n",
      "005D": " FGDRIVER v4.02 - \"FG_INITEMS\" - INITIALIZE EXPANDED MEMORY USE\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh expanded memory manager inaccessible or not installed\r\n",
      "005E": " FGDRIVER v4.02 - \"FG_INITJOY\" - INITIALIZE JOYSTICK USE\r\n\tBX = joystick number (0001h or 0002h)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh joystick not connected or no game port\r\n",
      "005F": " FGDRIVER v4.02 - \"FG_INITPM\"??? - (NOT IMPLEMENTED)\r\n\t???\r\n\nReturn: ???\r\n",
      "0060": " FGDRIVER v4.02 - \"FG_INITXMS\" - INITIALIZE EXTENDED MEMORY USE\r\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFFh extended memory manager inaccessible or not installed\r\n",
      "0061": " FGDRIVER v4.02 - \"FG_INSIDE\" - CHECK IF POINT INSIDE CONVEX POLYGON\r\n\tES:BX -> vertex array\r\n\n\tCX = number of vertices\r\n\n\tDX = screen space column of point to test\r\n\n\tSI = screen space row of point to test\r\n\nReturn: AX = result\r\n\n\t    0000h point is outside polygon\r\n\n\t    0001h point is inside polygon\r\n\n\t    undefined if not a convex polygon\r\n",
      "0062": " FGDRIVER v4.02 - \"FG_INTJOY\" - GET KEYCODES CORRESP TO JOYSTICK POS\r\n\tCX = joystick number (0001h or 0002h)\r\n\n\tES:BX -> variable pointer record (see #03488)\r\n",
      "0063": " FGDRIVER v4.02 - \"FG_INTKEY\" - GET KEYSTROKE, NO WAIT\r\n\tES:BX -> variable pointer record (see #03489)\r\n\nReturn: variables updated\r\n",
      "0064": " FGDRIVER v4.02 - \"FG_INVERT\" - INVERT ORIENTATION OF BITMAP\r\n\tES:BX -> bitmap\r\n\n\tCX = width of bitmap in bytes\r\n\n\tDX = height of bitmap in pixel rows\r\n\nReturn: nothing\r\n",
      "0065": " FGDRIVER v4.02 - \"FG_JUSTIFY\" - SET TEXT OUTPUT JUSTIFICATION\r\n\tBX = horizontal justification\r\n\n\t      (00h centered, 01h right-justified, FFh left-justified)\r\n\n\tCX = vertical justification\r\n\n\t      (00h centered, 01h top of characters, FFh bottom of chars)\r\n",
      "0066": " FGDRIVER v4.02 - \"FG_KBINIT\" - ENABLE/DISABLE LOW-LEVEL KBD HANDLER\r\n\tBX = new state (0000h disabled, 0001h enabled)\r\n",
      "0067": " FGDRIVER v4.02 - \"FG_KBLAST\" - GET MOST RECENT SCANCODE PROCESSED\r\nReturn: AX = scancode for keypress most recently processed by FastGraph's\r\n\n\t      low-level keyboard handler, or 0000h if no keys since FG_KBINIT\r\n",
      "0068": " FGDRIVER v4.02 - \"FG_KBRESET\" - RESET LOW-LEVEL KEYBOARD HANDLER\r\n",
      "0069": " FGDRIVER v4.02 - \"FG_KBTEST\" - CHECK WHETHER SPECIFIED KEY PRESSED\r\n\tBX = scan code of desired key\r\n\nReturn: AX = state\r\n\n\t    0000h key is not pressed\r\n\n\t    0001h key is currently pressed\r\n",
      "006A": " FGDRIVER v4.02 - \"FG_LOADPCX\" - LOAD .PCX INTO ACTIVE VIRTUAL BUFFER\r\n\tES:BX -> ASCIZ filename for PCX image\r\n\n\tCX = control flags\r\n\n\t    bit 0: use current palette, overriding stored .PCX palette\r\n\n\t    bit 1: load at current graphics position, not stored position\r\n\n\t    bit 2: load image from FG_IMAGEBUF buffer instead of .PCX file\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not found\r\n\n\t    0002h not a .PCX file\r\n",
      "006B": " FGDRIVER v4.02 - \"FG_LOCATE\" - SET TEXT-MODE CURSOR POSITION\r\n\tBX = row\r\n\n\tCX = column\r\n",
      "006C": " FGDRIVER v4.02 - \"FG_MAKEPCX\" - CREATE PCX FILE FROM SCREEN WINDOW\r\n\tBX = left edge in screen space units\r\n\n\tCX = right edge in screen space units\r\n\n\tDX = top edge in screen space units\r\n\n\tSI = bottom edge in screen space units\r\n\n\tES:DI -> ASCIZ filename of PCX file to create\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not created\r\n",
      "006D": " FGDRIVER v4.02 - \"FG_MAKEPPR\" - CREATE PACKED PIXEL RUN FILE\r\n\tBX = left edge in screen space units\r\n\n\tCX = right edge in screen space units\r\n\n\tDX = top edge in screen space units\r\n\n\tSI = bottom edge in screen space units\r\n\n\tES:DI -> ASCIZ filename of PPR file to create\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not created\r\n",
      "006E": " FGDRIVER v4.02 - \"FG_MAKESPR\" - CREATE STANDARD PIXEL RUN FILE\r\n\tBX = left edge in screen space units\r\n\n\tCX = right edge in screen space units\r\n\n\tDX = top edge in screen space units\r\n\n\tSI = bottom edge in screen space units\r\n\n\tES:DI -> ASCIZ filename of SPR file to create\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not created\r\n",
      "006F": " FGDRIVER v4.02 - \"FG_MAPRGB\" - MAP COLOR COMPONENTS INTO PALETTE VAL\r\n\tBX = red component\r\n\n\tCX = green component\r\n\n\tDX = blue component\r\n\nReturn: AX = mode-specific palette value corresponding to specified components\r\n",
      "0070": " FGDRIVER v4.02 - \"FG_MEASURE\" - GET DELAY UNITS PER CLOCK TICK\r\nReturn: AX = delay units per clock tick (processor-dependent)\r\n",
      "0071": " FGDRIVER v4.02 - \"FG_MEMAVAIL\" - QUERY AMOUNT OF FREE MEMORY\r\nReturn: DX:AX = number of bytes of conventional memory available\r\n",
      "0072": " FGDRIVER v4.02 - \"FG_MEMORY\" - GET SIZE OF VIDEO MEMORY\r\nReturn: AX = size of video memory in KB\r\n",
      "0073": " FGDRIVER v4.02 - \"FG_MOUSE256\" - DEFINE 256-COLOR MOUSE CURSOR\r\n\tES:BX -> 512-byte cursor definition\r\n\n\tCX = X offset of hot-spot within mouse cursor\r\n\n\tDX = Y offset of hot-spot within mouse cursor\r\n\nReturn: nothing\r\n",
      "0074": " FGDRIVER v4.02 - \"FG_MOUSEBUT\" - GET MOUSE BUTTON PRESS/RELEASE CNTS\r\n\tCX = mouse button (1 = left press, 2 = right press, 3 = middle press,\r\n\n\t\t  -1=left release, -2=right release, -3=middle release)\r\n\n\tES:BX -> variable pointer record (see #03490)\r\n\nReturn: variables updated\r\n",
      "0075": " FGDRIVER v4.02 - \"FG_MOUSECUR\" - SPECIFY TEXT-MODE MOUSE CURSOR\r\n\tBX = screen mask\r\n\n\tCX = cursor mask\r\n",
      "0076": " FGDRIVER v4.02 - \"FG_MOUSEFIN\" - UNHOOK FASTGRAPH MOUSE HANDLER\r\n",
      "0077": " FGDRIVER v4.02 - \"FG_MOUSEINI\" - INITIALIZE MOUSE SUPPORT\r\nReturn: AX = status\r\n\n\t    0002h two-button mouse\r\n\n\t    0003h three-button mouse\r\n\n\t    FFFFh initialization failed\r\n",
      "0078": " FGDRIVER v4.02 - \"FG_MOUSELIM\" - SPECIFY MOUSE CURSOR LIMITS\r\n\tBX = left-most position allowed for mouse cursor\r\n\n\tCX = right-most position allowed\r\n\n\tDX = top-most position allowed\r\n\n\tSI = bottom-most position allowed\r\n",
      "0079": " FGDRIVER v4.02 - \"FG_MOUSEMOV\" - SET MOUSE CURSOR POSITION\r\n\tBX = new column\r\n\n\tCX = new row\r\n",
      "007A": " FGDRIVER v4.02 - \"FG_MOUSEPOS\" - GET CURRENT MOUSE POSITION\r\n\tES:BX -> variable pointer record (see #03491)\r\n",
      "007B": " FGDRIVER v4.02 - \"FG_MOUSEPTR\" - SPECIFY GRAPH-MODE MOUSE CURSOR\r\n\tES:BX -> masks (16-byte screen mask followed by 16-byte cursor mask)\r\n\n\tCX = X offset of hot spot from upper left corner\r\n\n\tDX = Y offset of hot spot from upper left corner\r\n",
      "007C": " FGDRIVER v4.02 - \"FG_MOUSESPD\" - SET MOUSE CURSOR SPEED\r\n\tBX = horizontal mickeys per eight pixels of movement (default 16)\r\n\n\tCX = vertical mickeys per eight pixels of movement (default 16)\r\n",
      "007D": " FGDRIVER v4.02 - \"FG_MOUSEVIS\" - SET MOUSE CURSOR VISIBILITY\r\n\tBX = new state (0000h invisible, 0001h visible)\r\n",
      "007E": " FGDRIVER v4.02 - \"FG_MOVE\" - SET GRAPHICS CURSOR POSITION\r\n\tBX = new column\r\n\n\tCX = new row\r\n",
      "007F": " FGDRIVER v4.02 - \"FG_MOVEREL\" - ADJUST GRAPHICS CURSOR POSITION\r\n\tBX = column offset\r\n\n\tCX = row offset\r\n",
      "0080": " FGDRIVER v4.02 - \"FG_MUSIC\" - PLAY SERIES OF NOTES\r\n\tES:BX -> '$'-terminated music string in BASIC PLAY format\r\n\nReturn: after music completed\r\n",
      "0081": " FGDRIVER v4.02 - \"FG_MUSICB\" - PLAY SERIES OF NOTES IN BACKGROUND\r\n\tCX = number of repetitions (negative = continuous play)\r\n\n\tES:BX -> '$'-terminated music string in BASIC PLAY format\r\n",
      "0082": " FGDRIVER v4.02 - \"FG_NUMLOCK\" - GET STATE OF NUMLOCK KEY\r\nReturn: AX = NumLock state (0000h off, 0001h on)\r\n",
      "0083": " FGDRIVER v4.02 - \"FG_PACK\" - CONVERT PIXEL-PER-BYTE TO PACKED BITMAP\r\n\tES:BX -> variable pointer record (see #03492)\r\n\n\tCX = width of bitmap in pixels\r\n\n\tDX = height of bitmap in pixels\r\n\nReturn: result bitmap buffer updated\r\n",
      "0084": " FGDRIVER v4.02 - \"FG_PAGESIZE\" - GET VIDEO PAGE SIZE FOR CURR MODE\r\nReturn: DX:AX = page size in bytes\r\n",
      "0085": " FGDRIVER v4.02 - \"FG_PAINT\" - FLOOD CLOSED REGION WITH COLOR\r\n\tBX = column\r\n\n\tCX = row\r\n",
      "0086": " FGDRIVER v4.02 - \"FG_PALETTE\" - SET PALETTE / SET VIDEO DAC REGISTER\r\n",
      "0087": " FGDRIVER v4.02 - \"FG_PALETTES\" - SET ALL PALETTE REGISTERS\r\n\tES:BX -> array of 16 WORDs containing values for palette registers\r\n\n\t\t  (or first 16 DAC registers in 256-color modes)\r\n",
      "0088": " FGDRIVER v4.02 - \"FG_PAN\" - SET SCREEN ORIGIN\r\n\tBX = new column for screen origin\r\n\n\tCX = new row for screen origin\r\n",
      "0089": " FGDRIVER v4.02 - \"FG_PATTERN\" - SPECIFY DISPLAY PATTERN FOR COLOR\r\n\tBX = index of pattern to define\r\n\n\tCX = number of predefined display pattern\r\n",
      "008A": " FGDRIVER v4.02 - \"FG_PCXHEAD\" - GET PCX FILE HEADER\r\n\tES:BX -> variable pointer record (see #03493)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFEh not a PCX file\r\n\n\t    FFFFh file does not exist\r\n",
      "008B": " FGDRIVER v4.02 - \"FG_PCXMODE\" - GET OPTIMAL VIDEO MODE FOR DISPLAY\r\n\tES:BX -> PCX header (see AX=008Ah)\r\n\nReturn: AX = optimal video mode for PCX file\r\n\n\t    FFFEh not a valid PCX header\r\n\n\t    FFFFh unable to determine compatible video mode\r\n",
      "008C": " FGDRIVER v4.02 - \"FG_PCXPAL\" - GET PALETTE STORED IN PCX FILE\r\n\tES:BX -> variable pointer record (see #03494)\r\n\nReturn: AX = number of colors in palette (16 or 256) or\r\n\n\t    FFFEh not a valid PCX file\r\n\n\t    FFFFh file not found\r\n",
      "008D": " FGDRIVER v4.02 - \"FG_PCXRANGE\" - GET EXTENT OF PCX IMAGE\r\n\tES:BX -> variable pointer record (see #03495)\r\n\nReturn: indicated variables updated; if the indicated header is not valid,\r\n\n\t  all of the coordinate variables are set to FFFFh\r\n",
      "008E": " FGDRIVER v4.02 - \"FG_PLAYING\" - DETERMINE WHETHER ASYNC SOUND ACTIVE\r\nReturn: AX = sound state (0 = no asynchronous sound, 1 = async sound playing)\r\n",
      "008F": " FGDRIVER v4.02 - \"FG_POINT\" - DISPLAY A PIXEL\r\n\tBX = column\r\n\n\tCX = row\r\n",
      "0090": " FGDRIVER v4.02 - \"FG_POINTX\" - DISPLAY A PIXEL IN XOR MODE\r\n\tBX = column\r\n\n\tCX = row\r\n",
      "0091": " FGDRIVER v4.02 - \"FG_POLYEDGE\" - SPECIFY INCLUSION OF FINAL PIXELS\r\n\tBX = edge flag\r\n\n\t    0000h include right- and bottom-edge pixels when drawing polygons\r\n\n\t\t  with FG_POLYFILL\r\n\n\t    0001h (default) exclue right- and bottom-edge pixels\r\n",
      "0092": " FGDRIVER v4.02 - \"FG_POLYFILL\" - DRAW A FILLED CONVEX POLYGON\r\n\tCX = number of vertices\r\n\n\tES:BX -> variable pointer record (see #03496)\r\n",
      "0093": " FGDRIVER v4.02 - \"FG_POLYGON\" - DRAW AN UNFILLED POLYGON\r\n\tCX = number of vertices in polygon\r\n\n\tES:BX -> variable pointer record (see #03497)\r\n",
      "0094": " FGDRIVER v4.02 - \"FG_POLYLINE\" - DRAW AN UNFILLED POLYGON\r\n\tCX = number of vertices in polygon\r\n\n\tES:BX -> vertex array (see #03498)\r\n",
      "0095": " FGDRIVER v4.02 - \"FG_POLYOFF\" - DEFINE POLYGON DRAWING OFFSET\r\n\tBX = horizontal offset (default 0)\r\n\n\tCX = vertical offset (default 0)\r\n",
      "0096": " FGDRIVER v4.02 - \"FG_PRINT\" - DISPLAY STRING OF HARDWARE CHARACTERS\r\n\tCX = length of string\r\n\n\tES:BX -> string to display\r\n",
      "0097": " FGDRIVER v4.02 - \"FG_PRINTC\" - DISPLAY STRING OF HW CHARS (CLIPPED)\r\n\tCX = length of string\r\n\n\tES:BX -> string to display\r\n",
      "0098": " FGDRIVER v4.02 - \"FG_PUTBLOCK\" - RESTORE RECTANGLE OF DISPLAY\r\n\tES:BX -> buffer containing previously-saved image\r\n\n\tCX = left edge\r\n\n\tDX = right edge\r\n\n\tSI = top edge\r\n\n\tDI = bottom edge\r\n",
      "0099": " FGDRIVER v4.02 - \"FG_PUTIMAGE\" - DISPLAY MODE-SPECIFIC BITMAP IMAGE\r\n\tES:BX -> buffer containing mode-specific bitmap\r\n\n\tCX = width in bytes\r\n\n\tDX = height in pixel rows\r\n",
      "009A": " FGDRIVER v4.02 - \"FG_QUIET\" - STOP CONTINUOUS SYNCHRONOUS SOUND\r\n",
      "009B": " FGDRIVER v4.02 - \"FG_RECT\" - DRAW UNFILLED RECTANGLE IN SCREEN SPACE\r\n\tBX = left edge column\r\n\n\tCX = right edge column\r\n\n\tDX = top edge row\r\n\n\tSI = bottom edge row\r\n",
      "009C": " FGDRIVER v4.02 - \"FG_RESET\" - ERASE SCREEN AND RESTORE SCREEN ATTR\r\n",
      "009D": " FGDRIVER v4.02 - \"FG_RESIZE\" - SET GRAPHICS MODE VIDEO PAGE SIZE\r\n\tBX = new page width in pixels\r\n\n\tCX = new page height in pixels\r\n",
      "009E": " FGDRIVER v4.02 - \"FG_RESTORE\" - COPY REGION FROM HIDDEN TO VIS PAGE\r\n\tBX = left edge column\r\n\n\tCX = right edge column\r\n\n\tDX = top edge row\r\n\n\tSI = bottom edge row\r\n",
      "009F": " FGDRIVER v4.02 - \"FG_RESUME\" - RESTART ASYNCHRONOUS SOUND\r\n",
      "00A0": " FGDRIVER v4.02 - \"FG_REVIMAGE\" - DISPLAY REVERSED IMAGE (BITMAP)\r\n\tES:BX -> mode-specific bitmap\r\n\n\tCX = width of bitmap in bytes\r\n\n\tDX = height of bitmap in pixel rows\r\n",
      "00A1": " FGDRIVER v4.02 - \"FG_REVMASK\" - DISPLAY REVERSED IMAGE (MASKING MAP)\r\n\tES:BX -> array containing image stored as a masking map (see #03475)\r\n\n\tCX = number of pixel runs in masking map\r\n\n\tDX = width of masking map in pixels\r\n",
      "00A2": " FGDRIVER v4.02 - \"FG_SAVE\" - COPY REGION FROM VISIBLE TO HIDDEN PAGE\r\n\tBX = left edge column\r\n\n\tCX = right edge column\r\n\n\tDX = top edge row\r\n\n\tSI = bottom edge row\r\n",
      "00A3": " FGDRIVER v4.02 - \"FG_SCALE\" - SCALE BITMAP\r\n\tES:BX -> variable pointer record (see #03499)\r\n\n\tCX = width of source bitmap in pixels (0 < width <= 1024)\r\n\n\tDX = height of source bitmap in pixels (0 < height <= 1024)\r\n\n\tSI = desired width of scaled bitmap (0 < width <= 1024)\r\n\n\tDI = desired height of scaled bitmap (0 < height <= 1024)\r\n\nReturn: nothing\r\n",
      "00A4": " FGDRIVER v4.02 - \"FG_SCRLOCK\" - GET STATE OF SCROLL LOCK KEY\r\nReturn: AX = ScrollLock state (0000h off, 0001h on)\r\n",
      "00A5": " FGDRIVER v4.02 - \"FG_SCROLL\" - VERTICALLY SCROLL SCREEN REGION\r\n\tBX = left edge column\r\n\n\tCX = right edge column\r\n\n\tDX = top edge row\r\n\n\tSI = bottom edge row\r\n\n\tDI = number of pixels by which to scroll (positive scrolls up,\r\n\n\t      negative scrolls down)\r\n\n\tES = type of scroll\r\n\n\t    0000h circular (rows scrolled off are copied to vacated rows)\r\n\n\t    else vacated rows are filled with the current color\r\n",
      "00A6": " FGDRIVER v4.02 - \"FG_SETATTR\" - SET TEXT-MODE CHARACTER ATTRIBUTE\r\n\tBX = foreground\r\n\n\tCX = background\r\n\n\tDX = blink (0000h nonblinking, 0001h blink)\r\n",
      "00A7": " FGDRIVER v4.02 - \"FG_SETBANKS\" - SET SVGA READ AND WRITE BANKS\r\n\tBX = memory bank from which to read (FFFFh leave unchanged)\r\n\n\tCX = memory bank to which to write (FFFFh leave unchanged)\r\n",
      "00A8": " FGDRIVER v4.02 - \"FG_SETCAPS\" - SET STATE OF CAPSLOCK KEY\r\n\tBX = new state (0000h off, 0001h on)\r\n",
      "00A9": " FGDRIVER v4.02 - \"FG_SETCLIP\" - SET CLIPPING REGION\r\n\tBX = left edge of clipping region\r\n\n\tCX = right edge of clipping region\r\n\n\tDX = top edge of clipping region\r\n\n\tSI = bottom edge of clipping region\r\n",
      "00AA": " FGDRIVER v4.02 - \"FG_SETCOLOR\" - SET CURRENT COLOR\r\n\tBX = new color index (or text attribute in text modes)\r\n",
      "00AB": " FGDRIVER v4.02 - \"FG_SETDACS\" - SET VIDEO DAC CONTENTS\r\n\tCX = number of DAC registers to set (0001h to 0100h)\r\n\n\tDX = starting DAC register number (0000h to 00FFh)\r\n\n\tES:BX -> buffer containing DAC red/green/blue triples\r\n",
      "00AC": " FGDRIVER v4.02 - \"FG_SETENTRY\" - SET TYPE AND ADDRESS OF VIDEO PAGE\r\n\tBX = page number (00h-3Fh)\r\n\n\tCX = page address\r\n\n\tDX = page type (see #03484 at AX=0042h)\r\n",
      "00AD": " FGDRIVER v4.02 - \"FG_SETFUNC\" - SET LOGICAL OPERATION FOR VIDEO OPS\r\n\tBX = operation\r\n\n\t    0000h replacement\r\n\n\t    0001h AND\r\n\n\t    0002h OR\r\n\n\t    0003h XOR\r\n",
      "00AE": " FGDRIVER v4.02 - \"FG_SETHPAGE\" - SET HIDDEN VIDEO PAGE\r\n\tBX = new hidden page (0000h to 003Fh)\r\n",
      "00AF": " FGDRIVER v4.02 - \"FG_SETLINES\" - SET TEXT ROWS ON SCREEN\r\n\tBX = new screen size (25, 43, 50)\r\n",
      "00B0": " FGDRIVER v4.02 - \"FG_SETMODE\" - SELECT VIDEO MODE AND INITIALIZE\r\n\tBX = new video mode or FFFFh for current mode (see #03500)\r\n\n\tES:DX -> WORD shareware splash screen flag\r\n",
      "00B1": " FGDRIVER v4.02 - \"FG_SETNUM\" - SET STATE OF NUMLOCK KEY\r\n\tBX = new state (0000h off, 0001h on)\r\n",
      "00B2": " FGDRIVER v4.02 - \"FG_SETPAGE\" - SET ACTIVE VIDEO PAGE\r\n\tBX = new video page (0000h to 003Fh)\r\n",
      "00B3": " FGDRIVER v4.02 - \"FG_SETRGB\" - SET VIDEO DAC REGISTER CONTENTS\r\n\tBX = palette or DAC register number\r\n\n\tCX = red color component\r\n\n\tDX = green component\r\n\n\tSI = blue component\r\n",
      "00B4": " FGDRIVER v4.02 - UNUSED\r\nReturn: AX = 0000h\r\n",
      "00B5": " FGDRIVER v4.02 - \"FG_SETVIEW\" - DEFINE VIEWPORT\r\n\tES:BX -> variable record (see #03501)\r\n\n\tCX = viewport's top edge in screen space\r\n\n\tDX = viewport's bottom edge in screen space\r\n\nReturn: nothing\r\n",
      "00B6": " FGDRIVER v4.02 - \"FG_SETVPAGE\" - SET VISIBLE VIDEO PAGE\r\n\tBX = new video page (0000h to 003Fh)\r\n",
      "00B7": " FGDRIVER v4.02 - \"FG_SHEAR\" - SHEAR UNPACKED BITMAP\r\n\tES:BX -> variable pointer record (see #03502)\r\n\n\tCX = bitmap width (0 < width <= 1024)\r\n\n\tDX = bitmap height (0 < height <= 1024)\r\n\n\tSI = size of resulting image (width for horiz. shear, height for vert.)\r\n\n\tDI = shear type\r\n\n\t    0000h horizontal shear to left\r\n\n\t    0001h horizontal shear to right\r\n\n\t    0002h vertical shear to left (left edge stretched up)\r\n\n\t    0003h vertical shear to right (right edge stretched up)\r\n\nReturn: nothing\r\n",
      "00B8": " FGDRIVER v4.02 - \"FG_SHOWFLIC\" - DISPLAY IMAGE FROM FLI/FLC FILE\r\n\tES:BX -> ASCIZ filename for FLI/FLC file\r\n\n\tCX = number of times to display image file (0000h = continuously)\r\n\n\tDX = control flags (see #03479 at AX=0031h)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not found\r\n\n\t    0002h not a valid FLI/FLC file\r\n",
      "00B9": " FGDRIVER v4.02 - \"FG_SHOWPCX\" - DISPLAY IMAGE FROM PCX FILE\r\n\tES:BX -> ASCIZ filename of PCX image\r\n\n\tCX = flags (see #03503)\r\n\nReturn: AX = status\r\n\n\t    0000h success\r\n\n\t    0001h file not found\r\n\n\t    0002h not a PCX file\r\n",
      "00BA": " FGDRIVER v4.02 - \"FG_SHOWPPR\" - DISPLAY IMAGE FROM PPR FILE\r\n\tES:BX -> ASCIZ filename of packed pixel run image\r\n\n\tCX = width in pixels (nonzero)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not found\r\n",
      "00BB": " FGDRIVER v4.02 - \"FG_SHOWSPR\" - DISPLAY IMAGE FROM SPR FILE\r\n\tES:BX -> ASCIZ filename of standard pixel run image\r\n\n\tCX = width in pixels (nonzero)\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    0001h file not found\r\n",
      "00BC": " FGDRIVER v4.02 - \"FG_SOUND\" - MAKE SOUND FOR SPECIFIED DURATION\r\n\tBX = frequency in Hertz (18-32767)\r\n\n\tCX = duration in clock ticks (0000h or negative for continuous sound)\r\n",
      "00BD": " FGDRIVER v4.02 - \"FG_SOUNDS\" - PLAY SOUNDS IN BACKGROUND\r\n\tCX = number of times to cycle through sound list\r\n\n\tES:BX -> sounds array (see #03504)\r\n",
      "00BE": " FGDRIVER v4.02 - \"FG_SPLIT\" - ENABLE/DISABLE SPLIT SCREEN ENVIRONMNT\r\n\tBX = beginning row for bottom half of split-screen\r\n",
      "00BF": " FGDRIVER v4.02 - \"FG_STALL\" - PAUSE FOR SPECIFIED DURATION\r\n\tBX = duration in processor-dependent delay units (see AX=0070h)\r\n\nReturn: after delay elapses\r\n",
      "00C0": " FGDRIVER v4.02 - \"FG_SUSPEND\" - TEMPORARILY STOP ASYNCHRONOUS SOUND\r\n",
      "00C1": " FGDRIVER v4.02 - \"FG_SVGAINIT\" - INITIALIZE FASTGRAPH SVGA KERNEL\r\n\tBX = method (see #03505)\r\n\nReturn: AX = status\r\n\n\t    0000h no VESA BIOS or supported SVGA chipset\r\n\n\t    0001h using VESA BIOS\r\n\n\t    0002h-0016h specific chipset being used (same as \"method\" below)\r\n",
      "00C2": " FGDRIVER v4.02 - \"FG_SVGASTAT\" - GET SVGA CHIPSET INFORMATION\r\nReturn: AX = chipset information (see #03506)\r\n",
      "00C3": " FGDRIVER v4.02 - \"FG_SVGAVER\" - GET FASTGRAPH SVGA KERNEL VERSION\r\n\tES:BX -> variable pointer record (see #03507)\r\n",
      "00C4": " FGDRIVER v4.02 - \"FG_TCDEFINE\" - DEFINE TRANSPARENCY OF COLOR INDEX\r\n\tBX = color index\r\n\n\tCX = transparency (00h opaque, other transparent)\r\n",
      "00C5": " FGDRIVER v4.02 - \"FG_TCMASK\" - SET TRANSPARENT COLORS\r\n\tBX = colors to consider transparent (bit 0 = color 0, etc)\r\n",
      "00C6": " FGDRIVER v4.02 - \"FG_TCXFER\" - COPY REGION EXCLUDING TRANSPARENT\r\n\tCX = source video page\r\n\n\tDX = destination video page\r\n\n\tES:BX -> copy record (see #03508)\r\n",
      "00C7": " FGDRIVER v4.02 - \"FG_TESTMODE\" - CHECK IF VIDEO MODE AVAILABLE\r\n\tBX = desired video mode (00h-17h, also 18h-1Dh after \"FG_SVGAINIT\")\r\n\n\tCX = required number of video pages (ignore memory size if <= 0)\r\n\nReturn: AX = status\r\n\n\t    0000h mode not available with requested number of pages\r\n\n\t    0001h mode is available\r\n",
      "00C8": " FGDRIVER v4.02 - \"FG_TEXT\" - DISPLAY STRING OF CHARACTERS\r\n\tCX = length of string\r\n\n\tES:BX -> string\r\n",
      "00C9": " FGDRIVER v4.02 - \"FG_TEXTC\" - DISPLAY STRING OF CHARACTERS (CLIPPED)\r\n\tCX = length of string\r\n\n\tES:BX -> string\r\n",
      "00CA": " FGDRIVER v4.02 - \"FG_TRANSFER\" - COPY REGION\r\n\tCX = source video page\r\n\n\tDX = destination video page\r\n\n\tES:BX -> copy record (see #03508)\r\n",
      "00CB": " FGDRIVER v4.02 - \"FG_UNPACK\" - EXPAND MODE-SPECIFIC BITMAP\r\n\tES:BX -> variable pointer record (see #03509)\r\n\n\tCX = size of source bitmap in bytes\r\n\nReturn: result buffer filled\r\n",
      "00CC": " FGDRIVER v4.02 - \"FG_VBADDR\" - GET ADDRESS OF VIRTUAL BUFFER\r\n\tBX = virtual buffer handle (0000h-001Fh)\r\n\nReturn: DX:AX -> virtual buffer\r\n",
      "00CD": " FGDRIVER v4.02 - \"FG_VBALLOC\" - CREATE VIRTUAL BUFFER\r\n\tBX = width of virtual buffer in pixels\r\n\n\tCX = height in pixels\r\n\nReturn: AX = handle for virtual buffer, or\r\n\n\t    FFFEh out of memory\r\n\n\t    FFFFh virtual buffer table full\r\n",
      "00CE": " FGDRIVER v4.02 - \"FG_VBCLOSE\" - CLOSE ACTIVE VIRTUAL BUFFER\r\n",
      "00CF": " FGDRIVER v4.02 - \"FG_VBCOPY\" - COPY RECT BETWEEN VIRTUAL BUFFERS\r\n\tES:BX -> variable record (see #03510)\r\n\n\tCX = handle for source virtual buffer\r\n\n\tDX = handle for destination virtual buffer\r\n",
      "00D0": " FGDRIVER v4.02 - \"FG_VBCUT\" - COPY RECT FROM VIDEO TO VIRTUAL BUFFER\r\n\tBX = source region's left edge\r\n\n\tCX = source region's right edge\r\n\n\tDX = source region's top edge\r\n\n\tSI = source region's bottom edge\r\n\n\tDI = X coordinate of destination's upper left corner\r\n\n\tES = Y coordinate of destination's upper left corner\r\n",
      "00D1": " FGDRIVER v4.02 - \"FG_VBDEFINE\" - CREATE VIRTUAL BUFFER\r\n\tES:BX -> memory block for virtual buffer\r\n\n\tCX = buffer width in pixels\r\n\n\tDX = buffer height in pixels\r\n\nReturn: AX = virtual buffer handle\r\n\n\t    FFFFh on error\r\n",
      "00D2": " FGDRIVER v4.02 - \"FG_VBFREE\" - RELEASE VIRTUAL BUFFER\r\n\tBX = virtual buffer handle\r\n",
      "00D3": " FGDRIVER v4.02 - \"FG_VBHANDLE\" - GET ACTIVE VIRTUAL BUFFER'S HANDLE\r\nReturn: AX = handle for active virtual buffer\r\n",
      "00D4": " FGDRIVER v4.02 - \"FG_VBINIT\" - INITIALIZE VIRTUAL BUFFER ENVIRONMENT\r\nReturn: nothing\r\n",
      "00D5": " FGDRIVER v4.02 - \"FG_VBOPEN\" - MAKE VIRTUAL BUFFER ACTIVE\r\n\tBX = virtual buffer handle\r\n\nReturn: AX = status\r\n\n\t    0000h successful\r\n\n\t    FFFEh no buffer defined for specified handle\r\n\n\t    FFFFh invalid buffer handle\r\n",
      "00D6": " FGDRIVER v4.02 - \"FG_VBPASTE\" - COPY RECT FROM VIRTUAL BUF TO VIDEO\r\n\tBX = source region's left edge\r\n\n\tCX = source region's right edge\r\n\n\tDX = source region's top edge\r\n\n\tSI = source region's bottom edge\r\n\n\tDI = X coordinate of destination's upper left corner\r\n\n\tES = Y coordinate of destination's upper left corner\r\n",
      "00D7": " FGDRIVER v4.02 - \"FG_VBTCCOPY\" - COPY RECTANGLE BETWEEN VIRTUAL BUFS\r\n\tES:BX -> variable record (see #03511)\r\n\n\tCX = source virtual buffer's handle\r\n\n\tDX = destination virtual buffer's handle\r\n",
      "00D8": " FGDRIVER v4.02 - \"FG_VBTCXFER\" - COPY RECTANGLE TO ACTIVE VIDEO PAGE\r\n\tBX = source region's left edge\r\n\n\tCX = source region's right edge\r\n\n\tDX = source region's top edge\r\n\n\tSI = source region's bottom edge\r\n\n\tDI = X coordinate of destination's upper left corner\r\n\n\tES = Y coordinate of destination's upper left corner\r\n",
      "00D9": " FGDRIVER v4.02 - \"FG_VBUNDEF\" - RELEASE HANDLE FOR VIRTUAL BUFFER\r\n\tBX = virtual buffer handle\r\n",
      "00DA": " FGDRIVER v4.02 - \"FG_VGASTATE\" - SAVE/RESTORE VGA CONTROLLER STATE\r\n\tBX = direction (0000h save, else restore)\r\n",
      "00DB": " FGDRIVER v4.02 - \"FG_VOICE\" - START SOUND\r\n\tBX = channel on TI sound chip\r\n\n\t    1-3 = channels 1-3, 4 = channel 4 with periodic noise,\r\n\n\t    5 = channel 4 with white noise\r\n\n\tCX = frequency in Hz (18-32767 for channels 1-3; 0=512 Hz, 1=1024 Hz,\r\n\n\t      2=2048 Hz for channels 4 and 5)\r\n\n\tDX = volume\r\n\n\tSI = duration in clock ticks (continuous if <= 0)\r\n",
      "00DC": " FGDRIVER v4.02 - \"FG_VOICES\" - PLAY SOUNDS IN BACKGROUND\r\n\tES:BX -> tone array (see #03512)\r\n\n\tCX = number of times to repeat tone array\r\n",
      "00DD": " FGDRIVER v4.02 - \"FG_WAITFOR\" - DELAY FOR SPECIFIED DURATION\r\n\tBX = duration in clock ticks\r\n\nReturn: after delay elapses\r\n",
      "00DE": " FGDRIVER v4.02 - \"FG_WAITKEY\" - FLUSH KEYBOARD BUFFER AND AWAIT KEY\r\nReturn: after next key pressed\r\n",
      "00DF": " FGDRIVER v4.02 - \"FG_WAITVR\" - ENABLE/DISABLE VERTICAL RETRACE WAIT\r\n\tBX = new state (0000h disabled, 0001h enabled)\r\n",
      "00E0": " FGDRIVER v4.02 - \"FG_WHERE\" - GET CURRENT CURSOR POSITION\r\n\tES:BX -> variable pointers (see #03513)\r\n\nReturn: indicated variables filled with cursor row and column for active\r\n\n\t  display\r\n",
      "00E1": " FGDRIVER v4.02 - \"FG_XALPHA\" - CONVERT SCREEN COLUMN TO CHAR COLUMN\r\n\tBX = screen space column\r\n\nReturn: AX = character space column containing specified coordinate\r\n",
      "00E2": " FGDRIVER v4.02 - \"FG_XCONVERT\" - CONVERT CHAR COLUMN TO SCREEN COL\r\n\tBX = character space column\r\n\nReturn: AX = screen space column of leftmost pixel in specified character col\r\n",
      "00E3": " FGDRIVER v4.02 - \"FG_XVIEW\" - CONVERT VIEWPORT COORDINATE\r\n\tBX = horizontal viewport coordinate\r\n\nReturn: AX = screen space X coordinate corresponding to supplied coordinate\r\n",
      "00E4": " FGDRIVER v4.02 - \"FG_YALPHA\" - CONVERT SCREEN ROW TO CHARACTER ROW\r\n\tBX = screen space row\r\n\nReturn: AX = character space row containing specified coordinate\r\n",
      "00E5": " FGDRIVER v4.02 - \"FG_YCONVERT\" - CONVERT CHARACTER ROW TO SCREEN ROW\r\n\tBX = character space row\r\n\nReturn: AX = screen space row of topmost pixel in specified character row\r\n",
      "00E6": " FGDRIVER v4.02 - \"FG_YVIEW\" - TRANSLATE VERTICAL VIEWPORT COORDINATE\r\n\tBX = viewport Y coordinate\r\n\nReturn: AX = screen space row for viewport coordinate\r\n"
    },
    "AH": {
      "01": " Cswitch - GIVE UP REST OF TIME-SLICE\r\n",
      "02": " Cswitch - WAIT FOR SEMAPHORE\r\n\tDX = semaphore number (0-63)\r\n\nReturn: AX = FFFFh bad semaphore number\r\n\n\t     else  success\r\n",
      "03": " Cswitch - CHECK SEMAPHORE\r\n\tDX = semaphore number (0-63)\r\n\nReturn: AX = status\r\n\n\t    FFFFh not owned\r\n\n\t    else  owned\r\n",
      "04": " Cswitch - TRIGGER SEMAPHORE\r\n\tDX = semaphore number (0-63)\r\n\nReturn: AX = status\r\n\n\t    FFFFh bad semaphore number\r\n\n\t    else  success\r\n",
      "05": " Cswitch - SLEEP\r\n\tBX = seconds to sleep\r\n",
      "06": " Cswitch - SUSPEND\r\n",
      "07": " Cswitch - SPAWN\r\n\tES:BX -> function address to start executing at\r\n\n\tCX = priority (1-10)\r\n\nReturn: AX = result/status\r\n\n\t    FFFDh  no free memory control blocks\r\n\n\t    FFFEh  no free task control blocks\r\n\n\t    FFFFh  not enough memory to create new task stack\r\n\n\t    >0\t   the tcb number of the new task, indicating no error\r\n",
      "08": " Cswitch - WAKE UP TASK\r\n\tBX = tcb identifier\r\n",
      "09": " Cswitch - SET PRIORITY\r\n\tBX = new base priority (1-10)\r\n",
      "0A": " Cswitch - TEST MESSAGE QUEUE\r\n\tDX = queue number (0-63)\r\n\nReturn: AX = result/message size\r\n\n\t    0000h nothing on queue\r\n\n\t    FFFFh bad queue number\r\n\n\t    else  number of bytes in first message in queue\r\n",
      "0B": " Cswitch - SEND MESSAGE\r\n\tCX = number of bytes to write\r\n\n\tDS:SI -> buffer\r\n\n\tDX = queue number (0-63)\r\n\nReturn: AX = result/message size\r\n\n\t    0000h no message was on queue\r\n\n\t    FFFEh triggered by something arriving, redo the call\r\n\n\t    FFFFh bad queue number\r\n\n\t    else  number of bytes in message\r\n",
      "0C": " Cswitch - READ MESSAGE\r\n\tCX = number of bytes to read\r\n\n\tDS:SI -> buffer\r\n\n\tDX = queue number (0-63)\r\n\nReturn: AX = status\r\n\n\t    FFFFh bad queue number\r\n\n\t    else  number of bytes transferred\r\n",
      "0D": " Cswitch - DON'T ALLOW TASK TO BE SWAPPED OUT\r\n",
      "0E": " Cswitch - ALLOW TASK TO BE SWAPPED OUT\r\n",
      "0F": " Cswitch - LOAD AND RUN PROGRAM FROM DISK\r\n\tES:BX -> command line\r\n\n\tCX = priority (1-10)\r\n\n\tDX = background flag (nonzero allows loading to EMS)\r\n\nReturn: AX = status\r\n\n\t    0000h task loader queue is full\r\n\n\t    0001h  no error\r\n",
      "10": " Cswitch - TERMINATE SPAWNED PROGRAM\r\n",
      "11": " Cswitch - GET TCB INFORMATION\r\n\tES:BX -> a pointer which will be set to the tcb address\r\n\nReturn: AX = tcb indentifier\r\n",
      "12": " Cswitch - GET TCB ADDRESS\r\n\tES:BX -> a pointer which will be set to the tcb table address\r\n\nReturn: AX = tcb indentifier\r\n",
      "13": " Cswitch - CHECK STATUS OF PREVIOUS LOAD_TASK\r\nReturn: AX = result\r\n\n\t    FFFCh no Memory Control Blocks available\r\n\n\t    FFFDh no TCBs available\r\n\n\t    FFFEh insufficient memory\r\n\n\t    FFFFh cannot open file\r\n\n\t    0000h load in progress (not done yet)\r\n\n\t    else  tcb indentifier\r\n"
    }
  },
  "65": " EZRECV v1.0 - API\r\n\tAX = function\r\n\n\t    0000h ???\r\n\n\t\tReturn: AX = ??? or FFFFh\r\n\n\t    0001h ???\r\n\n\t\tReturn: AX = status (0000h or 0001h)\r\n\n\t    0002h ???\r\n\n\t\tReturn: AX = status (0000h or 0001h)\r\n\n\t    0003h set ??? to 0001h\r\n\n\t\tReturn: AX = 0000h\r\n\n\t    0004h ???\r\n\n\t\tReturn: AX = ???\r\n\nReturn: BH = COM port being used\r\n\n\tBL = speed???\r\n\n\tCH = ???\r\n\n\tCL = ???\r\n\n\tDX = ???\r\n\n\tDS = ???\r\n\n\tES = EZRECV data segment\r\n",
  "67": {
    "AX": {
      "DE00": " Virtual Control Program Interface - INSTALLATION CHECK\r\nReturn: AH = status\r\n\n\t    00h VCPI is present\r\n\n\t\tBH = major version number\r\n\n\t\tBL = minor version number\r\n\n\t    nonzero  VCPI not present\r\n",
      "DE01": " Virtual Control Program Interface - GET PROTECTED MODE INTERFACE\r\n\tES:DI -> 4K page table buffer\r\n\n\tDS:SI -> three descriptor table entries in GDT\r\n\n\t\tfirst becomes code segment descriptor, other two for use by\r\n\n\t\t  main control program\r\n\nReturn: AH = 00h successful\r\n\n\t    DI -> first unused page table entry in buffer\r\n\n\t    EBX -> protected mode entry point in code segment (see #03664)\r\n\n\tAH = nonzero  failed\r\n",
      "DE02": " Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS\r\nReturn: AH = 00h  successful\r\n\n\t    EDX = physical address of highest 4K memory page\r\n\n\tAH nonzero: failed\r\n",
      "DE03": " Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES\r\nReturn: AH = 00h  successful\r\n\n\t    EDX = number of free 4K pages\r\n\n\tAH nonzero: failed\r\n",
      "DE04": " Virtual Control Program Interface - ALLOCATE A 4K PAGE\r\nReturn: AH = 00h successful\r\n\n\t    EDX = physical address of allocated page\r\n\n\tAH nonzero: failed\r\n",
      "DE05": " Virtual Control Program Interface - FREE 4K PAGE\r\n\tEDX = physical address of 4K page\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t    nonzero failed\r\n",
      "DE06": " Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB\r\n\tCX = page number (linear address shifted right 12 bits)\r\n\nReturn: AH = status\r\n\n\t    00h successful\r\n\n\t\tEDX = physical address of page\r\n\n\t    nonzero invalid page number (AH = 8Bh recommended)\r\n",
      "DE07": " Virtual Control Program Interface - READ CR0\r\nReturn: AH = 00h\r\n\n\tEBX = value of Control Register 0\r\n",
      "DE08": " Virtual Control Program Interface - READ DEBUG REGISTERS\r\n\tES:DI -> array of 8 DWORDs\r\n\nReturn: AH = 00h\r\n\n\tbuffer filled with DR0 first, DR7 last, DR4 and DR5 unused\r\n",
      "DE09": " Virtual Control Program Interface - SET DEBUG REGISTERS\r\n\tES:DI -> array of 8 DWORDs holding new values of debug registers\r\n\nReturn: AH = 00h\r\n",
      "DE0A": " Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS\r\nReturn: AH = 00h successful\r\n\n\t    BX = first vector used by master 8259 (IRQ0)\r\n\n\t    CX = first vector used by slave 8259 (IRQ8)\r\n\n\tAH nonzero: failed\r\n",
      "DE0B": " Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS\r\n\tBX = first vector used by master 8259\r\n\n\tCX = first vector used by slave 8259\r\n\n\tinterrupts disabled\r\n\nReturn: AH = 00h successful\r\n\n\tAH nonzero: failed\r\n",
      "DE0C": " Virtual Control Program Interface - SWITCH TO PROTECTED MODE\r\n\tESI = linear address in first megabyte of values for system\r\n\n\t      registers (see #03665)\r\n\n\tinterrupts disabled\r\n\nReturn: interrupts disabled\r\n\n\tGDTR, IDTR, LDTR, TR loaded\r\n\n\tSS:ESP must have at least 16 bytes space, and the entry point is\r\n\n\t      required to set up a new stack before enabling interrupts\r\n\n\tEAX, ESI, DS, ES, FS, GS destroyed\r\n"
    }
  },
  "6B": {
    "AX": {
      "0000": " Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED WRITE\r\n\tCX = length\r\n\n\tES:BX -> buffer\r\n\nReturn: CX = number of bytes written\r\n",
      "0100": " Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED READ\r\n\tCX = length of buffer\r\n\n\tES:BX -> buffer\r\n\nReturn: CX = number of bytes read\r\n",
      "0600": " Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - CONTROL\r\n\tCX = command\r\n\n\t    02h send break\r\n\n\t    04h disconnect\r\n\n\t    06h hold\r\n\nReturn: CF clear if successful\r\n\n\t    AL = 00h\r\n\n\tCF set on error\r\n\n\t    AX < 0\r\n",
      "0700": " Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - GET STATUS\r\nReturn: CH <> 00h if connection active\r\n"
    },
    "AH": {
      "02": " Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - INSTALL CHECK\r\n\tAL nonzero\r\n\nReturn: AL = 00h if present and OK\r\n",
      "10": " NPC NCSI EXTENDED SERIAL I/O - GET STATUS\r\n\tAL = connection ID (Novell TELAPI.EXE)\r\n\n\tCX = ???\r\n\n\tES:BX -> buffer for status (see #03730)\r\n\nReturn: CF clear if successful\r\n\n\t    CL = ???\r\n\n\t    CH = ???\r\n\n\tCF set on error\r\n\n\t???\r\n",
      "11": " NPC NCSI EXTENDED SERIAL I/O - ALLOCATE A VIRTUAL CIRCUIT\r\n\tDX = 0001h\r\n\n\tAL = 00h\r\n\n\tES:BX -> service name string (8 characters, blank-padded)\r\n\nReturn: CF clear if successful\r\n\n\t    AL = virtual circuit number allocated (01h for Novell TELAPI.EXE)\r\n\n\t    CL = ??? (01h for Novell TELAPI.EXE)\r\n\n\t    CH = ??? (01h for Novell TELAPI.EXE)\r\n\n\tCF set on error\r\n\n\t    ???\r\n",
      "12": " NPC NCSI EXTENDED SERIAL I/O - VIRTUAL CIRCUIT STATUS\r\n\tAL = virtual circuit number (0-8)\r\n\nReturn: CF clear if successful\r\n\n\t    AL = virtual circuit number\r\n\n\t    CL = virtual circuit's state\r\n\n\t\t00h idle\r\n\n\t\t01h Telnet session, in command state\r\n\n\t\t02h Telnet session, connected to host\r\n\n\t\t03h-06h ??? (not returned by TelAPI)\r\n\n\tCF set on error\r\n\n\t    AL = error code\r\n\n\t\tE2h invalid virtual circuit number\r\n\n\t\tE4h specified virtual circuit not allocated\r\n",
      "13": " NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE REQUEST/REPLY SERVICE NAME\r\n\tAL = virtual circuit number\r\n\n\tCL = direction (00h get, nonzero set)\r\n\n\tES:BX -> buffer for/containing service name\r\n\nReturn: ???\r\n",
      "14": " NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE SERVICE ADDRESS\r\n\tAL = virtual circuit number\r\n\n\tES:BX -> buffer for/containing service address\r\n\nReturn: ???\r\n",
      "15": " NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE VIRTUAL CIRCUIT CONFIG\r\n\tAL = virtual circuit number\r\n\n\tCL = direction (00h get, nonzero set)\r\n\n\tES:BX -> buffer for/containing virtual circuit config (see #03731)\r\n\nReturn: ES:BX buffer filled\r\n",
      "16": " NPC NCSI EXTENDED SERIAL I/O - LOG AND/OR INITIALIZE VIRTUAL CIRCUIT\r\n\tAL = virtual circuit number\r\n\n\tCL = ??? switch (00h, ???)\r\n\nReturn: CF clear if successful\r\n\n\t    AL = virtual circuit number\r\n\n\tCF set on error\r\n\n\t    ???\r\n",
      "17": " NPC NCSI EXTENDED SERIAL I/O - DISCONNECT A VIRTUAL CIRCUIT\r\n\tAL = virtual circuit number\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t???\r\n",
      "18": " NPC NCSI EXTENDED SERIAL I/O - WRITE DATA ON A VIRTUAL CIRCUIT\r\n\tAL = virtual circuit number\r\n\n\tCX = number of characters to send\r\n\n\tES:BX -> buffer containing characters to be sent\r\n\nReturn: CF clear if successful\r\n\n\tCF set on error\r\n\n\t???\r\n",
      "19": " NPC NCSI EXTENDED SERIAL I/O - READ DATA ON A VIRTUAL CIRCUIT\r\n\tAL = virtual circuit number\r\n\n\tCX = number of characters to read\r\n\n\tES:BX -> buffer for received characters\r\n\nReturn: CX = 0000h if failed\r\n\n\tCX = nonzero (possibly number of characters received) if successful\r\n",
      "1A": " NPC NCSI EXTENDED SERIAL I/O - RECEIVE STATUS\r\n\t???\r\n\nReturn: ???\r\n",
      "1B": " NPC NCSI EXTENDED SERIAL I/O - TRANSMIT STATUS\r\n\t???\r\n\nReturn: ???\r\n",
      "1C": " NPC NCSI EXTENDED SERIAL I/O - CLEAR RECEIVE BUFFER\r\n\tAL = circuit number\r\n\nReturn: nothing\r\n",
      "1D": " NPC NCSI EXTENDED SERIAL I/O - TRANSMIT BUFFER CONTROL\r\n\t???\r\n\nReturn: ???\r\n",
      "1E": " NPC NCSI EXTENDED SERIAL I/O - ISSUE CONTROL REQUEST\r\n\t???\r\n\nReturn: ???\r\n",
      "1F": " NPC NCSI EXTENDED SERIAL I/O - EXTERNAL STATUS\r\n\t???\r\n\nReturn: ???\r\n",
      "20": " Connection Manager CLIENT.EXE - ???\r\n\t???\r\n\nReturn: ???\r\n",
      "21": " NPC NCSI EXTENDED SERIAL I/O - QUERY NAME SERVICE\r\n\tAL = virtual circuit number\r\n\n\tCL = ??? (00h or 01h)\r\n\n\tES:BX -> buffer for service name structure (see #03732)\r\n\nReturn: CF clear if successful\r\n\n\t    ES:BX buffer filled\r\n\n\tCF set on error\r\n"
    }
  },
  "6D": {
    "AX": {
      "BD60": " Matrox Multiple Monitor Support v1.0 - ???\r\n\tDS:SI -> buffer containing ??? (see #03735)\r\n\n\t???\r\n\nReturn: AX = 00BDh if function executed\r\n\n\t   ???:SI -> 22-byte buffer (inside TSR) filled with ??? (see #03735)\r\n\n\tAX unchanged if function disabled\r\n",
      "BD61": " Matrox Multiple Monitor Support v1.0 - GET VIDEO MODE INFORMATION\r\n\tBX = width in pixels (bits 13-0)\r\n\n\t    bit 14: ???\r\n\n\t    bit 15: ???\r\n\n\tCX = height in pixels\r\n\nReturn: AL = BDh if function supported\r\n\n\t    AH = status\r\n\n\t\t00h successful\r\n\n\t\t01h failed (resolution/flags not supported)\r\n\n\t    CX:BX -> video mode data structure (see #03736)\r\n\n\t\t  (first word is FFFFh if unsupported resolution)\r\n\n\t    EAX high word cleared\r\n",
      "BD6F": " Matrox Multiple Monitor Support v1.0 - INSTALLATION CHECK\r\n\tBL = subfunction\r\n\n\t    00h installation check\r\n\n\t    01h disable TSR\r\n\n\t    02h enable TSR (see AX=BD60h)\r\n\nReturn: AX = 00BDh if installed\r\n",
      "BDFF": " Matrox Multiple Monitor Support v1.0 - UNHOOK INTERRUPT (UNINSTALL)\r\nReturn: AX = 00BDh if supported\r\n"
    }
  },
  "70": " IRQ8 - CMOS REAL-TIME CLOCK\r\n",
  "71": " IRQ9 - REDIRECTED TO INT 0A BY BIOS\r\n",
  "72": " IRQ10 - RESERVED\r\n",
  "73": " IRQ11 - RESERVED\r\n",
  "74": " IRQ12 - POINTING DEVICE (PS)\r\n",
  "75": " IRQ13 - MATH COPROCESSOR EXCEPTION (AT and up)\r\n",
  "76": " IRQ14 - HARD DISK CONTROLLER OPERATION COMPLETE (AT and later)\r\n",
  "77": " IRQ15 - RESERVED (AT,PS)\r\n",
  "78": {
    "AX": {
      "0000": " HugeRealMode Driver - INSTALLATION CHECK\r\nReturn: AX = DBCAh if installed\r\n",
      "0001": " HugeRealMode Driver - GET ENTRY POINT\r\nReturn: ES:BX -> far call entry point (see #03788,#03803)\r\n"
    }
  },
  "79": " AVATAR.SYS - FAST GET KEYSTROKE\r\nReturn: CF set if no keystroke available\r\n\n\t    AX = FFFFh\r\n\n\tCF clear if key pressed\r\n\n\t    AX = keystroke\r\n",
  "7A": " DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ2\r\n",
  "7B": " DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ3\r\n",
  "7C": " DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ4\r\n",
  "7D": " YTERM 1.4 - CLOCK SUPPORT\r\n",
  "7E": " YTERM 1.4 - ???\r\n",
  "7F": {
    "AH": {
      "00": " MultiLink Advanced v1.0+ - ENQUEUE SYSTEM RESOURCE\r\n\tBX = resource identifier\r\n\n\tAL = wait flag\r\n\nReturn: AL = status\r\n\n\t    00h successful\r\n\n\t    01h resource not available\r\n\n\t    02h user error\r\n",
      "01": " TIGA Communications Driver v2.05 - GET ENTRY POINTS\r\nReturn: BX = 1234h if installed\r\n\n\t    DX:AX -> array of FAR entry points\r\n\n\t    CH = driver major version\r\n\n\t    CL = driver minor version\r\n",
      "02": " MultiLink Advanced v1.0+ - RELEASE CPU\r\nReturn: ???\r\n",
      "09": " MultiLink Advanced v1.0+ - SET TASK PRIORITY\r\n\tAL = priority (0-7)\r\n\nReturn: nothing\r\n",
      "0A": " MultiLink Advanced v1.0+ - SET KEYBOARD TEST STATUS\r\n\tAL = task-switch status\r\n\n\t    00h normal (disable task when it repeatedly polls keyboard)\r\n\n\t    01h disable task until keyboard input available\r\n\n\t    FFh never disable task\r\n\nReturn: ???\r\n"
    },
    "AX": {
      "0105": " IBM XGA Adapter Interface (XGAAIDOS.SYS)\r\nReturn: CF set on error\r\n\n\tCF clear if successful\r\n\n\t    CX:DX -> array of FAR pointers to entry points (see #03877)\r\n",
      "0106": " HDILOAD Mach32 Adapter Interface - UNINSTALL\r\nReturn: AX = 0105h if successfully unloaded\r\n",
      "1234": " TIGA Communications Driver v2.05 - UNINSTALL\r\n",
      "2525": " TIGA Communications Driver v2.05 - ???\r\n\tBX = ???\r\n\nReturn: ???\r\n",
      "4321": " TIGA Communications Driver v2.05 - INSTALLATION CHECK\r\nReturn: AX = 0000h if installed\r\n",
      "5555": " TIGA Communications Driver v2.05 - ???\r\n\tBX = ???\r\n\nReturn: ???\r\n",
      "ABCD": " IBM 8516 Touch Screen Device Driver - GET API ENTRY\r\n\tBX = 0000h\r\n\nReturn: AX = total number of functions available\r\n\n\tES:BX -> entry point array (see #03967)\r\n"
    }
  },
  "80": " Phar Lap 386|DOS-Extender - RELOCATED PRINT-SCREEN\r\n",
  "D8": " Screen Thief v1.00 - RELOCATED IRQ0\r\n",
  "D9": " Screen Thief v1.00 - RELOCATED IRQ1\r\n",
  "DA": " Screen Thief v1.00 - RELOCATED IRQ2\r\n",
  "DB": " Screen Thief v1.00 - RELOCATED IRQ3\r\n",
  "DC": " Screen Thief v1.00 - RELOCATED IRQ4\r\n",
  "DD": " Screen Thief v1.00 - RELOCATED IRQ5\r\n",
  "DE": " Screen Thief v1.00 - RELOCATED IRQ6\r\n",
  "DF": " Screen Thief v1.00 - RELOCATED IRQ7\r\n",
  "F4": " DoubleDOS - GIVE UP REST OF CURRENT CLOCK TICK AND ALL OF NEXT TICK\r\n",
  "F5": " DoubleDOS - ???\r\n",
  "F6": " DoubleDOS - ???\r\n",
  "F7": " DoubleDOS - ???\r\n",
  "F8": " DoubleDOS - ???\r\n",
  "F9": " DoubleDOS - ???\r\n",
  "FA": " DoubleDOS - TURN OFF TIMESHARING\r\n",
  "FB": " DoubleDOS - TURN ON TIMESHARING\r\n",
  "FC": " DoubleDOS - GET CURRENT SCREEN BUFFER ADDRESS\r\nReturn: ES = segment of display buffer\r\n",
  "FD": {
    "AH": {
      "01": " TFPCX - TEST FOR CHARACTER WAITING\r\nReturn: AX = status\r\n\n\t    0000h no characters waiting\r\n\n\t    0001h character available for input\r\n",
      "02": " TFPCX - GET CHARACTER\r\nReturn: AL = character\r\n",
      "03": " TFPCX - OUTPUT CHARACTER\r\n\tAL = character to send\r\n\nReturn: nothing\r\n",
      "FE": " TFPCX - GET VERSION\r\nReturn: AH = major version\r\n\n\tAL = minor version\r\n"
    }
  },
  "FE": " AT/XT286/PS50+ - destroyed by return from protected mode\r\n",
  "FF": {
    "BX": {
      "0000": " PC/FORTH - GRAPHICS API - VIDEO STATUS CHANGE\r\n\tDS:SI -> FORTH program counter\r\n\n\tSS:BP -> FORTH parameter stack\r\n\n\tSS:SP -> FORTH return stack\r\n\n\tDS:DX -> FORTH video parameter area\r\n"
    }
  }
}